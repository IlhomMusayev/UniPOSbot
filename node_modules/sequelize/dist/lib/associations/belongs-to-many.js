"use strict";var S=Object.defineProperty,z=Object.defineProperties;var E=Object.getOwnPropertyDescriptors;var _=Object.getOwnPropertySymbols;var x=Object.prototype.hasOwnProperty,P=Object.prototype.propertyIsEnumerable;var k=(y,r,e)=>r in y?S(y,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):y[r]=e,o=(y,r)=>{for(var e in r||(r={}))x.call(r,e)&&k(y,e,r[e]);if(_)for(var e of _(r))P.call(r,e)&&k(y,e,r[e]);return y},A=(y,r)=>z(y,E(r));var D=(y,r)=>S(y,"name",{value:r,configurable:!0});const w=require("./../utils"),C=require("./helpers"),f=require("lodash"),I=require("./base"),T=require("./belongs-to"),U=require("./has-many"),M=require("./has-one"),$=require("../errors").AssociationError,v=require("../errors").EmptyResultError,j=require("../operators");class O extends I{constructor(r,e,t){super(r,e,t);if(this.options.through===void 0||this.options.through===!0||this.options.through===null)throw new $(`${r.name}.belongsToMany(${e.name}) requires through option, pass either a string or a model`);if(this.options.through.model||(this.options.through={model:t.through}),this.associationType="BelongsToMany",this.targetAssociation=null,this.sequelize=r.sequelize,this.through=o({},this.options.through),this.isMultiAssociation=!0,this.doubleLinked=!1,!this.as&&this.isSelfAssociation)throw new $("'as' must be defined for many-to-many self-associations");if(this.as?(this.isAliased=!0,f.isPlainObject(this.as)?(this.options.name=this.as,this.as=this.as.plural):this.options.name={plural:this.as,singular:w.singularize(this.as)}):(this.as=this.target.options.name.plural,this.options.name=this.target.options.name),this.combinedTableName=w.combineTableNames(this.source.tableName,this.isSelfAssociation?this.as||this.target.tableName:this.target.tableName),this.isSelfAssociation&&(this.targetAssociation=this),f.each(this.target.associations,s=>{s.associationType==="BelongsToMany"&&s.target===this.source&&this.options.through.model===s.options.through.model&&(this.paired=s,s.paired=this)}),this.sourceKey=this.options.sourceKey||this.source.primaryKeyAttribute,this.sourceKeyField=this.source.rawAttributes[this.sourceKey].field||this.sourceKey,this.options.targetKey?(this.targetKey=this.options.targetKey,this.targetKeyField=this.target.rawAttributes[this.targetKey].field||this.targetKey):(this.targetKeyDefault=!0,this.targetKey=this.target.primaryKeyAttribute,this.targetKeyField=this.target.rawAttributes[this.targetKey].field||this.targetKey),this._createForeignAndOtherKeys(),typeof this.through.model=="string"&&(this.sequelize.isDefined(this.through.model)?this.through.model=this.sequelize.model(this.through.model):this.through.model=this.sequelize.define(this.through.model,{},Object.assign(this.options,{tableName:this.through.model,indexes:[],paranoid:this.through.paranoid?this.through.paranoid:!1,validate:{}}))),Object.assign(this.options,f.pick(this.through.model.options,["timestamps","createdAt","updatedAt","deletedAt","paranoid"])),this.paired){let s=!1;this.targetKeyDefault&&(this.targetKey=this.paired.sourceKey,this.targetKeyField=this.paired.sourceKeyField,this._createForeignAndOtherKeys()),this.paired.targetKeyDefault&&this.paired.targetKey!==this.sourceKey&&(delete this.through.model.rawAttributes[this.paired.otherKey],this.paired.targetKey=this.sourceKey,this.paired.targetKeyField=this.sourceKeyField,this.paired._createForeignAndOtherKeys(),s=!0),this.otherKeyDefault&&(this.otherKey=this.paired.foreignKey),this.paired.otherKeyDefault&&this.paired.otherKey!==this.foreignKey&&(delete this.through.model.rawAttributes[this.paired.otherKey],this.paired.otherKey=this.foreignKey,s=!0),s&&this.paired._injectAttributes()}this.through&&(this.throughModel=this.through.model),this.options.tableName=this.combinedName=this.through.model===Object(this.through.model)?this.through.model.tableName:this.through.model,this.associationAccessor=this.as;const i=f.upperFirst(this.options.name.plural),h=f.upperFirst(this.options.name.singular);this.accessors={get:`get${i}`,set:`set${i}`,addMultiple:`add${i}`,add:`add${h}`,create:`create${h}`,remove:`remove${h}`,removeMultiple:`remove${i}`,hasSingle:`has${h}`,hasAll:`has${i}`,count:`count${i}`}}_createForeignAndOtherKeys(){f.isObject(this.options.foreignKey)?(this.foreignKeyAttribute=this.options.foreignKey,this.foreignKey=this.foreignKeyAttribute.name||this.foreignKeyAttribute.fieldName):(this.foreignKeyAttribute={},this.foreignKey=this.options.foreignKey||w.camelize([this.source.options.name.singular,this.sourceKey].join("_"))),f.isObject(this.options.otherKey)?(this.otherKeyAttribute=this.options.otherKey,this.otherKey=this.otherKeyAttribute.name||this.otherKeyAttribute.fieldName):(this.options.otherKey||(this.otherKeyDefault=!0),this.otherKeyAttribute={},this.otherKey=this.options.otherKey||w.camelize([this.isSelfAssociation?w.singularize(this.as):this.target.options.name.singular,this.targetKey].join("_")))}_injectAttributes(){this.identifier=this.foreignKey,this.foreignIdentifier=this.otherKey,f.each(this.through.model.rawAttributes,(g,c)=>{g.primaryKey===!0&&g._autoGenerated===!0&&(c===this.foreignKey||c===this.otherKey?g.primaryKey=!1:delete this.through.model.rawAttributes[c],this.primaryKeyDeleted=!0)});const e=this.source.rawAttributes[this.sourceKey].type,t=this.sourceKeyField,h=this.target.rawAttributes[this.targetKey].type,s=this.targetKeyField,a=o({type:e},this.foreignKeyAttribute),u=o({type:h},this.otherKeyAttribute);if(this.primaryKeyDeleted===!0)u.primaryKey=a.primaryKey=!0;else if(this.through.unique!==!1){let g;typeof this.options.uniqueKey=="string"&&this.options.uniqueKey!==""?g=this.options.uniqueKey:g=[this.through.model.tableName,this.foreignKey,this.otherKey,"unique"].join("_"),u.unique=a.unique=g}return this.through.model.rawAttributes[this.foreignKey]||(this.through.model.rawAttributes[this.foreignKey]={_autoGenerated:!0}),this.through.model.rawAttributes[this.otherKey]||(this.through.model.rawAttributes[this.otherKey]={_autoGenerated:!0}),this.options.constraints!==!1&&(a.references={model:this.source.getTableName(),key:t},a.onDelete=this.options.onDelete||this.through.model.rawAttributes[this.foreignKey].onDelete,a.onUpdate=this.options.onUpdate||this.through.model.rawAttributes[this.foreignKey].onUpdate,a.onDelete||(a.onDelete="CASCADE"),a.onUpdate||(a.onUpdate="CASCADE"),u.references={model:this.target.getTableName(),key:s},u.onDelete=this.through.model.rawAttributes[this.otherKey].onDelete||this.options.onDelete,u.onUpdate=this.through.model.rawAttributes[this.otherKey].onUpdate||this.options.onUpdate,u.onDelete||(u.onDelete="CASCADE"),u.onUpdate||(u.onUpdate="CASCADE")),Object.assign(this.through.model.rawAttributes[this.foreignKey],a),Object.assign(this.through.model.rawAttributes[this.otherKey],u),this.through.model.refreshAttributes(),this.identifierField=this.through.model.rawAttributes[this.foreignKey].field||this.foreignKey,this.foreignIdentifierField=this.through.model.rawAttributes[this.otherKey].field||this.otherKey,this.paired&&!this.paired.foreignIdentifierField&&(this.paired.foreignIdentifierField=this.through.model.rawAttributes[this.paired.otherKey].field||this.paired.otherKey),this.toSource=new T(this.through.model,this.source,{foreignKey:this.foreignKey}),this.manyFromSource=new U(this.source,this.through.model,{foreignKey:this.foreignKey}),this.oneFromSource=new M(this.source,this.through.model,{foreignKey:this.foreignKey,sourceKey:this.sourceKey,as:this.through.model.name}),this.toTarget=new T(this.through.model,this.target,{foreignKey:this.otherKey}),this.manyFromTarget=new U(this.target,this.through.model,{foreignKey:this.otherKey}),this.oneFromTarget=new M(this.target,this.through.model,{foreignKey:this.otherKey,sourceKey:this.targetKey,as:this.through.model.name}),this.paired&&this.paired.otherKeyDefault&&(this.paired.toTarget=new T(this.paired.through.model,this.paired.target,{foreignKey:this.paired.otherKey}),this.paired.oneFromTarget=new M(this.paired.target,this.paired.through.model,{foreignKey:this.paired.otherKey,sourceKey:this.paired.targetKey,as:this.paired.through.model.name})),C.checkNamingCollision(this),this}mixin(r){const e=["get","count","hasSingle","hasAll","set","add","addMultiple","remove","removeMultiple","create"],t={hasSingle:"has",hasAll:"has",addMultiple:"add",removeMultiple:"remove"};C.mixinMethods(this,r,e,t)}async get(r,e){e=w.cloneDeep(e)||{};const t=this.through;let i,h;this.scope&&(i=o({},this.scope)),e.where={[j.and]:[i,e.where]},Object(t.model)===t.model&&(h={},h[this.foreignKey]=r.get(this.sourceKey),t.scope&&Object.assign(h,t.scope),e.through&&e.through.where&&(h={[j.and]:[h,e.through.where]}),e.include=e.include||[],e.include.push({association:this.oneFromTarget,attributes:e.joinTableAttributes,required:!0,paranoid:f.get(e.through,"paranoid",!0),where:h}));let s=this.target;return Object.prototype.hasOwnProperty.call(e,"scope")&&(e.scope?s=s.scope(e.scope):s=s.unscoped()),Object.prototype.hasOwnProperty.call(e,"schema")&&(s=s.schema(e.schema,e.schemaDelimiter)),s.findAll(e)}async count(r,e){const t=this.target.sequelize;e=w.cloneDeep(e),e.attributes=[[t.fn("COUNT",t.col([this.target.name,this.targetKeyField].join("."))),"count"]],e.joinTableAttributes=[],e.raw=!0,e.plain=!0;const i=await this.get(r,e);return parseInt(i.count,10)}async has(r,e,t){Array.isArray(e)||(e=[e]),t=A(o({raw:!0},t),{scope:!1,attributes:[this.targetKey],joinTableAttributes:[]});const i=e.map(s=>s instanceof this.target?s.where():{[this.targetKey]:s});t.where={[j.and]:[{[j.or]:i},t.where]};const h=await this.get(r,t);return f.differenceWith(i,h,(s,a)=>f.isEqual(s[this.targetKey],a[this.targetKey])).length===0}async set(r,e,t){t=t||{};const i=this.sourceKey,h=this.targetKey,s=this.identifier,a=this.foreignIdentifier;e===null?e=[]:e=this.toInstanceArray(e);const u=o({[s]:r.get(i)},this.through.scope),g=D(c=>{const q=[],d=[],p=t.through||{},F=e.filter(m=>!c.some(n=>n[a]===m.get(h)));for(const m of c){const n=e.find(l=>m[a]===l.get(h));if(!n)q.push(m);else{let l=n[this.through.model.name];l instanceof this.through.model&&(l={});const K=o(o({},p),l);Object.keys(K).length&&d.push(this.through.model.update(K,Object.assign(t,{where:{[s]:r.get(i),[a]:n.get(h)}})))}}if(q.length>0&&d.push(this.through.model.destroy(A(o({},t),{where:o({[s]:r.get(i),[a]:q.map(m=>m[a])},this.through.scope)}))),F.length>0){const m=F.map(n=>o(A(o(o({},p),n[this.through.model.name]),{[s]:r.get(i),[a]:n.get(h)}),this.through.scope));d.push(this.through.model.bulkCreate(m,o({validate:!0},t)))}return Promise.all(d)},"updateAssociations");try{const c=await this.through.model.findAll(A(o({},t),{where:u,raw:!0}));return await g(c)}catch(c){if(c instanceof v)return g([]);throw c}}async add(r,e,t){if(!e)return Promise.resolve();t=o({},t);const i=this,h=i.sourceKey,s=i.targetKey,a=i.identifier,u=i.foreignIdentifier,g=t.through||{};e=i.toInstanceArray(e);const c=o({[a]:r.get(h),[u]:e.map(d=>d.get(s))},i.through.scope),q=D(d=>{const p=[],F=[],m=[];for(const n of e){const l=d&&d.find(K=>K[u]===n.get(s));if(!l)F.push(n);else{const K=n[i.through.model.name],b=o(o({},g),K);Object.keys(b).some(N=>b[N]!==l[N])&&m.push(n)}}if(F.length>0){const n=F.map(l=>{const K=l[i.through.model.name],b=o(o({},g),K);return b[a]=r.get(h),b[u]=l.get(s),Object.assign(b,i.through.scope),b});p.push(i.through.model.bulkCreate(n,o({validate:!0},t)))}for(const n of m){let l=n[i.through.model.name];const K=o(o({},g),l);l instanceof i.through.model&&(l={}),p.push(i.through.model.update(K,Object.assign(t,{where:{[a]:r.get(h),[u]:n.get(s)}})))}return Promise.all(p)},"updateAssociations");try{const d=await i.through.model.findAll(A(o({},t),{where:c,raw:!0})),[p]=await q(d);return p}catch(d){if(d instanceof v)return q();throw d}}remove(r,e,t){const i=this;t=t||{},e=i.toInstanceArray(e);const h={[i.identifier]:r.get(i.sourceKey),[i.foreignIdentifier]:e.map(s=>s.get(i.targetKey))};return i.through.model.destroy(A(o({},t),{where:h}))}async create(r,e,t){const i=this;t=t||{},e=e||{},Array.isArray(t)&&(t={fields:t}),i.scope&&(Object.assign(e,i.scope),t.fields&&(t.fields=t.fields.concat(Object.keys(i.scope))));const h=await i.target.create(e,t);return await r[i.accessors.add](h,f.omit(t,["fields"])),h}verifyAssociationAlias(r){return typeof r=="string"?this.as===r:r&&r.plural?this.as===r.plural:!this.isAliased}}D(O,"BelongsToMany"),module.exports=O,module.exports.BelongsToMany=O,module.exports.default=O;
//# sourceMappingURL=belongs-to-many.js.map
