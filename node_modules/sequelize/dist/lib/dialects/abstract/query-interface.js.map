{
  "version": 3,
  "sources": ["../../../../lib/dialects/abstract/query-interface.js"],
  "sourcesContent": ["'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst Transaction = require('../../transaction');\nconst QueryTypes = require('../../query-types');\n\n/**\n * The interface that Sequelize uses to talk to all databases\n */\nclass QueryInterface {\n  constructor(sequelize, queryGenerator) {\n    this.sequelize = sequelize;\n    this.queryGenerator = queryGenerator;\n  }\n\n  /**\n   * Create a database\n   *\n   * @param {string} database  Database name to create\n   * @param {object} [options] Query options\n   * @param {string} [options.charset] Database default character set, MYSQL only\n   * @param {string} [options.collate] Database default collation\n   * @param {string} [options.encoding] Database default character set, PostgreSQL only\n   * @param {string} [options.ctype] Database character classification, PostgreSQL only\n   * @param {string} [options.template] The name of the template from which to create the new database, PostgreSQL only\n   *\n   * @returns {Promise}\n   */\n  async createDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createDatabaseQuery(database, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a database\n   *\n   * @param {string} database  Database name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropDatabase(database, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropDatabaseQuery(database);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Create a schema\n   *\n   * @param {string} schema    Schema name to create\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async createSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.createSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a schema\n   *\n   * @param {string} schema    Schema name to drop\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropSchema(schema, options) {\n    options = options || {};\n    const sql = this.queryGenerator.dropSchema(schema);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllSchemas(options) {\n    options = options || {};\n\n    if (!this.queryGenerator._dialect.supports.schemas) {\n      return this.sequelize.drop(options);\n    }\n    const schemas = await this.showAllSchemas(options);\n    return Promise.all(schemas.map(schemaName => this.dropSchema(schemaName, options)));\n  }\n\n  /**\n   * Show all schemas\n   *\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<Array>}\n   */\n  async showAllSchemas(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: this.sequelize.QueryTypes.SELECT\n    };\n\n    const showSchemasSql = this.queryGenerator.showSchemasQuery(options);\n\n    const schemaNames = await this.sequelize.query(showSchemasSql, options);\n\n    return _.flatten(schemaNames.map(value => value.schema_name ? value.schema_name : value));\n  }\n\n  /**\n   * Return database version\n   *\n   * @param {object}    [options]      Query options\n   * @param {QueryType} [options.type] Query type\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async databaseVersion(options) {\n    return await this.sequelize.query(\n      this.queryGenerator.versionQuery(),\n      { ...options, type: QueryTypes.VERSION }\n    );\n  }\n\n  /**\n   * Create a table with given set of attributes\n   *\n   * ```js\n   * queryInterface.createTable(\n   *   'nameOfTheNewTable',\n   *   {\n   *     id: {\n   *       type: Sequelize.INTEGER,\n   *       primaryKey: true,\n   *       autoIncrement: true\n   *     },\n   *     createdAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     updatedAt: {\n   *       type: Sequelize.DATE\n   *     },\n   *     attr1: Sequelize.STRING,\n   *     attr2: Sequelize.INTEGER,\n   *     attr3: {\n   *       type: Sequelize.BOOLEAN,\n   *       defaultValue: false,\n   *       allowNull: false\n   *     },\n   *     //foreign key usage\n   *     attr4: {\n   *       type: Sequelize.INTEGER,\n   *       references: {\n   *         model: 'another_table_name',\n   *         key: 'id'\n   *       },\n   *       onUpdate: 'cascade',\n   *       onDelete: 'cascade'\n   *     }\n   *   },\n   *   {\n   *     engine: 'MYISAM',    // default: 'InnoDB'\n   *     charset: 'latin1',   // default: null\n   *     schema: 'public',    // default: public, PostgreSQL only.\n   *     comment: 'my table', // comment for table\n   *     collate: 'latin1_danish_ci' // collation, MYSQL only\n   *   }\n   * )\n   * ```\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of table attributes to create\n   * @param {object} [options] create table and query options\n   * @param {Model}  [model] model class\n   *\n   * @returns {Promise}\n   */\n  async createTable(tableName, attributes, options, model) {\n    let sql = '';\n\n    options = { ...options };\n\n    if (options && options.uniqueKeys) {\n      _.forOwn(options.uniqueKeys, uniqueKey => {\n        if (uniqueKey.customIndex === undefined) {\n          uniqueKey.customIndex = true;\n        }\n      });\n    }\n\n    if (model) {\n      options.uniqueKeys = options.uniqueKeys || model.uniqueKeys;\n    }\n\n    attributes = _.mapValues(\n      attributes,\n      attribute => this.sequelize.normalizeAttribute(attribute)\n    );\n\n    // Postgres requires special SQL commands for ENUM/ENUM[]\n    await this.ensureEnums(tableName, attributes, options, model);\n\n    if (\n      !tableName.schema &&\n      (options.schema || !!model && model._schema)\n    ) {\n      tableName = this.queryGenerator.addSchema({\n        tableName,\n        _schema: !!model && model._schema || options.schema\n      });\n    }\n\n    attributes = this.queryGenerator.attributesToSQL(attributes, { table: tableName, context: 'createTable' });\n    sql = this.queryGenerator.createTableQuery(tableName, attributes, options);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Drop a table from database\n   *\n   * @param {string} tableName Table name to drop\n   * @param {object} options   Query options\n   *\n   * @returns {Promise}\n   */\n  async dropTable(tableName, options) {\n    // if we're forcing we should be cascading unless explicitly stated otherwise\n    options = { ...options };\n    options.cascade = options.cascade || options.force || false;\n\n    const sql = this.queryGenerator.dropTableQuery(tableName, options);\n\n    await this.sequelize.query(sql, options);\n  }\n\n  async _dropAllTables(tableNames, skip, options) {\n    for (const tableName of tableNames) {\n      // if tableName is not in the Array of tables names then don't drop it\n      if (!skip.includes(tableName.tableName || tableName)) {\n        await this.dropTable(tableName, { ...options, cascade: true } );\n      }\n    }\n  }\n\n  /**\n   * Drop all tables from database\n   *\n   * @param {object} [options] query options\n   * @param {Array}  [options.skip] List of table to skip\n   *\n   * @returns {Promise}\n   */\n  async dropAllTables(options) {\n    options = options || {};\n    const skip = options.skip || [];\n\n    const tableNames = await this.showAllTables(options);\n    const foreignKeys = await this.getForeignKeysForTables(tableNames, options);\n\n    for (const tableName of tableNames) {\n      let normalizedTableName = tableName;\n      if (_.isObject(tableName)) {\n        normalizedTableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      for (const foreignKey of foreignKeys[normalizedTableName]) {\n        await this.sequelize.query(this.queryGenerator.dropForeignKeyQuery(tableName, foreignKey));\n      }\n    }\n    await this._dropAllTables(tableNames, skip, options);\n  }\n\n  /**\n   * Rename a table\n   *\n   * @param {string} before    Current name of table\n   * @param {string} after     New name from table\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async renameTable(before, after, options) {\n    options = options || {};\n    const sql = this.queryGenerator.renameTableQuery(before, after);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Get all tables in current database\n   *\n   * @param {object}    [options] Query options\n   * @param {boolean}   [options.raw=true] Run query in raw mode\n   * @param {QueryType} [options.type=QueryType.SHOWTABLE] query type\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showAllTables(options) {\n    options = {\n      ...options,\n      raw: true,\n      type: QueryTypes.SHOWTABLES\n    };\n\n    const showTablesSql = this.queryGenerator.showTablesQuery(this.sequelize.config.database);\n    const tableNames = await this.sequelize.query(showTablesSql, options);\n    return _.flatten(tableNames);\n  }\n\n  /**\n   * Describe a table structure\n   *\n   * This method returns an array of hashes containing information about all attributes in the table.\n   *\n   * ```js\n   * {\n   *    name: {\n   *      type:         'VARCHAR(255)', // this will be 'CHARACTER VARYING' for pg!\n   *      allowNull:    true,\n   *      defaultValue: null\n   *    },\n   *    isBetaMember: {\n   *      type:         'TINYINT(1)', // this will be 'BOOLEAN' for pg!\n   *      allowNull:    false,\n   *      defaultValue: false\n   *    }\n   * }\n   * ```\n   *\n   * @param {string} tableName table name\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise<object>}\n   */\n  async describeTable(tableName, options) {\n    let schema = null;\n    let schemaDelimiter = null;\n\n    if (typeof options === 'string') {\n      schema = options;\n    } else if (typeof options === 'object' && options !== null) {\n      schema = options.schema || null;\n      schemaDelimiter = options.schemaDelimiter || null;\n    }\n\n    if (typeof tableName === 'object' && tableName !== null) {\n      schema = tableName.schema;\n      tableName = tableName.tableName;\n    }\n\n    const sql = this.queryGenerator.describeTableQuery(tableName, schema, schemaDelimiter);\n    options = { ...options, type: QueryTypes.DESCRIBE };\n\n    try {\n      const data = await this.sequelize.query(sql, options);\n      /*\n       * If no data is returned from the query, then the table name may be wrong.\n       * Query generators that use information_schema for retrieving table info will just return an empty result set,\n       * it will not throw an error like built-ins do (e.g. DESCRIBE on MySql).\n       */\n      if (_.isEmpty(data)) {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      return data;\n    } catch (e) {\n      if (e.original && e.original.code === 'ER_NO_SUCH_TABLE') {\n        throw new Error(`No description found for \"${tableName}\" table. Check the table name and schema; remember, they _are_ case sensitive.`);\n      }\n\n      throw e;\n    }\n  }\n\n  /**\n   * Add a new column to a table\n   *\n   * ```js\n   * queryInterface.addColumn('tableA', 'columnC', Sequelize.STRING, {\n   *    after: 'columnB' // after option is only supported by MySQL\n   * });\n   * ```\n   *\n   * @param {string} table     Table to add column to\n   * @param {string} key       Column name\n   * @param {object} attribute Attribute definition\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async addColumn(table, key, attribute, options) {\n    if (!table || !key || !attribute) {\n      throw new Error('addColumn takes at least 3 arguments (table, attribute name, attribute definition)');\n    }\n\n    options = options || {};\n    attribute = this.sequelize.normalizeAttribute(attribute);\n    return await this.sequelize.query(this.queryGenerator.addColumnQuery(table, key, attribute), options);\n  }\n\n  /**\n   * Remove a column from a table\n   *\n   * @param {string} tableName      Table to remove column from\n   * @param {string} attributeName  Column name to remove\n   * @param {object} [options]      Query options\n   */\n  async removeColumn(tableName, attributeName, options) {\n    return this.sequelize.query(this.queryGenerator.removeColumnQuery(tableName, attributeName), options);\n  }\n\n  normalizeAttribute(dataTypeOrOptions) {\n    let attribute;\n    if (Object.values(DataTypes).includes(dataTypeOrOptions)) {\n      attribute = { type: dataTypeOrOptions, allowNull: true };\n    } else {\n      attribute = dataTypeOrOptions;\n    }\n\n    return this.sequelize.normalizeAttribute(attribute);\n  }\n\n  /**\n   * Change a column definition\n   *\n   * @param {string} tableName          Table name to change from\n   * @param {string} attributeName      Column name\n   * @param {object} dataTypeOrOptions  Attribute definition for new column\n   * @param {object} [options]          Query options\n   */\n  async changeColumn(tableName, attributeName, dataTypeOrOptions, options) {\n    options = options || {};\n\n    const query = this.queryGenerator.attributesToSQL({\n      [attributeName]: this.normalizeAttribute(dataTypeOrOptions)\n    }, {\n      context: 'changeColumn',\n      table: tableName\n    });\n    const sql = this.queryGenerator.changeColumnQuery(tableName, query);\n\n    return this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Rejects if the table doesn't have the specified column, otherwise returns the column description.\n   *\n   * @param {string} tableName\n   * @param {string} columnName\n   * @param {object} options\n   * @private\n   */\n  async assertTableHasColumn(tableName, columnName, options) {\n    const description = await this.describeTable(tableName, options);\n    if (description[columnName]) {\n      return description;\n    }\n    throw new Error(`Table ${tableName} doesn't have the column ${columnName}`);\n  }\n\n  /**\n   * Rename a column\n   *\n   * @param {string} tableName        Table name whose column to rename\n   * @param {string} attrNameBefore   Current column name\n   * @param {string} attrNameAfter    New column name\n   * @param {object} [options]        Query option\n   *\n   * @returns {Promise}\n   */\n  async renameColumn(tableName, attrNameBefore, attrNameAfter, options) {\n    options = options || {};\n    const data = (await this.assertTableHasColumn(tableName, attrNameBefore, options))[attrNameBefore];\n\n    const _options = {};\n\n    _options[attrNameAfter] = {\n      attribute: attrNameAfter,\n      type: data.type,\n      allowNull: data.allowNull,\n      defaultValue: data.defaultValue\n    };\n\n    // fix: a not-null column cannot have null as default value\n    if (data.defaultValue === null && !data.allowNull) {\n      delete _options[attrNameAfter].defaultValue;\n    }\n\n    const sql = this.queryGenerator.renameColumnQuery(\n      tableName,\n      attrNameBefore,\n      this.queryGenerator.attributesToSQL(_options)\n    );\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add an index to a column\n   *\n   * @param {string|object}  tableName Table name to add index on, can be a object with schema\n   * @param {Array}   [attributes]     Use options.fields instead, List of attributes to add index on\n   * @param {object}  options          indexes options\n   * @param {Array}   options.fields   List of attributes to add index on\n   * @param {boolean} [options.concurrently] Pass CONCURRENT so other operations run while the index is created\n   * @param {boolean} [options.unique] Create a unique index\n   * @param {string}  [options.using]  Useful for GIN indexes\n   * @param {string}  [options.operator] Index operator\n   * @param {string}  [options.type]   Type of index, available options are UNIQUE|FULLTEXT|SPATIAL\n   * @param {string}  [options.name]   Name of the index. Default is <table>_<attr1>_<attr2>\n   * @param {object}  [options.where]  Where condition on index, for partial indexes\n   * @param {string}  [rawTablename]   table name, this is just for backward compatibiity\n   *\n   * @returns {Promise}\n   */\n  async addIndex(tableName, attributes, options, rawTablename) {\n    // Support for passing tableName, attributes, options or tableName, options (with a fields param which is the attributes)\n    if (!Array.isArray(attributes)) {\n      rawTablename = options;\n      options = attributes;\n      attributes = options.fields;\n    }\n\n    if (!rawTablename) {\n      // Map for backwards compat\n      rawTablename = tableName;\n    }\n\n    options = Utils.cloneDeep(options);\n    options.fields = attributes;\n    const sql = this.queryGenerator.addIndexQuery(tableName, options, rawTablename);\n    return await this.sequelize.query(sql, { ...options, supportsSearchPath: false });\n  }\n\n  /**\n   * Show indexes on a table\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]   Query options\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async showIndex(tableName, options) {\n    const sql = this.queryGenerator.showIndexesQuery(tableName, options);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWINDEXES });\n  }\n\n\n  /**\n   * Returns all foreign key constraints of requested tables\n   *\n   * @param {string[]} tableNames table names\n   * @param {object} [options] Query options\n   *\n   * @returns {Promise}\n   */\n  async getForeignKeysForTables(tableNames, options) {\n    if (tableNames.length === 0) {\n      return {};\n    }\n\n    options = { ...options, type: QueryTypes.FOREIGNKEYS };\n\n    const results = await Promise.all(tableNames.map(tableName =>\n      this.sequelize.query(this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database), options)));\n\n    const result = {};\n\n    tableNames.forEach((tableName, i) => {\n      if (_.isObject(tableName)) {\n        tableName = `${tableName.schema}.${tableName.tableName}`;\n      }\n\n      result[tableName] = Array.isArray(results[i])\n        ? results[i].map(r => r.constraint_name)\n        : [results[i] && results[i].constraint_name];\n\n      result[tableName] = result[tableName].filter(_.identity);\n    });\n\n    return result;\n  }\n\n  /**\n   * Get foreign key references details for the table\n   *\n   * Those details contains constraintSchema, constraintName, constraintCatalog\n   * tableCatalog, tableSchema, tableName, columnName,\n   * referencedTableCatalog, referencedTableCatalog, referencedTableSchema, referencedTableName, referencedColumnName.\n   * Remind: constraint informations won't return if it's sqlite.\n   *\n   * @param {string} tableName table name\n   * @param {object} [options]  Query options\n   */\n  async getForeignKeyReferencesForTable(tableName, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n    const query = this.queryGenerator.getForeignKeysQuery(tableName, this.sequelize.config.database);\n    return this.sequelize.query(query, queryOptions);\n  }\n\n  /**\n   * Remove an already existing index from a table\n   *\n   * @param {string} tableName                    Table name to drop index from\n   * @param {string|string[]} indexNameOrAttributes  Index name or list of attributes that in the index\n   * @param {object} [options]                    Query options\n   *\n   * @returns {Promise}\n   */\n  async removeIndex(tableName, indexNameOrAttributes, options) {\n    options = options || {};\n    const sql = this.queryGenerator.removeIndexQuery(tableName, indexNameOrAttributes);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Add a constraint to a table\n   *\n   * Available constraints:\n   * - UNIQUE\n   * - DEFAULT (MSSQL only)\n   * - CHECK (MySQL - Ignored by the database engine )\n   * - FOREIGN KEY\n   * - PRIMARY KEY\n   *\n   * @example <caption>UNIQUE</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['email'],\n   *   type: 'unique',\n   *   name: 'custom_unique_constraint_name'\n   * });\n   *\n   * @example <caption>CHECK</caption>\n   * queryInterface.addConstraint('Users', {\n   *   fields: ['roles'],\n   *   type: 'check',\n   *   where: {\n   *      roles: ['user', 'admin', 'moderator', 'guest']\n   *   }\n   * });\n   *\n   * @example <caption>Default - MSSQL only</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['roles'],\n   *    type: 'default',\n   *    defaultValue: 'guest'\n   * });\n   *\n   * @example <caption>Primary Key</caption>\n   * queryInterface.addConstraint('Users', {\n   *    fields: ['username'],\n   *    type: 'primary key',\n   *    name: 'custom_primary_constraint_name'\n   * });\n   *\n   * @example <caption>Foreign Key</caption>\n   * queryInterface.addConstraint('Posts', {\n   *   fields: ['username'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     field: 'target_column_name'\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @example <caption>Composite Foreign Key</caption>\n   * queryInterface.addConstraint('TableName', {\n   *   fields: ['source_column_name', 'other_source_column_name'],\n   *   type: 'foreign key',\n   *   name: 'custom_fkey_constraint_name',\n   *   references: { //Required field\n   *     table: 'target_table_name',\n   *     fields: ['target_column_name', 'other_target_column_name']\n   *   },\n   *   onDelete: 'cascade',\n   *   onUpdate: 'cascade'\n   * });\n   *\n   * @param {string} tableName                   Table name where you want to add a constraint\n   * @param {object} options                     An object to define the constraint name, type etc\n   * @param {string} options.type                Type of constraint. One of the values in available constraints(case insensitive)\n   * @param {Array}  options.fields              Array of column names to apply the constraint over\n   * @param {string} [options.name]              Name of the constraint. If not specified, sequelize automatically creates a named constraint based on constraint type, table & column names\n   * @param {string} [options.defaultValue]      The value for the default constraint\n   * @param {object} [options.where]             Where clause/expression for the CHECK constraint\n   * @param {object} [options.references]        Object specifying target table, column name to create foreign key constraint\n   * @param {string} [options.references.table]  Target table name\n   * @param {string} [options.references.field]  Target column name\n   * @param {string} [options.references.fields] Target column names for a composite primary key. Must match the order of fields in options.fields.\n   * @param {string} [options.deferrable]        Sets the constraint to be deferred or immediately checked. See Sequelize.Deferrable. PostgreSQL Only\n   *\n   * @returns {Promise}\n   */\n  async addConstraint(tableName, options) {\n    if (!options.fields) {\n      throw new Error('Fields must be specified through options.fields');\n    }\n\n    if (!options.type) {\n      throw new Error('Constraint type must be specified through options.type');\n    }\n\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.addConstraintQuery(tableName, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  async showConstraint(tableName, constraintName, options) {\n    const sql = this.queryGenerator.showConstraintsQuery(tableName, constraintName);\n    return await this.sequelize.query(sql, { ...options, type: QueryTypes.SHOWCONSTRAINTS });\n  }\n\n  /**\n   * Remove a constraint from a table\n   *\n   * @param {string} tableName       Table name to drop constraint from\n   * @param {string} constraintName  Constraint name\n   * @param {object} options         Query options\n   */\n  async removeConstraint(tableName, constraintName, options) {\n    return this.sequelize.query(this.queryGenerator.removeConstraintQuery(tableName, constraintName), options);\n  }\n\n  async insert(instance, tableName, values, options) {\n    options = Utils.cloneDeep(options);\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n    const sql = this.queryGenerator.insertQuery(tableName, values, instance && instance.constructor.rawAttributes, options);\n\n    options.type = QueryTypes.INSERT;\n    options.instance = instance;\n\n    const results = await this.sequelize.query(sql, options);\n    if (instance) results[0].isNewRecord = false;\n\n    return results;\n  }\n\n  /**\n   * Upsert\n   *\n   * @param {string} tableName    table to upsert on\n   * @param {object} insertValues values to be inserted, mapped to field name\n   * @param {object} updateValues values to be updated, mapped to field name\n   * @param {object} where        where conditions, which can be used for UPDATE part when INSERT fails\n   * @param {object} options      query options\n   *\n   * @returns {Promise<boolean,?number>} Resolves an array with <created, primaryKey>\n   */\n  async upsert(tableName, insertValues, updateValues, where, options) {\n    options = { ...options };\n\n    const model = options.model;\n    const primaryKeys = Object.values(model.primaryKeys).map(item => item.field);\n    const uniqueKeys = Object.values(model.uniqueKeys).filter(c => c.fields.length > 0).map(c => c.fields);\n    const indexKeys = Object.values(model._indexes).filter(c => c.unique && c.fields.length > 0).map(c => c.fields);\n\n    options.type = QueryTypes.UPSERT;\n    options.updateOnDuplicate = Object.keys(updateValues);\n    options.upsertKeys = [];\n\n    // For fields in updateValues, try to find a constraint or unique index\n    // that includes given field. Only first matching upsert key is used.\n    for (const field of options.updateOnDuplicate) {\n      const uniqueKey = uniqueKeys.find(fields => fields.includes(field));\n      if (uniqueKey) {\n        options.upsertKeys = uniqueKey;\n        break;\n      }\n\n      const indexKey = indexKeys.find(fields => fields.includes(field));\n      if (indexKey) {\n        options.upsertKeys = indexKey;\n        break;\n      }\n    }\n\n    // Always use PK, if no constraint available OR update data contains PK\n    if (\n      options.upsertKeys.length === 0\n      || _.intersection(options.updateOnDuplicate, primaryKeys).length\n    ) {\n      options.upsertKeys = primaryKeys;\n    }\n\n    options.upsertKeys = _.uniq(options.upsertKeys);\n\n    const sql = this.queryGenerator.insertQuery(tableName, insertValues, model.rawAttributes, options);\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Insert multiple records into a table\n   *\n   * @example\n   * queryInterface.bulkInsert('roles', [{\n   *    label: 'user',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }, {\n   *    label: 'admin',\n   *    createdAt: new Date(),\n   *    updatedAt: new Date()\n   *  }]);\n   *\n   * @param {string} tableName   Table name to insert record to\n   * @param {Array}  records     List of records to insert\n   * @param {object} options     Various options, please see Model.bulkCreate options\n   * @param {object} attributes  Various attributes mapped by field name\n   *\n   * @returns {Promise}\n   */\n  async bulkInsert(tableName, records, options, attributes) {\n    options = { ...options };\n    options.type = QueryTypes.INSERT;\n\n    const results = await this.sequelize.query(\n      this.queryGenerator.bulkInsertQuery(tableName, records, options, attributes),\n      options\n    );\n\n    return results[0];\n  }\n\n  async update(instance, tableName, values, identifier, options) {\n    options = { ...options };\n    options.hasTrigger = instance && instance.constructor.options.hasTrigger;\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, instance.constructor.rawAttributes);\n\n    options.type = QueryTypes.UPDATE;\n\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Update multiple records of a table\n   *\n   * @example\n   * queryInterface.bulkUpdate('roles', {\n   *     label: 'admin',\n   *   }, {\n   *     userType: 3,\n   *   },\n   * );\n   *\n   * @param {string} tableName     Table name to update\n   * @param {object} values        Values to be inserted, mapped to field name\n   * @param {object} identifier    A hash with conditions OR an ID as integer OR a string with conditions\n   * @param {object} [options]     Various options, please see Model.bulkCreate options\n   * @param {object} [attributes]  Attributes on return objects if supported by SQL dialect\n   *\n   * @returns {Promise}\n   */\n  async bulkUpdate(tableName, values, identifier, options, attributes) {\n    options = Utils.cloneDeep(options);\n    if (typeof identifier === 'object') identifier = Utils.cloneDeep(identifier);\n\n    const sql = this.queryGenerator.updateQuery(tableName, values, identifier, options, attributes);\n    const table = _.isObject(tableName) ? tableName : { tableName };\n    const model = _.find(this.sequelize.modelManager.models, { tableName: table.tableName });\n\n    options.type = QueryTypes.BULKUPDATE;\n    options.model = model;\n    return await this.sequelize.query(sql, options);\n  }\n\n  async delete(instance, tableName, identifier, options) {\n    const cascades = [];\n    const sql = this.queryGenerator.deleteQuery(tableName, identifier, {}, instance.constructor);\n\n    options = { ...options };\n\n    // Check for a restrict field\n    if (!!instance.constructor && !!instance.constructor.associations) {\n      const keys = Object.keys(instance.constructor.associations);\n      const length = keys.length;\n      let association;\n\n      for (let i = 0; i < length; i++) {\n        association = instance.constructor.associations[keys[i]];\n        if (association.options && association.options.onDelete &&\n          association.options.onDelete.toLowerCase() === 'cascade' &&\n          association.options.useHooks === true) {\n          cascades.push(association.accessors.get);\n        }\n      }\n    }\n\n    for (const cascade of cascades) {\n      let instances = await instance[cascade](options);\n      // Check for hasOne relationship with non-existing associate (\"has zero\")\n      if (!instances) continue;\n      if (!Array.isArray(instances)) instances = [instances];\n      for (const _instance of instances) await _instance.destroy(options);\n    }\n    options.instance = instance;\n    return await this.sequelize.query(sql, options);\n  }\n\n  /**\n   * Delete multiple records from a table\n   *\n   * @param {string}  tableName            table name from where to delete records\n   * @param {object}  where                where conditions to find records to delete\n   * @param {object}  [options]            options\n   * @param {boolean} [options.truncate]   Use truncate table command\n   * @param {boolean} [options.cascade=false]         Only used in conjunction with TRUNCATE. Truncates  all tables that have foreign-key references to the named table, or to any tables added to the group due to CASCADE.\n   * @param {boolean} [options.restartIdentity=false] Only used in conjunction with TRUNCATE. Automatically restart sequences owned by columns of the truncated table.\n   * @param {Model}   [model]              Model\n   *\n   * @returns {Promise}\n   */\n  async bulkDelete(tableName, where, options, model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, { limit: null });\n\n    if (options.truncate === true) {\n      return this.sequelize.query(\n        this.queryGenerator.truncateTableQuery(tableName, options),\n        options\n      );\n    }\n\n    if (typeof identifier === 'object') where = Utils.cloneDeep(where);\n\n    return await this.sequelize.query(\n      this.queryGenerator.deleteQuery(tableName, where, options, model),\n      options\n    );\n  }\n\n  async select(model, tableName, optionsArg) {\n    const options = { ...optionsArg, type: QueryTypes.SELECT, model };\n\n    return await this.sequelize.query(\n      this.queryGenerator.selectQuery(tableName, options, model),\n      options\n    );\n  }\n\n  async increment(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('+', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async decrement(model, tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options) {\n    options = Utils.cloneDeep(options);\n\n    const sql = this.queryGenerator.arithmeticQuery('-', tableName, where, incrementAmountsByField, extraAttributesToBeUpdated, options);\n\n    options.type = QueryTypes.UPDATE;\n    options.model = model;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async rawSelect(tableName, options, attributeSelector, Model) {\n    options = Utils.cloneDeep(options);\n    options = _.defaults(options, {\n      raw: true,\n      plain: true,\n      type: QueryTypes.SELECT\n    });\n\n    const sql = this.queryGenerator.selectQuery(tableName, options, Model);\n\n    if (attributeSelector === undefined) {\n      throw new Error('Please pass an attribute selector!');\n    }\n\n    const data = await this.sequelize.query(sql, options);\n    if (!options.plain) {\n      return data;\n    }\n\n    const result = data ? data[attributeSelector] : null;\n\n    if (!options || !options.dataType) {\n      return result;\n    }\n\n    const dataType = options.dataType;\n\n    if (dataType instanceof DataTypes.DECIMAL || dataType instanceof DataTypes.FLOAT) {\n      if (result !== null) {\n        return parseFloat(result);\n      }\n    }\n    if (dataType instanceof DataTypes.INTEGER || dataType instanceof DataTypes.BIGINT) {\n      if (result !== null) {\n        return parseInt(result, 10);\n      }\n    }\n    if (dataType instanceof DataTypes.DATE) {\n      if (result !== null && !(result instanceof Date)) {\n        return new Date(result);\n      }\n    }\n    return result;\n  }\n\n  async createTrigger(\n    tableName,\n    triggerName,\n    timingType,\n    fireOnArray,\n    functionName,\n    functionParams,\n    optionsArray,\n    options\n  ) {\n    const sql = this.queryGenerator.createTrigger(tableName, triggerName, timingType, fireOnArray, functionName, functionParams, optionsArray);\n    options = options || {};\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async dropTrigger(tableName, triggerName, options) {\n    const sql = this.queryGenerator.dropTrigger(tableName, triggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async renameTrigger(tableName, oldTriggerName, newTriggerName, options) {\n    const sql = this.queryGenerator.renameTrigger(tableName, oldTriggerName, newTriggerName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Create an SQL function\n   *\n   * @example\n   * queryInterface.createFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'integer', name: 'param', direction: 'IN'}\n   *   ],\n   *   'integer',\n   *   'plpgsql',\n   *   'RETURN param + 1;',\n   *   [\n   *     'IMMUTABLE',\n   *     'LEAKPROOF'\n   *   ],\n   *   {\n   *    variables:\n   *      [\n   *        {type: 'integer', name: 'myVar', default: 100}\n   *      ],\n   *      force: true\n   *   };\n   * );\n   *\n   * @param {string}  functionName  Name of SQL function to create\n   * @param {Array}   params        List of parameters declared for SQL function\n   * @param {string}  returnType    SQL type of function returned value\n   * @param {string}  language      The name of the language that the function is implemented in\n   * @param {string}  body          Source code of function\n   * @param {Array}   optionsArray  Extra-options for creation\n   * @param {object}  [options]     query options\n   * @param {boolean} options.force If force is true, any existing functions with the same parameters will be replaced. For postgres, this means using `CREATE OR REPLACE FUNCTION` instead of `CREATE FUNCTION`. Default is false\n   * @param {Array<object>}   options.variables List of declared variables. Each variable should be an object with string fields `type` and `name`, and optionally having a `default` field as well.\n   *\n   * @returns {Promise}\n   */\n  async createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    const sql = this.queryGenerator.createFunction(functionName, params, returnType, language, body, optionsArray, options);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Drop an SQL function\n   *\n   * @example\n   * queryInterface.dropFunction(\n   *   'someFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ]\n   * );\n   *\n   * @param {string} functionName Name of SQL function to drop\n   * @param {Array}  params       List of parameters declared for SQL function\n   * @param {object} [options]    query options\n   *\n   * @returns {Promise}\n   */\n  async dropFunction(functionName, params, options) {\n    const sql = this.queryGenerator.dropFunction(functionName, params);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  /**\n   * Rename an SQL function\n   *\n   * @example\n   * queryInterface.renameFunction(\n   *   'fooFunction',\n   *   [\n   *     {type: 'varchar', name: 'param1', direction: 'IN'},\n   *     {type: 'integer', name: 'param2', direction: 'INOUT'}\n   *   ],\n   *   'barFunction'\n   * );\n   *\n   * @param {string} oldFunctionName  Current name of function\n   * @param {Array}  params           List of parameters declared for SQL function\n   * @param {string} newFunctionName  New name of function\n   * @param {object} [options]        query options\n   *\n   * @returns {Promise}\n   */\n  async renameFunction(oldFunctionName, params, newFunctionName, options) {\n    const sql = this.queryGenerator.renameFunction(oldFunctionName, params, newFunctionName);\n    options = options || {};\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  // Helper methods useful for querying\n\n  /**\n   * @private\n   */\n  ensureEnums() {\n    // noop by default\n  }\n\n  async setIsolationLevel(transaction, value, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to set isolation level for a transaction without transaction object!');\n    }\n\n    if (transaction.parent || !value) {\n      // Not possible to set a separate isolation level for savepoints\n      return;\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.setIsolationLevelQuery(value, {\n      parent: transaction.parent\n    });\n\n    if (!sql) return;\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async startTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to start a transaction without transaction object!');\n    }\n\n    options = { ...options, transaction: transaction.parent || transaction };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.startTransactionQuery(transaction);\n\n    return await this.sequelize.query(sql, options);\n  }\n\n  async deferConstraints(transaction, options) {\n    options = { ...options, transaction: transaction.parent || transaction };\n\n    const sql = this.queryGenerator.deferConstraintsQuery(options);\n\n    if (sql) {\n      return await this.sequelize.query(sql, options);\n    }\n  }\n\n  async commitTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to commit a transaction without transaction object!');\n    }\n    if (transaction.parent) {\n      // Savepoints cannot be committed\n      return;\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n\n    const sql = this.queryGenerator.commitTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'commit';\n\n    return await promise;\n  }\n\n  async rollbackTransaction(transaction, options) {\n    if (!transaction || !(transaction instanceof Transaction)) {\n      throw new Error('Unable to rollback a transaction without transaction object!');\n    }\n\n    options = {\n      ...options,\n      transaction: transaction.parent || transaction,\n      supportsSearchPath: false,\n      completesTransaction: true\n    };\n    options.transaction.name = transaction.parent ? transaction.name : undefined;\n    const sql = this.queryGenerator.rollbackTransactionQuery(transaction);\n    const promise = this.sequelize.query(sql, options);\n\n    transaction.finished = 'rollback';\n\n    return await promise;\n  }\n}\n\nexports.QueryInterface = QueryInterface;\n"],
  "mappings": "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",
  "names": []
}
