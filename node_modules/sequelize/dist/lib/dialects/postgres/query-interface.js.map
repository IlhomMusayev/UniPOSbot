{
  "version": 3,
  "sources": ["../../../../lib/dialects/postgres/query-interface.js"],
  "sourcesContent": ["'use strict';\n\nconst DataTypes = require('../../data-types');\nconst QueryTypes = require('../../query-types');\nconst { QueryInterface } = require('../abstract/query-interface');\nconst Utils = require('../../utils');\n\n/**\n * The interface that Sequelize uses to talk with Postgres database\n */\nclass PostgresQueryInterface extends QueryInterface {\n  /**\n   * Ensure enum and their values.\n   *\n   * @param {string} tableName  Name of table to create\n   * @param {object} attributes Object representing a list of normalized table attributes\n   * @param {object} [options]\n   * @param {Model}  [model]\n   *\n   * @protected\n   */\n  async ensureEnums(tableName, attributes, options, model) {\n    const keys = Object.keys(attributes);\n    const keyLen = keys.length;\n\n    let sql = '';\n    let promises = [];\n    let i = 0;\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && type.type instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        sql = this.queryGenerator.pgListEnums(tableName, attribute.field || keys[i], options);\n        promises.push(this.sequelize.query(\n          sql,\n          { ...options, plain: true, raw: true, type: QueryTypes.SELECT }\n        ));\n      }\n    }\n\n    const results = await Promise.all(promises);\n    promises = [];\n    let enumIdx = 0;\n\n    // This little function allows us to re-use the same code that prepends or appends new value to enum array\n    const addEnumValue = (field, value, relativeValue, position = 'before', spliceStart = promises.length) => {\n      const valueOptions = { ...options };\n      valueOptions.before = null;\n      valueOptions.after = null;\n\n      switch (position) {\n        case 'after':\n          valueOptions.after = relativeValue;\n          break;\n        case 'before':\n        default:\n          valueOptions.before = relativeValue;\n          break;\n      }\n\n      promises.splice(spliceStart, 0, () => {\n        return this.sequelize.query(this.queryGenerator.pgEnumAdd(\n          tableName, field, value, valueOptions\n        ), valueOptions);\n      });\n    };\n\n    for (i = 0; i < keyLen; i++) {\n      const attribute = attributes[keys[i]];\n      const type = attribute.type;\n      const enumType = type.type || type;\n      const field = attribute.field || keys[i];\n\n      if (\n        type instanceof DataTypes.ENUM ||\n        type instanceof DataTypes.ARRAY && enumType instanceof DataTypes.ENUM //ARRAY sub type is ENUM\n      ) {\n        // If the enum type doesn't exist then create it\n        if (!results[enumIdx]) {\n          promises.push(() => {\n            return this.sequelize.query(this.queryGenerator.pgEnum(tableName, field, enumType, options), { ...options, raw: true });\n          });\n        } else if (!!results[enumIdx] && !!model) {\n          const enumVals = this.queryGenerator.fromArray(results[enumIdx].enum_value);\n          const vals = enumType.values;\n\n          // Going through already existing values allows us to make queries that depend on those values\n          // We will prepend all new values between the old ones, but keep in mind - we can't change order of already existing values\n          // Then we append the rest of new values AFTER the latest already existing value\n          // E.g.: [1,2] -> [0,2,1] ==> [1,0,2]\n          // E.g.: [1,2,3] -> [2,1,3,4] ==> [1,2,3,4]\n          // E.g.: [1] -> [0,2,3] ==> [1,0,2,3]\n          let lastOldEnumValue;\n          let rightestPosition = -1;\n          for (let oldIndex = 0; oldIndex < enumVals.length; oldIndex++) {\n            const enumVal = enumVals[oldIndex];\n            const newIdx = vals.indexOf(enumVal);\n            lastOldEnumValue = enumVal;\n\n            if (newIdx === -1) {\n              continue;\n            }\n\n            const newValuesBefore = vals.slice(0, newIdx);\n            const promisesLength = promises.length;\n            // we go in reverse order so we could stop when we meet old value\n            for (let reverseIdx = newValuesBefore.length - 1; reverseIdx >= 0; reverseIdx--) {\n              if (~enumVals.indexOf(newValuesBefore[reverseIdx])) {\n                break;\n              }\n\n              addEnumValue(field, newValuesBefore[reverseIdx], lastOldEnumValue, 'before', promisesLength);\n            }\n\n            // we detect the most 'right' position of old value in new enum array so we can append new values to it\n            if (newIdx > rightestPosition) {\n              rightestPosition = newIdx;\n            }\n          }\n\n          if (lastOldEnumValue && rightestPosition < vals.length - 1) {\n            const remainingEnumValues = vals.slice(rightestPosition + 1);\n            for (let reverseIdx = remainingEnumValues.length - 1; reverseIdx >= 0; reverseIdx--) {\n              addEnumValue(field, remainingEnumValues[reverseIdx], lastOldEnumValue, 'after');\n            }\n          }\n\n          enumIdx++;\n        }\n      }\n    }\n\n    const result = await promises\n      .reduce(async (promise, asyncFunction) => await asyncFunction(await promise), Promise.resolve());\n\n    // If ENUM processed, then refresh OIDs\n    if (promises.length) {\n      await this.sequelize.dialect.connectionManager._refreshDynamicOIDs();\n    }\n    return result;\n  }\n\n  /**\n   * @override\n   */\n  async getForeignKeyReferencesForTable(table, options) {\n    const queryOptions = {\n      ...options,\n      type: QueryTypes.FOREIGNKEYS\n    };\n\n    // postgres needs some special treatment as those field names returned are all lowercase\n    // in order to keep same result with other dialects.\n    const query = this.queryGenerator.getForeignKeyReferencesQuery(table.tableName || table, this.sequelize.config.database);\n    const result = await this.sequelize.query(query, queryOptions);\n    return result.map(Utils.camelizeObjectKeys);\n  }\n\n  /**\n   * Drop specified enum from database (Postgres only)\n   *\n   * @param {string} [enumName]  Enum name to drop\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n  async dropEnum(enumName, options) {\n    options = options || {};\n\n    return this.sequelize.query(\n      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(enumName)),\n      { ...options, raw: true }\n    );\n  }\n\n  /**\n   * Drop all enums from database (Postgres only)\n   *\n   * @param {object} options Query options\n   *\n   * @returns {Promise}\n   */\n  async dropAllEnums(options) {\n    options = options || {};\n\n    const enums = await this.pgListEnums(null, options);\n\n    return await Promise.all(enums.map(result => this.sequelize.query(\n      this.queryGenerator.pgEnumDrop(null, null, this.queryGenerator.pgEscapeAndQuote(result.enum_name)),\n      { ...options, raw: true }\n    )));\n  }\n\n  /**\n   * List all enums (Postgres only)\n   *\n   * @param {string} [tableName]  Table whose enum to list\n   * @param {object} [options]    Query options\n   *\n   * @returns {Promise}\n   */\n  async pgListEnums(tableName, options) {\n    options = options || {};\n    const sql = this.queryGenerator.pgListEnums(tableName);\n    return this.sequelize.query(sql, { ...options, plain: false, raw: true, type: QueryTypes.SELECT });\n  }\n\n  /**\n   * Since postgres has a special case for enums, we should drop the related\n   * enum type within the table and attribute\n   *\n   * @override\n   */\n  async dropTable(tableName, options) {\n    await super.dropTable(tableName, options);\n    const promises = [];\n    const instanceTable = this.sequelize.modelManager.getModel(tableName, { attribute: 'tableName' });\n\n    if (!instanceTable) {\n      // Do nothing when model is not available\n      return;\n    }\n\n    const getTableName = (!options || !options.schema || options.schema === 'public' ? '' : `${options.schema}_`) + tableName;\n\n    const keys = Object.keys(instanceTable.rawAttributes);\n    const keyLen = keys.length;\n\n    for (let i = 0; i < keyLen; i++) {\n      if (instanceTable.rawAttributes[keys[i]].type instanceof DataTypes.ENUM) {\n        const sql = this.queryGenerator.pgEnumDrop(getTableName, keys[i]);\n        options.supportsSearchPath = false;\n        promises.push(this.sequelize.query(sql, { ...options, raw: true }));\n      }\n    }\n\n    await Promise.all(promises);\n  }\n}\n\nexports.PostgresQueryInterface = PostgresQueryInterface;\n"],
  "mappings": "6eAEA,KAAM,GAAY,QAAQ,oBACpB,EAAa,QAAQ,qBACrB,CAAE,kBAAmB,QAAQ,+BAC7B,EAAQ,QAAQ,eAKtB,eAAqC,EAAe,MAW5C,aAAY,EAAW,EAAY,EAAS,EAAO,CACvD,KAAM,GAAO,OAAO,KAAK,GACnB,EAAS,EAAK,OAEpB,GAAI,GAAM,GACN,EAAW,GACX,EAAI,EAER,IAAK,EAAI,EAAG,EAAI,EAAQ,IAAK,CAC3B,KAAM,GAAY,EAAW,EAAK,IAC5B,EAAO,EAAU,KAEvB,AACE,aAAgB,GAAU,MAC1B,YAAgB,GAAU,OAAS,EAAK,eAAgB,GAAU,OAElE,GAAM,KAAK,eAAe,YAAY,EAAW,EAAU,OAAS,EAAK,GAAI,GAC7E,EAAS,KAAK,KAAK,UAAU,MAC3B,EACA,OAAK,GAAL,CAAc,MAAO,GAAM,IAAK,GAAM,KAAM,EAAW,YAK7D,KAAM,GAAU,KAAM,SAAQ,IAAI,GAClC,EAAW,GACX,GAAI,GAAU,EAGd,KAAM,GAAe,GAAC,EAAO,EAAO,EAAe,EAAW,SAAU,EAAc,EAAS,SAAW,CACxG,KAAM,GAAe,KAAK,GAI1B,OAHA,EAAa,OAAS,KACtB,EAAa,MAAQ,KAEb,OACD,QACH,EAAa,MAAQ,EACrB,UACG,iBAEH,EAAa,OAAS,EACtB,MAGJ,EAAS,OAAO,EAAa,EAAG,IACvB,KAAK,UAAU,MAAM,KAAK,eAAe,UAC9C,EAAW,EAAO,EAAO,GACxB,KAlBc,gBAsBrB,IAAK,EAAI,EAAG,EAAI,EAAQ,IAAK,CAC3B,KAAM,GAAY,EAAW,EAAK,IAC5B,EAAO,EAAU,KACjB,EAAW,EAAK,MAAQ,EACxB,EAAQ,EAAU,OAAS,EAAK,GAEtC,GACE,YAAgB,GAAU,MAC1B,YAAgB,GAAU,OAAS,YAAoB,GAAU,MAGjE,GAAI,CAAC,EAAQ,GACX,EAAS,KAAK,IACL,KAAK,UAAU,MAAM,KAAK,eAAe,OAAO,EAAW,EAAO,EAAU,GAAU,OAAK,GAAL,CAAc,IAAK,eAEzG,CAAC,CAAC,EAAQ,IAAY,CAAC,CAAC,EAAO,CACxC,KAAM,GAAW,KAAK,eAAe,UAAU,EAAQ,GAAS,YAC1D,EAAO,EAAS,OAQtB,GAAI,GACA,EAAmB,GACvB,OAAS,GAAW,EAAG,EAAW,EAAS,OAAQ,IAAY,CAC7D,KAAM,GAAU,EAAS,GACnB,EAAS,EAAK,QAAQ,GAG5B,GAFA,EAAmB,EAEf,IAAW,GACb,SAGF,KAAM,GAAkB,EAAK,MAAM,EAAG,GAChC,EAAiB,EAAS,OAEhC,OAAS,GAAa,EAAgB,OAAS,EAAG,GAAc,GAC1D,EAAC,EAAS,QAAQ,EAAgB,IAD2B,IAKjE,EAAa,EAAO,EAAgB,GAAa,EAAkB,SAAU,GAI/E,AAAI,EAAS,GACX,GAAmB,GAIvB,GAAI,GAAoB,EAAmB,EAAK,OAAS,EAAG,CAC1D,KAAM,GAAsB,EAAK,MAAM,EAAmB,GAC1D,OAAS,GAAa,EAAoB,OAAS,EAAG,GAAc,EAAG,IACrE,EAAa,EAAO,EAAoB,GAAa,EAAkB,SAI3E,MAKN,KAAM,GAAS,KAAM,GAClB,OAAO,MAAO,EAAS,IAAkB,KAAM,GAAc,KAAM,IAAU,QAAQ,WAGxF,MAAI,GAAS,QACX,KAAM,MAAK,UAAU,QAAQ,kBAAkB,sBAE1C,OAMH,iCAAgC,EAAO,EAAS,CACpD,KAAM,GAAe,OAChB,GADgB,CAEnB,KAAM,EAAW,cAKb,EAAQ,KAAK,eAAe,6BAA6B,EAAM,WAAa,EAAO,KAAK,UAAU,OAAO,UAE/G,MAAO,AADQ,MAAM,MAAK,UAAU,MAAM,EAAO,IACnC,IAAI,EAAM,yBAWpB,UAAS,EAAU,EAAS,CAChC,SAAU,GAAW,GAEd,KAAK,UAAU,MACpB,KAAK,eAAe,WAAW,KAAM,KAAM,KAAK,eAAe,iBAAiB,IAChF,OAAK,GAAL,CAAc,IAAK,WAWjB,cAAa,EAAS,CAC1B,EAAU,GAAW,GAErB,KAAM,GAAQ,KAAM,MAAK,YAAY,KAAM,GAE3C,MAAO,MAAM,SAAQ,IAAI,EAAM,IAAI,GAAU,KAAK,UAAU,MAC1D,KAAK,eAAe,WAAW,KAAM,KAAM,KAAK,eAAe,iBAAiB,EAAO,YACvF,OAAK,GAAL,CAAc,IAAK,aAYjB,aAAY,EAAW,EAAS,CACpC,EAAU,GAAW,GACrB,KAAM,GAAM,KAAK,eAAe,YAAY,GAC5C,MAAO,MAAK,UAAU,MAAM,EAAK,OAAK,GAAL,CAAc,MAAO,GAAO,IAAK,GAAM,KAAM,EAAW,eASrF,WAAU,EAAW,EAAS,CAClC,KAAM,OAAM,UAAU,EAAW,GACjC,KAAM,GAAW,GACX,EAAgB,KAAK,UAAU,aAAa,SAAS,EAAW,CAAE,UAAW,cAEnF,GAAI,CAAC,EAEH,OAGF,KAAM,GAAgB,EAAC,GAAW,CAAC,EAAQ,QAAU,EAAQ,SAAW,SAAW,GAAK,GAAG,EAAQ,WAAa,EAE1G,EAAO,OAAO,KAAK,EAAc,eACjC,EAAS,EAAK,OAEpB,OAAS,GAAI,EAAG,EAAI,EAAQ,IAC1B,GAAI,EAAc,cAAc,EAAK,IAAI,eAAgB,GAAU,KAAM,CACvE,KAAM,GAAM,KAAK,eAAe,WAAW,EAAc,EAAK,IAC9D,EAAQ,mBAAqB,GAC7B,EAAS,KAAK,KAAK,UAAU,MAAM,EAAK,OAAK,GAAL,CAAc,IAAK,OAI/D,KAAM,SAAQ,IAAI,IAvOtB,8BA2OA,QAAQ,uBAAyB",
  "names": []
}
