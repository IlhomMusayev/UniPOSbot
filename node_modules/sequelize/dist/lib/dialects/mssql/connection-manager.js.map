{
  "version": 3,
  "sources": ["../../../../lib/dialects/mssql/connection-manager.js"],
  "sourcesContent": ["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst AsyncQueue = require('./async-queue').default;\nconst { logger } = require('../../utils/logger');\nconst sequelizeErrors = require('../../errors');\nconst DataTypes = require('../../data-types').mssql;\nconst parserStore = require('../parserStore')('mssql');\nconst debug = logger.debugContext('connection:mssql');\nconst debugTedious = logger.debugContext('connection:mssql:tedious');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 1433;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('tedious');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async connect(config) {\n    const connectionConfig = {\n      server: config.host,\n      authentication: {\n        type: 'default',\n        options: {\n          userName: config.username || undefined,\n          password: config.password || undefined\n        }\n      },\n      options: {\n        port: parseInt(config.port, 10),\n        database: config.database,\n        trustServerCertificate: true\n      }\n    };\n\n    if (config.dialectOptions) {\n      // only set port if no instance name was provided\n      if (\n        config.dialectOptions.options &&\n        config.dialectOptions.options.instanceName\n      ) {\n        delete connectionConfig.options.port;\n      }\n\n      if (config.dialectOptions.authentication) {\n        Object.assign(connectionConfig.authentication, config.dialectOptions.authentication);\n      }\n\n      Object.assign(connectionConfig.options, config.dialectOptions.options);\n    }\n\n    try {\n      return await new Promise((resolve, reject) => {\n        const connection = new this.lib.Connection(connectionConfig);\n        if (connection.state === connection.STATE.INITIALIZED) {\n          connection.connect();\n        }\n        connection.queue = new AsyncQueue();\n        connection.lib = this.lib;\n\n        const connectHandler = error => {\n          connection.removeListener('end', endHandler);\n          connection.removeListener('error', errorHandler);\n\n          if (error) return reject(error);\n\n          debug('connection acquired');\n          resolve(connection);\n        };\n\n        const endHandler = () => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('error', errorHandler);\n          reject(new Error('Connection was closed by remote server'));\n        };\n\n        const errorHandler = error => {\n          connection.removeListener('connect', connectHandler);\n          connection.removeListener('end', endHandler);\n          reject(error);\n        };\n\n        connection.once('error', errorHandler);\n        connection.once('end', endHandler);\n        connection.once('connect', connectHandler);\n\n        /*\n         * Permanently attach this event before connection is even acquired\n         * tedious sometime emits error even after connect(with error).\n         *\n         * If we dont attach this even that unexpected error event will crash node process\n         *\n         * E.g. connectTimeout is set higher than requestTimeout\n         */\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n              this.pool.destroy(connection);\n          }\n        });\n\n        if (config.dialectOptions && config.dialectOptions.debug) {\n          connection.on('debug', debugTedious.log.bind(debugTedious));\n        }\n      });\n    } catch (error) {\n      if (!error.code) {\n        throw new sequelizeErrors.ConnectionError(error);\n      }\n\n      switch (error.code) {\n        case 'ESOCKET':\n          if (error.message.includes('connect EHOSTUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect ENETUNREACH')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('connect EADDRNOTAVAIL')) {\n            throw new sequelizeErrors.HostNotReachableError(error);\n          }\n          if (error.message.includes('getaddrinfo ENOTFOUND')) {\n            throw new sequelizeErrors.HostNotFoundError(error);\n          }\n          if (error.message.includes('connect ECONNREFUSED')) {\n            throw new sequelizeErrors.ConnectionRefusedError(error);\n          }\n          throw new sequelizeErrors.ConnectionError(error);\n        case 'ER_ACCESS_DENIED_ERROR':\n        case 'ELOGIN':\n          throw new sequelizeErrors.AccessDeniedError(error);\n        case 'EINVAL':\n          throw new sequelizeErrors.InvalidConnectionError(error);\n        default:\n          throw new sequelizeErrors.ConnectionError(error);\n      }\n    }\n  }\n\n  async disconnect(connection) {\n    // Don't disconnect a connection that is already disconnected\n    if (connection.closed) {\n      return;\n    }\n\n    connection.queue.close();\n\n    return new Promise(resolve => {\n      connection.on('end', resolve);\n      connection.close();\n      debug('connection closed');\n    });\n  }\n\n  validate(connection) {\n    return connection && connection.loggedIn;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],
  "mappings": "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",
  "names": []
}
