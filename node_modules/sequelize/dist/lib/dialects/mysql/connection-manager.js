"use strict";var d=Object.defineProperty;var h=Object.getOwnPropertySymbols;var N=Object.prototype.hasOwnProperty,q=Object.prototype.propertyIsEnumerable;var m=(o,e,r)=>e in o?d(o,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):o[e]=r,y=(o,e)=>{for(var r in e||(e={}))N.call(e,r)&&m(o,r,e[r]);if(h)for(var r of h(e))q.call(e,r)&&m(o,r,e[r]);return o};var i=(o,e)=>d(o,"name",{value:e,configurable:!0});const g=require("../abstract/connection-manager"),a=require("../../errors"),{logger:_}=require("../../utils/logger"),b=require("../../data-types").mysql,f=require("moment-timezone"),w=_.debugContext("connection:mysql"),u=require("../parserStore")("mysql"),{promisify:C}=require("util");class c extends g{constructor(e,r){r.config.port=r.config.port||3306;super(e,r);this.lib=this._loadDialectModule("mysql2"),this.refreshTypeParser(b)}_refreshTypeParser(e){u.refresh(e)}_clearTypeParser(){u.clear()}static _typecast(e,r){return u.get(e.type)?u.get(e.type)(e,this.sequelize.options,r):r()}async connect(e){const r=y({host:e.host,port:e.port,user:e.username,flags:"-FOUND_ROWS",password:e.password,database:e.database,timezone:this.sequelize.options.timezone,typeCast:c._typecast.bind(this),bigNumberStrings:!1,supportBigNumbers:!0},e.dialectOptions);try{const t=await new Promise((s,l)=>{const n=this.lib.createConnection(r),E=i(O=>{n.removeListener("connect",p),n.removeListener("error",p),l(O)},"errorHandler"),p=i(()=>{n.removeListener("error",E),s(n)},"connectHandler");n.on("error",E),n.once("connect",p)});if(w("connection acquired"),t.on("error",s=>{switch(s.code){case"ESOCKET":case"ECONNRESET":case"EPIPE":case"PROTOCOL_CONNECTION_LOST":this.pool.destroy(t)}}),!this.sequelize.config.keepDefaultTimezone){let s=this.sequelize.options.timezone;s=/\//.test(s)?f.tz(s).format("Z"):s,await C(l=>t.query(`SET time_zone = '${s}'`,l))()}return t}catch(t){switch(t.code){case"ECONNREFUSED":throw new a.ConnectionRefusedError(t);case"ER_ACCESS_DENIED_ERROR":throw new a.AccessDeniedError(t);case"ENOTFOUND":throw new a.HostNotFoundError(t);case"EHOSTUNREACH":throw new a.HostNotReachableError(t);case"EINVAL":throw new a.InvalidConnectionError(t);default:throw new a.ConnectionError(t)}}}async disconnect(e){if(e._closing){w("connection tried to disconnect but was already at CLOSED state");return}return await C(r=>e.end(r))()}validate(e){return e&&!e._fatalError&&!e._protocolError&&!e._closing&&!e.stream.destroyed}}i(c,"ConnectionManager"),module.exports=c,module.exports.ConnectionManager=c,module.exports.default=c;
//# sourceMappingURL=connection-manager.js.map
