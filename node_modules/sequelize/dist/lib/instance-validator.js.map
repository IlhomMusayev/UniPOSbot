{
  "version": 3,
  "sources": ["../../lib/instance-validator.js"],
  "sourcesContent": ["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('./utils');\nconst sequelizeError = require('./errors');\nconst DataTypes = require('./data-types');\nconst BelongsTo = require('./associations/belongs-to');\nconst validator = require('./utils/validator-extras').validator;\nconst { promisify } = require('util');\n\n/**\n * Instance Validator.\n *\n * @param {Instance} modelInstance The model instance.\n * @param {object} options A dictionary with options.\n *\n * @private\n */\nclass InstanceValidator {\n  constructor(modelInstance, options) {\n    options = {\n      // assign defined and default options\n      hooks: true,\n      ...options\n    };\n\n    if (options.fields && !options.skip) {\n      options.skip = _.difference(Object.keys(modelInstance.constructor.rawAttributes), options.fields);\n    } else {\n      options.skip = options.skip || [];\n    }\n\n    this.options = options;\n\n    this.modelInstance = modelInstance;\n\n    /**\n     * Exposes a reference to validator.js. This allows you to add custom validations using `validator.extend`\n     *\n     * @name validator\n     * @private\n     */\n    this.validator = validator;\n\n    /**\n     *  All errors will be stored here from the validations.\n     *\n     * @type {Array} Will contain keys that correspond to attributes which will\n     *   be Arrays of Errors.\n     * @private\n     */\n    this.errors = [];\n\n    /**\n     * @type {boolean} Indicates if validations are in progress\n     * @private\n     */\n    this.inProgress = false;\n  }\n\n  /**\n   * The main entry point for the Validation module, invoke to start the dance.\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validate() {\n    if (this.inProgress) throw new Error('Validations already in progress.');\n\n    this.inProgress = true;\n\n    await Promise.all([\n      this._perAttributeValidators(),\n      this._customValidators()\n    ]);\n\n    if (this.errors.length) {\n      throw new sequelizeError.ValidationError(null, this.errors);\n    }\n  }\n\n  /**\n   * Invoke the Validation sequence and run validation hooks if defined\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async validate() {\n    return await (this.options.hooks ? this._validateAndRunHooks() : this._validate());\n  }\n\n  /**\n   * Invoke the Validation sequence and run hooks\n   *   - Before Validation Model Hooks\n   *   - Validation\n   *   - On validation success: After Validation Model Hooks\n   *   - On validation failure: Validation Failed Model Hooks\n   *\n   * @returns {Promise}\n   * @private\n   */\n  async _validateAndRunHooks() {\n    const runHooks = this.modelInstance.constructor.runHooks.bind(this.modelInstance.constructor);\n    await runHooks('beforeValidate', this.modelInstance, this.options);\n\n    try {\n      await this._validate();\n    } catch (error) {\n      const newError = await runHooks('validationFailed', this.modelInstance, this.options, error);\n      throw newError || error;\n    }\n\n    await runHooks('afterValidate', this.modelInstance, this.options);\n    return this.modelInstance;\n  }\n\n  /**\n   * Will run all the validators defined per attribute (built-in validators and custom validators)\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _perAttributeValidators() {\n    // promisify all attribute invocations\n    const validators = [];\n\n    _.forIn(this.modelInstance.rawAttributes, (rawAttribute, field) => {\n      if (this.options.skip.includes(field)) {\n        return;\n      }\n\n      const value = this.modelInstance.dataValues[field];\n\n      if (value instanceof Utils.SequelizeMethod) {\n        return;\n      }\n\n      if (!rawAttribute._autoGenerated && !rawAttribute.autoIncrement) {\n        // perform validations based on schema\n        this._validateSchema(rawAttribute, field, value);\n      }\n\n      if (Object.prototype.hasOwnProperty.call(this.modelInstance.validators, field)) {\n        validators.push(this._singleAttrValidate(value, field, rawAttribute.allowNull));\n      }\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Will run all the custom validators defined in the model's options.\n   *\n   * @returns {Promise<Array>}\n   * @private\n   */\n  async _customValidators() {\n    const validators = [];\n    _.each(this.modelInstance.constructor.options.validate, (validator, validatorType) => {\n      if (this.options.skip.includes(validatorType)) {\n        return;\n      }\n\n      const valprom = this._invokeCustomValidator(validator, validatorType)\n        // errors are handled in settling, stub this\n        .catch(() => {});\n\n      validators.push(valprom);\n    });\n\n    return await Promise.all(validators);\n  }\n\n  /**\n   * Validate a single attribute with all the defined built-in validators and custom validators.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {string} field The field name.\n   * @param {boolean} allowNull Whether or not the schema allows null values\n   *\n   * @returns {Promise} A promise, will always resolve, auto populates error on this.error local object.\n   */\n  async _singleAttrValidate(value, field, allowNull) {\n    // If value is null and allowNull is false, no validators should run (see #9143)\n    if ((value === null || value === undefined) && !allowNull) {\n      // The schema validator (_validateSchema) has already generated the validation error. Nothing to do here.\n      return;\n    }\n\n    // Promisify each validator\n    const validators = [];\n    _.forIn(this.modelInstance.validators[field], (test, validatorType) => {\n\n      if (validatorType === 'isUrl' || validatorType === 'isURL' || validatorType === 'isEmail') {\n        // Preserve backwards compat. Validator.js now expects the second param to isURL and isEmail to be an object\n        if (typeof test === 'object' && test !== null && test.msg) {\n          test = {\n            msg: test.msg\n          };\n        } else if (test === true) {\n          test = {};\n        }\n      }\n\n      // Custom validators should always run, except if value is null and allowNull is false (see #9143)\n      if (typeof test === 'function') {\n        validators.push(this._invokeCustomValidator(test, validatorType, true, value, field));\n        return;\n      }\n\n      // If value is null, built-in validators should not run (only custom validators have to run) (see #9134).\n      if (value === null || value === undefined) {\n        return;\n      }\n\n      const validatorPromise = this._invokeBuiltinValidator(value, test, validatorType, field);\n      // errors are handled in settling, stub this\n      validatorPromise.catch(() => {});\n      validators.push(validatorPromise);\n    });\n\n    return Promise\n      .all(validators.map(validator => validator.catch(rejection => {\n        const isBuiltIn = !!rejection.validatorName;\n        this._pushError(isBuiltIn, field, rejection, value, rejection.validatorName, rejection.validatorArgs);\n      })));\n  }\n\n  /**\n   * Prepare and invoke a custom validator.\n   *\n   * @private\n   *\n   * @param {Function} validator The custom validator.\n   * @param {string} validatorType the custom validator type (name).\n   * @param {boolean} optAttrDefined Set to true if custom validator was defined from the attribute\n   * @param {*} optValue value for attribute\n   * @param {string} optField field for attribute\n   *\n   * @returns {Promise} A promise.\n   */\n  async _invokeCustomValidator(validator, validatorType, optAttrDefined, optValue, optField) {\n    let isAsync = false;\n\n    const validatorArity = validator.length;\n    // check if validator is async and requires a callback\n    let asyncArity = 1;\n    let errorKey = validatorType;\n    let invokeArgs;\n    if (optAttrDefined) {\n      asyncArity = 2;\n      invokeArgs = optValue;\n      errorKey = optField;\n    }\n    if (validatorArity === asyncArity) {\n      isAsync = true;\n    }\n\n    if (isAsync) {\n      try {\n        if (optAttrDefined) {\n          return await promisify(validator.bind(this.modelInstance, invokeArgs))();\n        }\n        return await promisify(validator.bind(this.modelInstance))();\n      } catch (e) {\n        return this._pushError(false, errorKey, e, optValue, validatorType);\n      }\n    }\n\n    try {\n      return await validator.call(this.modelInstance, invokeArgs);\n    } catch (e) {\n      return this._pushError(false, errorKey, e, optValue, validatorType);\n    }\n  }\n\n  /**\n   * Prepare and invoke a build-in validator.\n   *\n   * @private\n   *\n   * @param {*} value Anything.\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated\n   *\n   * @returns {object} An object with specific keys to invoke the validator.\n   */\n  async _invokeBuiltinValidator(value, test, validatorType, field) {\n    // Cast value as string to pass new Validator.js string requirement\n    const valueString = String(value);\n    // check if Validator knows that kind of validation test\n    if (typeof validator[validatorType] !== 'function') {\n      throw new Error(`Invalid validator function: ${validatorType}`);\n    }\n\n    const validatorArgs = this._extractValidatorArgs(test, validatorType, field);\n\n    if (!validator[validatorType](valueString, ...validatorArgs)) {\n      throw Object.assign(new Error(test.msg || `Validation ${validatorType} on ${field} failed`), { validatorName: validatorType, validatorArgs });\n    }\n  }\n\n  /**\n   * Will extract arguments for the validator.\n   *\n   * @param {*} test The test case.\n   * @param {string} validatorType One of known to Sequelize validators.\n   * @param {string} field The field that is being validated.\n   *\n   * @private\n   */\n  _extractValidatorArgs(test, validatorType, field) {\n    let validatorArgs = test.args || test;\n    const isLocalizedValidator = typeof validatorArgs !== 'string' && (validatorType === 'isAlpha' || validatorType === 'isAlphanumeric' || validatorType === 'isMobilePhone');\n\n    if (!Array.isArray(validatorArgs)) {\n      if (validatorType === 'isImmutable') {\n        validatorArgs = [validatorArgs, field, this.modelInstance];\n      } else if (isLocalizedValidator || validatorType === 'isIP') {\n        validatorArgs = [];\n      } else {\n        validatorArgs = [validatorArgs];\n      }\n    } else {\n      validatorArgs = validatorArgs.slice(0);\n    }\n    return validatorArgs;\n  }\n\n  /**\n   * Will validate a single field against its schema definition (isnull).\n   *\n   * @param {object} rawAttribute As defined in the Schema.\n   * @param {string} field The field name.\n   * @param {*} value anything.\n   *\n   * @private\n   */\n  _validateSchema(rawAttribute, field, value) {\n    if (rawAttribute.allowNull === false && (value === null || value === undefined)) {\n      const association = Object.values(this.modelInstance.constructor.associations).find(association => association instanceof BelongsTo && association.foreignKey === rawAttribute.fieldName);\n      if (!association || !this.modelInstance.get(association.associationAccessor)) {\n        const validators = this.modelInstance.validators[field];\n        const errMsg = _.get(validators, 'notNull.msg', `${this.modelInstance.constructor.name}.${field} cannot be null`);\n\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          errMsg,\n          'notNull Violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'is_null'\n        ));\n      }\n    }\n\n    if (rawAttribute.type instanceof DataTypes.STRING || rawAttribute.type instanceof DataTypes.TEXT || rawAttribute.type instanceof DataTypes.CITEXT) {\n      if (Array.isArray(value) || _.isObject(value) && !(value instanceof Utils.SequelizeMethod) && !Buffer.isBuffer(value)) {\n        this.errors.push(new sequelizeError.ValidationErrorItem(\n          `${field} cannot be an array or an object`,\n          'string violation', // sequelizeError.ValidationErrorItem.Origins.CORE,\n          field,\n          value,\n          this.modelInstance,\n          'not_a_string'\n        ));\n      }\n    }\n  }\n\n  /**\n   * Signs all errors retaining the original.\n   *\n   * @param {boolean}       isBuiltin   - Determines if error is from builtin validator.\n   * @param {string}        errorKey    - name of invalid attribute.\n   * @param {Error|string}  rawError    - The original error.\n   * @param {string|number} value       - The data that triggered the error.\n   * @param {string}        fnName      - Name of the validator, if any\n   * @param {Array}         fnArgs      - Arguments for the validator [function], if any\n   *\n   * @private\n   */\n  _pushError(isBuiltin, errorKey, rawError, value, fnName, fnArgs) {\n    const message = rawError.message || rawError || 'Validation error';\n    const error = new sequelizeError.ValidationErrorItem(\n      message,\n      'Validation error', // sequelizeError.ValidationErrorItem.Origins.FUNCTION,\n      errorKey,\n      value,\n      this.modelInstance,\n      fnName,\n      isBuiltin ? fnName : undefined,\n      isBuiltin ? fnArgs : undefined\n    );\n\n    error[InstanceValidator.RAW_KEY_NAME] = rawError;\n\n    this.errors.push(error);\n  }\n}\n/**\n * The error key for arguments as passed by custom validators\n *\n * @type {string}\n * @private\n */\nInstanceValidator.RAW_KEY_NAME = 'original';\n\nmodule.exports = InstanceValidator;\nmodule.exports.InstanceValidator = InstanceValidator;\nmodule.exports.default = InstanceValidator;\n"],
  "mappings": "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",
  "names": []
}
