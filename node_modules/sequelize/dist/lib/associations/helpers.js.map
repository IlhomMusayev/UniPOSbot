{
  "version": 3,
  "sources": ["../../../lib/associations/helpers.js"],
  "sourcesContent": ["'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'` +\n      ` and association '${association.as}' on model ${association.source.name}` +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      newAttribute.references = {\n        model: source.getTableName(),\n        key: key || primaryKeys[0]\n      };\n\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {object} association instance\n * @param {object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {object} aliases Mapping between model and association method names\n *\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n"],
  "mappings": "4FAEA,WAA8B,EAAa,CACzC,GAAI,OAAO,UAAU,eAAe,KAAK,EAAY,OAAO,cAAe,EAAY,IACrF,KAAM,IAAI,OACR,uCAAuC,EAAY,wBAC9B,EAAY,gBAAgB,EAAY,OAAO,uFAJjE,4BAST,QAAQ,qBAAuB,EAE/B,WAAkC,EAAc,EAAQ,EAAQ,EAAS,EAAK,CAI5E,GAAI,EAAQ,sBAAwB,EAAQ,UAAY,EAAQ,SAAU,CAExE,KAAM,GAAc,OAAO,KAAK,EAAO,aACpC,IAAI,GAAuB,EAAO,cAAc,GAAqB,OAAS,GAEjF,AAAI,GAAY,SAAW,GAAK,CAAC,EAAY,SAAS,KACpD,GAAa,WAAa,CACxB,MAAO,EAAO,eACd,IAAK,GAAO,EAAY,IAG1B,EAAa,SAAW,EAAQ,SAChC,EAAa,SAAW,EAAQ,WAhB7B,gCAoBT,QAAQ,yBAA2B,EAanC,WAAsB,EAAa,EAAK,EAAS,EAAS,CACxD,EAAU,GAAW,GAErB,SAAW,KAAU,GAEnB,GAAI,CAAC,OAAO,UAAU,eAAe,KAAK,EAAK,EAAY,UAAU,IAAU,CAC7E,KAAM,GAAa,EAAQ,IAAW,EAEtC,EAAI,EAAY,UAAU,IAAW,UAAW,CAC9C,MAAO,GAAY,GAAY,KAAM,GAAG,MAAM,KAAK,cATlD,oBAcT,QAAQ,aAAe",
  "names": []
}
