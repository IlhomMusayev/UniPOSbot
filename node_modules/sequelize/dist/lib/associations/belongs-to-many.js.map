{
  "version": 3,
  "sources": ["../../../lib/associations/belongs-to-many.js"],
  "sourcesContent": ["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst BelongsTo = require('./belongs-to');\nconst HasMany = require('./has-many');\nconst HasOne = require('./has-one');\nconst AssociationError = require('../errors').AssociationError;\nconst EmptyResultError = require('../errors').EmptyResultError;\nconst Op = require('../operators');\n\n/**\n * Many-to-many association with a join table.\n *\n * When the join table has additional attributes, these can be passed in the options object:\n *\n * ```js\n * UserProject = sequelize.define('user_project', {\n *   role: Sequelize.STRING\n * });\n * User.belongsToMany(Project, { through: UserProject });\n * Project.belongsToMany(User, { through: UserProject });\n * // through is required!\n *\n * user.addProject(project, { through: { role: 'manager' }});\n * ```\n *\n * All methods allow you to pass either a persisted instance, its primary key, or a mixture:\n *\n * ```js\n * const project = await Project.create({ id: 11 });\n * await user.addProjects([project, 12]);\n * ```\n *\n * If you want to set several target instances, but with different attributes you have to set the attributes on the instance, using a property with the name of the through model:\n *\n * ```js\n * p1.UserProjects = {\n *   started: true\n * }\n * user.setProjects([p1, p2], { through: { started: false }}) // The default value is false, but p1 overrides that.\n * ```\n *\n * Similarly, when fetching through a join table with custom attributes, these attributes will be available as an object with the name of the through model.\n * ```js\n * const projects = await user.getProjects();\n * const p1 = projects[0];\n * p1.UserProjects.started // Is this project started yet?\n * ```\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsToMany(Project)` the getter will be `user.getProjects()`.\n *\n * @see {@link Model.belongsToMany}\n */\nclass BelongsToMany extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    if (this.options.through === undefined || this.options.through === true || this.options.through === null) {\n      throw new AssociationError(`${source.name}.belongsToMany(${target.name}) requires through option, pass either a string or a model`);\n    }\n\n    if (!this.options.through.model) {\n      this.options.through = {\n        model: options.through\n      };\n    }\n\n    this.associationType = 'BelongsToMany';\n    this.targetAssociation = null;\n    this.sequelize = source.sequelize;\n    this.through = { ...this.options.through };\n    this.isMultiAssociation = true;\n    this.doubleLinked = false;\n\n    if (!this.as && this.isSelfAssociation) {\n      throw new AssociationError('\\'as\\' must be defined for many-to-many self-associations');\n    }\n\n    if (this.as) {\n      this.isAliased = true;\n\n      if (_.isPlainObject(this.as)) {\n        this.options.name = this.as;\n        this.as = this.as.plural;\n      } else {\n        this.options.name = {\n          plural: this.as,\n          singular: Utils.singularize(this.as)\n        };\n      }\n    } else {\n      this.as = this.target.options.name.plural;\n      this.options.name = this.target.options.name;\n    }\n\n    this.combinedTableName = Utils.combineTableNames(\n      this.source.tableName,\n      this.isSelfAssociation ? this.as || this.target.tableName : this.target.tableName\n    );\n\n    /*\n    * If self association, this is the target association - Unless we find a pairing association\n    */\n    if (this.isSelfAssociation) {\n      this.targetAssociation = this;\n    }\n\n    /*\n    * Find paired association (if exists)\n    */\n    _.each(this.target.associations, association => {\n      if (association.associationType !== 'BelongsToMany') return;\n      if (association.target !== this.source) return;\n\n      if (this.options.through.model === association.options.through.model) {\n        this.paired = association;\n        association.paired = this;\n      }\n    });\n\n    /*\n    * Default/generated source/target keys\n    */\n    this.sourceKey = this.options.sourceKey || this.source.primaryKeyAttribute;\n    this.sourceKeyField = this.source.rawAttributes[this.sourceKey].field || this.sourceKey;\n\n    if (this.options.targetKey) {\n      this.targetKey = this.options.targetKey;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    } else {\n      this.targetKeyDefault = true;\n      this.targetKey = this.target.primaryKeyAttribute;\n      this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    }\n\n    this._createForeignAndOtherKeys();\n\n    if (typeof this.through.model === 'string') {\n      if (!this.sequelize.isDefined(this.through.model)) {\n        this.through.model = this.sequelize.define(this.through.model, {}, Object.assign(this.options, {\n          tableName: this.through.model,\n          indexes: [], //we don't want indexes here (as referenced in #2416)\n          paranoid: this.through.paranoid ? this.through.paranoid : false, // Default to non-paranoid join (referenced in #11991)\n          validate: {} // Don't propagate model-level validations\n        }));\n      } else {\n        this.through.model = this.sequelize.model(this.through.model);\n      }\n    }\n\n    Object.assign(this.options, _.pick(this.through.model.options, [\n      'timestamps', 'createdAt', 'updatedAt', 'deletedAt', 'paranoid'\n    ]));\n\n    if (this.paired) {\n      let needInjectPaired = false;\n\n      if (this.targetKeyDefault) {\n        this.targetKey = this.paired.sourceKey;\n        this.targetKeyField = this.paired.sourceKeyField;\n        this._createForeignAndOtherKeys();\n      }\n      if (this.paired.targetKeyDefault) {\n        // in this case paired.otherKey depends on paired.targetKey,\n        // so cleanup previously wrong generated otherKey\n        if (this.paired.targetKey !== this.sourceKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.targetKey = this.sourceKey;\n          this.paired.targetKeyField = this.sourceKeyField;\n          this.paired._createForeignAndOtherKeys();\n          needInjectPaired = true;\n        }\n      }\n\n      if (this.otherKeyDefault) {\n        this.otherKey = this.paired.foreignKey;\n      }\n      if (this.paired.otherKeyDefault) {\n        // If paired otherKey was inferred we should make sure to clean it up\n        // before adding a new one that matches the foreignKey\n        if (this.paired.otherKey !== this.foreignKey) {\n          delete this.through.model.rawAttributes[this.paired.otherKey];\n          this.paired.otherKey = this.foreignKey;\n          needInjectPaired = true;\n        }\n      }\n\n      if (needInjectPaired) {\n        this.paired._injectAttributes();\n      }\n    }\n\n    if (this.through) {\n      this.throughModel = this.through.model;\n    }\n\n    this.options.tableName = this.combinedName = this.through.model === Object(this.through.model) ? this.through.model.tableName : this.through.model;\n\n    this.associationAccessor = this.as;\n\n    // Get singular and plural names, trying to uppercase the first letter, unless the model forbids it\n    const plural = _.upperFirst(this.options.name.plural);\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${plural}`,\n      set: `set${plural}`,\n      addMultiple: `add${plural}`,\n      add: `add${singular}`,\n      create: `create${singular}`,\n      remove: `remove${singular}`,\n      removeMultiple: `remove${plural}`,\n      hasSingle: `has${singular}`,\n      hasAll: `has${plural}`,\n      count: `count${plural}`\n    };\n  }\n\n  _createForeignAndOtherKeys() {\n    /*\n    * Default/generated foreign/other keys\n    */\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else {\n      this.foreignKeyAttribute = {};\n      this.foreignKey = this.options.foreignKey || Utils.camelize(\n        [\n          this.source.options.name.singular,\n          this.sourceKey\n        ].join('_')\n      );\n    }\n\n    if (_.isObject(this.options.otherKey)) {\n      this.otherKeyAttribute = this.options.otherKey;\n      this.otherKey = this.otherKeyAttribute.name || this.otherKeyAttribute.fieldName;\n    } else {\n      if (!this.options.otherKey) {\n        this.otherKeyDefault = true;\n      }\n\n      this.otherKeyAttribute = {};\n      this.otherKey = this.options.otherKey || Utils.camelize(\n        [\n          this.isSelfAssociation ? Utils.singularize(this.as) : this.target.options.name.singular,\n          this.targetKey\n        ].join('_')\n      );\n    }\n  }\n\n  // the id is in the target table\n  // or in an extra table which connects two tables\n  _injectAttributes() {\n    this.identifier = this.foreignKey;\n    this.foreignIdentifier = this.otherKey;\n\n    // remove any PKs previously defined by sequelize\n    // but ignore any keys that are part of this association (#5865)\n    _.each(this.through.model.rawAttributes, (attribute, attributeName) => {\n      if (attribute.primaryKey === true && attribute._autoGenerated === true) {\n        if (attributeName === this.foreignKey || attributeName === this.otherKey) {\n          // this key is still needed as it's part of the association\n          // so just set primaryKey to false\n          attribute.primaryKey = false;\n        }\n        else {\n          delete this.through.model.rawAttributes[attributeName];\n        }\n        this.primaryKeyDeleted = true;\n      }\n    });\n\n    const sourceKey = this.source.rawAttributes[this.sourceKey];\n    const sourceKeyType = sourceKey.type;\n    const sourceKeyField = this.sourceKeyField;\n    const targetKey = this.target.rawAttributes[this.targetKey];\n    const targetKeyType = targetKey.type;\n    const targetKeyField = this.targetKeyField;\n    const sourceAttribute = { type: sourceKeyType, ...this.foreignKeyAttribute };\n    const targetAttribute = { type: targetKeyType, ...this.otherKeyAttribute };\n\n    if (this.primaryKeyDeleted === true) {\n      targetAttribute.primaryKey = sourceAttribute.primaryKey = true;\n    } else if (this.through.unique !== false) {\n      let uniqueKey;\n      if (typeof this.options.uniqueKey === 'string' && this.options.uniqueKey !== '') {\n        uniqueKey = this.options.uniqueKey;\n      } else {\n        uniqueKey = [this.through.model.tableName, this.foreignKey, this.otherKey, 'unique'].join('_');\n      }\n      targetAttribute.unique = sourceAttribute.unique = uniqueKey;\n    }\n\n    if (!this.through.model.rawAttributes[this.foreignKey]) {\n      this.through.model.rawAttributes[this.foreignKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (!this.through.model.rawAttributes[this.otherKey]) {\n      this.through.model.rawAttributes[this.otherKey] = {\n        _autoGenerated: true\n      };\n    }\n\n    if (this.options.constraints !== false) {\n      sourceAttribute.references = {\n        model: this.source.getTableName(),\n        key: sourceKeyField\n      };\n      // For the source attribute the passed option is the priority\n      sourceAttribute.onDelete = this.options.onDelete || this.through.model.rawAttributes[this.foreignKey].onDelete;\n      sourceAttribute.onUpdate = this.options.onUpdate || this.through.model.rawAttributes[this.foreignKey].onUpdate;\n\n      if (!sourceAttribute.onDelete) sourceAttribute.onDelete = 'CASCADE';\n      if (!sourceAttribute.onUpdate) sourceAttribute.onUpdate = 'CASCADE';\n\n      targetAttribute.references = {\n        model: this.target.getTableName(),\n        key: targetKeyField\n      };\n      // But the for target attribute the previously defined option is the priority (since it could've been set by another belongsToMany call)\n      targetAttribute.onDelete = this.through.model.rawAttributes[this.otherKey].onDelete || this.options.onDelete;\n      targetAttribute.onUpdate = this.through.model.rawAttributes[this.otherKey].onUpdate || this.options.onUpdate;\n\n      if (!targetAttribute.onDelete) targetAttribute.onDelete = 'CASCADE';\n      if (!targetAttribute.onUpdate) targetAttribute.onUpdate = 'CASCADE';\n    }\n\n    Object.assign(this.through.model.rawAttributes[this.foreignKey], sourceAttribute);\n    Object.assign(this.through.model.rawAttributes[this.otherKey], targetAttribute);\n\n    this.through.model.refreshAttributes();\n\n    this.identifierField = this.through.model.rawAttributes[this.foreignKey].field || this.foreignKey;\n    this.foreignIdentifierField = this.through.model.rawAttributes[this.otherKey].field || this.otherKey;\n\n    if (this.paired && !this.paired.foreignIdentifierField) {\n      this.paired.foreignIdentifierField = this.through.model.rawAttributes[this.paired.otherKey].field || this.paired.otherKey;\n    }\n\n    this.toSource = new BelongsTo(this.through.model, this.source, {\n      foreignKey: this.foreignKey\n    });\n    this.manyFromSource = new HasMany(this.source, this.through.model, {\n      foreignKey: this.foreignKey\n    });\n    this.oneFromSource = new HasOne(this.source, this.through.model, {\n      foreignKey: this.foreignKey,\n      sourceKey: this.sourceKey,\n      as: this.through.model.name\n    });\n\n    this.toTarget = new BelongsTo(this.through.model, this.target, {\n      foreignKey: this.otherKey\n    });\n    this.manyFromTarget = new HasMany(this.target, this.through.model, {\n      foreignKey: this.otherKey\n    });\n    this.oneFromTarget = new HasOne(this.target, this.through.model, {\n      foreignKey: this.otherKey,\n      sourceKey: this.targetKey,\n      as: this.through.model.name\n    });\n\n    if (this.paired && this.paired.otherKeyDefault) {\n      this.paired.toTarget = new BelongsTo(this.paired.through.model, this.paired.target, {\n        foreignKey: this.paired.otherKey\n      });\n\n      this.paired.oneFromTarget = new HasOne(this.paired.target, this.paired.through.model, {\n        foreignKey: this.paired.otherKey,\n        sourceKey: this.paired.targetKey,\n        as: this.paired.through.model.name\n      });\n    }\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'count', 'hasSingle', 'hasAll', 'set', 'add', 'addMultiple', 'remove', 'removeMultiple', 'create'];\n    const aliases = {\n      hasSingle: 'has',\n      hasAll: 'has',\n      addMultiple: 'add',\n      removeMultiple: 'remove'\n    };\n\n    Helpers.mixinMethods(this, obj, methods, aliases);\n  }\n\n  /**\n   * Get everything currently associated with this, using an optional where clause.\n   *\n   * @see\n   * {@link Model} for a full explanation of options\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   * @param {string} [options.schema] Apply a schema on the related model\n   * @param {object} [options.through.where] An optional where clause applied to through model (join table)\n   * @param {boolean} [options.through.paranoid=true] If true, only non-deleted records will be returned from the join table. If false, both deleted and non-deleted records will be returned. Only applies if through model is paranoid\n   *\n   * @returns {Promise<Array<Model>>}\n   */\n  async get(instance, options) {\n    options = Utils.cloneDeep(options) || {};\n\n    const through = this.through;\n    let scopeWhere;\n    let throughWhere;\n\n    if (this.scope) {\n      scopeWhere = { ...this.scope };\n    }\n\n    options.where = {\n      [Op.and]: [\n        scopeWhere,\n        options.where\n      ]\n    };\n\n    if (Object(through.model) === through.model) {\n      throughWhere = {};\n      throughWhere[this.foreignKey] = instance.get(this.sourceKey);\n\n      if (through.scope) {\n        Object.assign(throughWhere, through.scope);\n      }\n\n      //If a user pass a where on the options through options, make an \"and\" with the current throughWhere\n      if (options.through && options.through.where) {\n        throughWhere = {\n          [Op.and]: [throughWhere, options.through.where]\n        };\n      }\n\n      options.include = options.include || [];\n      options.include.push({\n        association: this.oneFromTarget,\n        attributes: options.joinTableAttributes,\n        required: true,\n        paranoid: _.get(options.through, 'paranoid', true),\n        where: throughWhere\n      });\n    }\n\n    let model = this.target;\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        model = model.unscoped();\n      } else {\n        model = model.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      model = model.schema(options.schema, options.schemaDelimiter);\n    }\n\n    return model.findAll(options);\n  }\n\n  /**\n   * Count everything currently associated with this, using an optional where clause.\n   *\n   * @param {Model} instance instance\n   * @param {object} [options] find options\n   * @param {object} [options.where] An optional where clause to limit the associated models\n   * @param {string|boolean} [options.scope] Apply a scope on the related model, or remove its default scope by passing false\n   *\n   * @returns {Promise<number>}\n   */\n  async count(instance, options) {\n    const sequelize = this.target.sequelize;\n\n    options = Utils.cloneDeep(options);\n    options.attributes = [\n      [sequelize.fn('COUNT', sequelize.col([this.target.name, this.targetKeyField].join('.'))), 'count']\n    ];\n    options.joinTableAttributes = [];\n    options.raw = true;\n    options.plain = true;\n\n    const result = await this.get(instance, options);\n\n    return parseInt(result.count, 10);\n  }\n\n  /**\n   * Check if one or more instance(s) are associated with this. If a list of instances is passed, the function returns true if _all_ instances are associated\n   *\n   * @param {Model} sourceInstance source instance to check for an association with\n   * @param {Model|Model[]|string[]|string|number[]|number} [instances] Can be an array of instances or their primary keys\n   * @param {object} [options] Options passed to getAssociations\n   *\n   * @returns {Promise<boolean>}\n   */\n  async has(sourceInstance, instances, options) {\n    if (!Array.isArray(instances)) {\n      instances = [instances];\n    }\n\n    options = {\n      raw: true,\n      ...options,\n      scope: false,\n      attributes: [this.targetKey],\n      joinTableAttributes: []\n    };\n\n    const instancePrimaryKeys = instances.map(instance => {\n      if (instance instanceof this.target) {\n        return instance.where();\n      }\n      return {\n        [this.targetKey]: instance\n      };\n    });\n\n    options.where = {\n      [Op.and]: [\n        { [Op.or]: instancePrimaryKeys },\n        options.where\n      ]\n    };\n\n    const associatedObjects = await this.get(sourceInstance, options);\n\n    return _.differenceWith(instancePrimaryKeys, associatedObjects,\n      (a, b) => _.isEqual(a[this.targetKey], b[this.targetKey])).length === 0;\n  }\n\n  /**\n   * Set the associated models by passing an array of instances or their primary keys.\n   * Everything that it not in the passed array will be un-associated.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newAssociatedObjects] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate`, `update` and `destroy`\n   * @param {object} [options.validate] Run validation for the join model\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async set(sourceInstance, newAssociatedObjects, options) {\n    options = options || {};\n\n    const sourceKey = this.sourceKey;\n    const targetKey = this.targetKey;\n    const identifier = this.identifier;\n    const foreignIdentifier = this.foreignIdentifier;\n\n    if (newAssociatedObjects === null) {\n      newAssociatedObjects = [];\n    } else {\n      newAssociatedObjects = this.toInstanceArray(newAssociatedObjects);\n    }\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      ...this.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const obsoleteAssociations = [];\n      const promises = [];\n      const defaultAttributes = options.through || {};\n\n      const unassociatedObjects = newAssociatedObjects.filter(obj =>\n        !currentRows.some(currentRow => currentRow[foreignIdentifier] === obj.get(targetKey))\n      );\n\n      for (const currentRow of currentRows) {\n        const newObj = newAssociatedObjects.find(obj => currentRow[foreignIdentifier] === obj.get(targetKey));\n\n        if (!newObj) {\n          obsoleteAssociations.push(currentRow);\n        } else {\n          let throughAttributes = newObj[this.through.model.name];\n          // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n          if (throughAttributes instanceof this.through.model) {\n            throughAttributes = {};\n          }\n\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).length) {\n            promises.push(\n              this.through.model.update(attributes, Object.assign(options, {\n                where: {\n                  [identifier]: sourceInstance.get(sourceKey),\n                  [foreignIdentifier]: newObj.get(targetKey)\n                }\n              }\n              ))\n            );\n          }\n        }\n      }\n\n      if (obsoleteAssociations.length > 0) {\n        promises.push(\n          this.through.model.destroy({\n            ...options,\n            where: {\n              [identifier]: sourceInstance.get(sourceKey),\n              [foreignIdentifier]: obsoleteAssociations.map(obsoleteAssociation => obsoleteAssociation[foreignIdentifier]),\n              ...this.through.scope\n            }\n          })\n        );\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          return {\n            ...defaultAttributes,\n            ...unassociatedObject[this.through.model.name],\n            [identifier]: sourceInstance.get(sourceKey),\n            [foreignIdentifier]: unassociatedObject.get(targetKey),\n            ...this.through.scope\n          };\n        });\n\n        promises.push(this.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await this.through.model.findAll({ ...options, where, raw: true });\n      return await updateAssociations(currentRows);\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations([]);\n      throw error;\n    }\n  }\n\n  /**\n   * Associate one or several rows with source instance. It will not un-associate any already associated instance\n   * that may be missing from `newInstances`.\n   *\n   * @param {Model} sourceInstance source instance to associate new instances with\n   * @param {Model|Model[]|string[]|string|number[]|number} [newInstances] A single instance or primary key, or a mixed array of persisted instances or primary keys\n   * @param {object} [options] Options passed to `through.findAll`, `bulkCreate` and `update`\n   * @param {object} [options.validate] Run validation for the join model.\n   * @param {object} [options.through] Additional attributes for the join table.\n   *\n   * @returns {Promise}\n   */\n  async add(sourceInstance, newInstances, options) {\n    // If newInstances is null or undefined, no-op\n    if (!newInstances) return Promise.resolve();\n\n    options = { ...options };\n\n    const association = this;\n    const sourceKey = association.sourceKey;\n    const targetKey = association.targetKey;\n    const identifier = association.identifier;\n    const foreignIdentifier = association.foreignIdentifier;\n    const defaultAttributes = options.through || {};\n\n    newInstances = association.toInstanceArray(newInstances);\n\n    const where = {\n      [identifier]: sourceInstance.get(sourceKey),\n      [foreignIdentifier]: newInstances.map(newInstance => newInstance.get(targetKey)),\n      ...association.through.scope\n    };\n\n    const updateAssociations = currentRows => {\n      const promises = [];\n      const unassociatedObjects = [];\n      const changedAssociations = [];\n      for (const obj of newInstances) {\n        const existingAssociation = currentRows && currentRows.find(current => current[foreignIdentifier] === obj.get(targetKey));\n\n        if (!existingAssociation) {\n          unassociatedObjects.push(obj);\n        } else {\n          const throughAttributes = obj[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          if (Object.keys(attributes).some(attribute => attributes[attribute] !== existingAssociation[attribute])) {\n            changedAssociations.push(obj);\n          }\n        }\n      }\n\n      if (unassociatedObjects.length > 0) {\n        const bulk = unassociatedObjects.map(unassociatedObject => {\n          const throughAttributes = unassociatedObject[association.through.model.name];\n          const attributes = { ...defaultAttributes, ...throughAttributes };\n\n          attributes[identifier] = sourceInstance.get(sourceKey);\n          attributes[foreignIdentifier] = unassociatedObject.get(targetKey);\n\n          Object.assign(attributes, association.through.scope);\n\n          return attributes;\n        });\n\n        promises.push(association.through.model.bulkCreate(bulk, { validate: true, ...options }));\n      }\n\n      for (const assoc of changedAssociations) {\n        let throughAttributes = assoc[association.through.model.name];\n        const attributes = { ...defaultAttributes, ...throughAttributes };\n        // Quick-fix for subtle bug when using existing objects that might have the through model attached (not as an attribute object)\n        if (throughAttributes instanceof association.through.model) {\n          throughAttributes = {};\n        }\n\n        promises.push(association.through.model.update(attributes, Object.assign(options, { where: {\n          [identifier]: sourceInstance.get(sourceKey),\n          [foreignIdentifier]: assoc.get(targetKey)\n        } })));\n      }\n\n      return Promise.all(promises);\n    };\n\n    try {\n      const currentRows = await association.through.model.findAll({ ...options, where, raw: true });\n      const [associations] = await updateAssociations(currentRows);\n      return associations;\n    } catch (error) {\n      if (error instanceof EmptyResultError) return updateAssociations();\n      throw error;\n    }\n  }\n\n  /**\n   * Un-associate one or more instance(s).\n   *\n   * @param {Model} sourceInstance instance to un associate instances with\n   * @param {Model|Model[]|string|string[]|number|number[]} [oldAssociatedObjects] Can be an Instance or its primary key, or a mixed array of instances and primary keys\n   * @param {object} [options] Options passed to `through.destroy`\n   *\n   * @returns {Promise}\n   */\n  remove(sourceInstance, oldAssociatedObjects, options) {\n    const association = this;\n\n    options = options || {};\n\n    oldAssociatedObjects = association.toInstanceArray(oldAssociatedObjects);\n\n    const where = {\n      [association.identifier]: sourceInstance.get(association.sourceKey),\n      [association.foreignIdentifier]: oldAssociatedObjects.map(newInstance => newInstance.get(association.targetKey))\n    };\n\n    return association.through.model.destroy({ ...options, where });\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance source instance\n   * @param {object} [values] values for target model\n   * @param {object} [options] Options passed to create and add\n   * @param {object} [options.through] Additional attributes for the join table\n   *\n   * @returns {Promise}\n   */\n  async create(sourceInstance, values, options) {\n    const association = this;\n\n    options = options || {};\n    values = values || {};\n\n    if (Array.isArray(options)) {\n      options = {\n        fields: options\n      };\n    }\n\n    if (association.scope) {\n      Object.assign(values, association.scope);\n      if (options.fields) {\n        options.fields = options.fields.concat(Object.keys(association.scope));\n      }\n    }\n\n    // Create the related model instance\n    const newAssociatedObject = await association.target.create(values, options);\n\n    await sourceInstance[association.accessors.add](newAssociatedObject, _.omit(options, ['fields']));\n    return newAssociatedObject;\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.plural) {\n      return this.as === alias.plural;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsToMany;\nmodule.exports.BelongsToMany = BelongsToMany;\nmodule.exports.default = BelongsToMany;\n"],
  "mappings": "6eAEA,KAAM,GAAQ,QAAQ,cAChB,EAAU,QAAQ,aAClB,EAAI,QAAQ,UACZ,EAAc,QAAQ,UACtB,EAAY,QAAQ,gBACpB,EAAU,QAAQ,cAClB,EAAS,QAAQ,aACjB,EAAmB,QAAQ,aAAa,iBACxC,EAAmB,QAAQ,aAAa,iBACxC,EAAK,QAAQ,gBA6CnB,eAA4B,EAAY,CACtC,YAAY,EAAQ,EAAQ,EAAS,CACnC,MAAM,EAAQ,EAAQ,GAEtB,GAAI,KAAK,QAAQ,UAAY,QAAa,KAAK,QAAQ,UAAY,IAAQ,KAAK,QAAQ,UAAY,KAClG,KAAM,IAAI,GAAiB,GAAG,EAAO,sBAAsB,EAAO,kEAgBpE,GAbK,KAAK,QAAQ,QAAQ,OACxB,MAAK,QAAQ,QAAU,CACrB,MAAO,EAAQ,UAInB,KAAK,gBAAkB,gBACvB,KAAK,kBAAoB,KACzB,KAAK,UAAY,EAAO,UACxB,KAAK,QAAU,KAAK,KAAK,QAAQ,SACjC,KAAK,mBAAqB,GAC1B,KAAK,aAAe,GAEhB,CAAC,KAAK,IAAM,KAAK,kBACnB,KAAM,IAAI,GAAiB,2DA+E7B,GA5EA,AAAI,KAAK,GACP,MAAK,UAAY,GAEjB,AAAI,EAAE,cAAc,KAAK,IACvB,MAAK,QAAQ,KAAO,KAAK,GACzB,KAAK,GAAK,KAAK,GAAG,QAElB,KAAK,QAAQ,KAAO,CAClB,OAAQ,KAAK,GACb,SAAU,EAAM,YAAY,KAAK,MAIrC,MAAK,GAAK,KAAK,OAAO,QAAQ,KAAK,OACnC,KAAK,QAAQ,KAAO,KAAK,OAAO,QAAQ,MAG1C,KAAK,kBAAoB,EAAM,kBAC7B,KAAK,OAAO,UACZ,KAAK,kBAAoB,KAAK,IAAM,KAAK,OAAO,UAAY,KAAK,OAAO,WAMtE,KAAK,mBACP,MAAK,kBAAoB,MAM3B,EAAE,KAAK,KAAK,OAAO,aAAc,GAAe,CAC9C,AAAI,EAAY,kBAAoB,iBAChC,EAAY,SAAW,KAAK,QAE5B,KAAK,QAAQ,QAAQ,QAAU,EAAY,QAAQ,QAAQ,OAC7D,MAAK,OAAS,EACd,EAAY,OAAS,QAOzB,KAAK,UAAY,KAAK,QAAQ,WAAa,KAAK,OAAO,oBACvD,KAAK,eAAiB,KAAK,OAAO,cAAc,KAAK,WAAW,OAAS,KAAK,UAE9E,AAAI,KAAK,QAAQ,UACf,MAAK,UAAY,KAAK,QAAQ,UAC9B,KAAK,eAAiB,KAAK,OAAO,cAAc,KAAK,WAAW,OAAS,KAAK,WAE9E,MAAK,iBAAmB,GACxB,KAAK,UAAY,KAAK,OAAO,oBAC7B,KAAK,eAAiB,KAAK,OAAO,cAAc,KAAK,WAAW,OAAS,KAAK,WAGhF,KAAK,6BAED,MAAO,MAAK,QAAQ,OAAU,UAChC,CAAK,KAAK,UAAU,UAAU,KAAK,QAAQ,OAQzC,KAAK,QAAQ,MAAQ,KAAK,UAAU,MAAM,KAAK,QAAQ,OAPvD,KAAK,QAAQ,MAAQ,KAAK,UAAU,OAAO,KAAK,QAAQ,MAAO,GAAI,OAAO,OAAO,KAAK,QAAS,CAC7F,UAAW,KAAK,QAAQ,MACxB,QAAS,GACT,SAAU,KAAK,QAAQ,SAAW,KAAK,QAAQ,SAAW,GAC1D,SAAU,OAOhB,OAAO,OAAO,KAAK,QAAS,EAAE,KAAK,KAAK,QAAQ,MAAM,QAAS,CAC7D,aAAc,YAAa,YAAa,YAAa,cAGnD,KAAK,OAAQ,CACf,GAAI,GAAmB,GAEvB,AAAI,KAAK,kBACP,MAAK,UAAY,KAAK,OAAO,UAC7B,KAAK,eAAiB,KAAK,OAAO,eAClC,KAAK,8BAEH,KAAK,OAAO,kBAGV,KAAK,OAAO,YAAc,KAAK,WACjC,OAAO,MAAK,QAAQ,MAAM,cAAc,KAAK,OAAO,UACpD,KAAK,OAAO,UAAY,KAAK,UAC7B,KAAK,OAAO,eAAiB,KAAK,eAClC,KAAK,OAAO,6BACZ,EAAmB,IAInB,KAAK,iBACP,MAAK,SAAW,KAAK,OAAO,YAE1B,KAAK,OAAO,iBAGV,KAAK,OAAO,WAAa,KAAK,YAChC,OAAO,MAAK,QAAQ,MAAM,cAAc,KAAK,OAAO,UACpD,KAAK,OAAO,SAAW,KAAK,WAC5B,EAAmB,IAInB,GACF,KAAK,OAAO,oBAIhB,AAAI,KAAK,SACP,MAAK,aAAe,KAAK,QAAQ,OAGnC,KAAK,QAAQ,UAAY,KAAK,aAAe,KAAK,QAAQ,QAAU,OAAO,KAAK,QAAQ,OAAS,KAAK,QAAQ,MAAM,UAAY,KAAK,QAAQ,MAE7I,KAAK,oBAAsB,KAAK,GAGhC,KAAM,GAAS,EAAE,WAAW,KAAK,QAAQ,KAAK,QACxC,EAAW,EAAE,WAAW,KAAK,QAAQ,KAAK,UAEhD,KAAK,UAAY,CACf,IAAK,MAAM,IACX,IAAK,MAAM,IACX,YAAa,MAAM,IACnB,IAAK,MAAM,IACX,OAAQ,SAAS,IACjB,OAAQ,SAAS,IACjB,eAAgB,SAAS,IACzB,UAAW,MAAM,IACjB,OAAQ,MAAM,IACd,MAAO,QAAQ,KAInB,4BAA6B,CAI3B,AAAI,EAAE,SAAS,KAAK,QAAQ,YAC1B,MAAK,oBAAsB,KAAK,QAAQ,WACxC,KAAK,WAAa,KAAK,oBAAoB,MAAQ,KAAK,oBAAoB,WAE5E,MAAK,oBAAsB,GAC3B,KAAK,WAAa,KAAK,QAAQ,YAAc,EAAM,SACjD,CACE,KAAK,OAAO,QAAQ,KAAK,SACzB,KAAK,WACL,KAAK,OAIX,AAAI,EAAE,SAAS,KAAK,QAAQ,UAC1B,MAAK,kBAAoB,KAAK,QAAQ,SACtC,KAAK,SAAW,KAAK,kBAAkB,MAAQ,KAAK,kBAAkB,WAEjE,MAAK,QAAQ,UAChB,MAAK,gBAAkB,IAGzB,KAAK,kBAAoB,GACzB,KAAK,SAAW,KAAK,QAAQ,UAAY,EAAM,SAC7C,CACE,KAAK,kBAAoB,EAAM,YAAY,KAAK,IAAM,KAAK,OAAO,QAAQ,KAAK,SAC/E,KAAK,WACL,KAAK,OAOb,mBAAoB,CAClB,KAAK,WAAa,KAAK,WACvB,KAAK,kBAAoB,KAAK,SAI9B,EAAE,KAAK,KAAK,QAAQ,MAAM,cAAe,CAAC,EAAW,IAAkB,CACrE,AAAI,EAAU,aAAe,IAAQ,EAAU,iBAAmB,IAChE,CAAI,IAAkB,KAAK,YAAc,IAAkB,KAAK,SAG9D,EAAU,WAAa,GAGvB,MAAO,MAAK,QAAQ,MAAM,cAAc,GAE1C,KAAK,kBAAoB,MAK7B,KAAM,GAAgB,AADJ,KAAK,OAAO,cAAc,KAAK,WACjB,KAC1B,EAAiB,KAAK,eAEtB,EAAgB,AADJ,KAAK,OAAO,cAAc,KAAK,WACjB,KAC1B,EAAiB,KAAK,eACtB,EAAkB,GAAE,KAAM,GAAkB,KAAK,qBACjD,EAAkB,GAAE,KAAM,GAAkB,KAAK,mBAEvD,GAAI,KAAK,oBAAsB,GAC7B,EAAgB,WAAa,EAAgB,WAAa,WACjD,KAAK,QAAQ,SAAW,GAAO,CACxC,GAAI,GACJ,AAAI,MAAO,MAAK,QAAQ,WAAc,UAAY,KAAK,QAAQ,YAAc,GAC3E,EAAY,KAAK,QAAQ,UAEzB,EAAY,CAAC,KAAK,QAAQ,MAAM,UAAW,KAAK,WAAY,KAAK,SAAU,UAAU,KAAK,KAE5F,EAAgB,OAAS,EAAgB,OAAS,EAGpD,MAAK,MAAK,QAAQ,MAAM,cAAc,KAAK,aACzC,MAAK,QAAQ,MAAM,cAAc,KAAK,YAAc,CAClD,eAAgB,KAIf,KAAK,QAAQ,MAAM,cAAc,KAAK,WACzC,MAAK,QAAQ,MAAM,cAAc,KAAK,UAAY,CAChD,eAAgB,KAIhB,KAAK,QAAQ,cAAgB,IAC/B,GAAgB,WAAa,CAC3B,MAAO,KAAK,OAAO,eACnB,IAAK,GAGP,EAAgB,SAAW,KAAK,QAAQ,UAAY,KAAK,QAAQ,MAAM,cAAc,KAAK,YAAY,SACtG,EAAgB,SAAW,KAAK,QAAQ,UAAY,KAAK,QAAQ,MAAM,cAAc,KAAK,YAAY,SAEjG,EAAgB,UAAU,GAAgB,SAAW,WACrD,EAAgB,UAAU,GAAgB,SAAW,WAE1D,EAAgB,WAAa,CAC3B,MAAO,KAAK,OAAO,eACnB,IAAK,GAGP,EAAgB,SAAW,KAAK,QAAQ,MAAM,cAAc,KAAK,UAAU,UAAY,KAAK,QAAQ,SACpG,EAAgB,SAAW,KAAK,QAAQ,MAAM,cAAc,KAAK,UAAU,UAAY,KAAK,QAAQ,SAE/F,EAAgB,UAAU,GAAgB,SAAW,WACrD,EAAgB,UAAU,GAAgB,SAAW,YAG5D,OAAO,OAAO,KAAK,QAAQ,MAAM,cAAc,KAAK,YAAa,GACjE,OAAO,OAAO,KAAK,QAAQ,MAAM,cAAc,KAAK,UAAW,GAE/D,KAAK,QAAQ,MAAM,oBAEnB,KAAK,gBAAkB,KAAK,QAAQ,MAAM,cAAc,KAAK,YAAY,OAAS,KAAK,WACvF,KAAK,uBAAyB,KAAK,QAAQ,MAAM,cAAc,KAAK,UAAU,OAAS,KAAK,SAExF,KAAK,QAAU,CAAC,KAAK,OAAO,wBAC9B,MAAK,OAAO,uBAAyB,KAAK,QAAQ,MAAM,cAAc,KAAK,OAAO,UAAU,OAAS,KAAK,OAAO,UAGnH,KAAK,SAAW,GAAI,GAAU,KAAK,QAAQ,MAAO,KAAK,OAAQ,CAC7D,WAAY,KAAK,aAEnB,KAAK,eAAiB,GAAI,GAAQ,KAAK,OAAQ,KAAK,QAAQ,MAAO,CACjE,WAAY,KAAK,aAEnB,KAAK,cAAgB,GAAI,GAAO,KAAK,OAAQ,KAAK,QAAQ,MAAO,CAC/D,WAAY,KAAK,WACjB,UAAW,KAAK,UAChB,GAAI,KAAK,QAAQ,MAAM,OAGzB,KAAK,SAAW,GAAI,GAAU,KAAK,QAAQ,MAAO,KAAK,OAAQ,CAC7D,WAAY,KAAK,WAEnB,KAAK,eAAiB,GAAI,GAAQ,KAAK,OAAQ,KAAK,QAAQ,MAAO,CACjE,WAAY,KAAK,WAEnB,KAAK,cAAgB,GAAI,GAAO,KAAK,OAAQ,KAAK,QAAQ,MAAO,CAC/D,WAAY,KAAK,SACjB,UAAW,KAAK,UAChB,GAAI,KAAK,QAAQ,MAAM,OAGrB,KAAK,QAAU,KAAK,OAAO,iBAC7B,MAAK,OAAO,SAAW,GAAI,GAAU,KAAK,OAAO,QAAQ,MAAO,KAAK,OAAO,OAAQ,CAClF,WAAY,KAAK,OAAO,WAG1B,KAAK,OAAO,cAAgB,GAAI,GAAO,KAAK,OAAO,OAAQ,KAAK,OAAO,QAAQ,MAAO,CACpF,WAAY,KAAK,OAAO,SACxB,UAAW,KAAK,OAAO,UACvB,GAAI,KAAK,OAAO,QAAQ,MAAM,QAIlC,EAAQ,qBAAqB,MAEtB,KAGT,MAAM,EAAK,CACT,KAAM,GAAU,CAAC,MAAO,QAAS,YAAa,SAAU,MAAO,MAAO,cAAe,SAAU,iBAAkB,UAC3G,EAAU,CACd,UAAW,MACX,OAAQ,MACR,YAAa,MACb,eAAgB,UAGlB,EAAQ,aAAa,KAAM,EAAK,EAAS,QAmBrC,KAAI,EAAU,EAAS,CAC3B,EAAU,EAAM,UAAU,IAAY,GAEtC,KAAM,GAAU,KAAK,QACrB,GAAI,GACA,EAEJ,AAAI,KAAK,OACP,GAAa,KAAK,KAAK,QAGzB,EAAQ,MAAQ,EACb,EAAG,KAAM,CACR,EACA,EAAQ,QAIR,OAAO,EAAQ,SAAW,EAAQ,OACpC,GAAe,GACf,EAAa,KAAK,YAAc,EAAS,IAAI,KAAK,WAE9C,EAAQ,OACV,OAAO,OAAO,EAAc,EAAQ,OAIlC,EAAQ,SAAW,EAAQ,QAAQ,OACrC,GAAe,EACZ,EAAG,KAAM,CAAC,EAAc,EAAQ,QAAQ,SAI7C,EAAQ,QAAU,EAAQ,SAAW,GACrC,EAAQ,QAAQ,KAAK,CACnB,YAAa,KAAK,cAClB,WAAY,EAAQ,oBACpB,SAAU,GACV,SAAU,EAAE,IAAI,EAAQ,QAAS,WAAY,IAC7C,MAAO,KAIX,GAAI,GAAQ,KAAK,OACjB,MAAI,QAAO,UAAU,eAAe,KAAK,EAAS,UAChD,CAAK,EAAQ,MAGX,EAAQ,EAAM,MAAM,EAAQ,OAF5B,EAAQ,EAAM,YAMd,OAAO,UAAU,eAAe,KAAK,EAAS,WAChD,GAAQ,EAAM,OAAO,EAAQ,OAAQ,EAAQ,kBAGxC,EAAM,QAAQ,QAajB,OAAM,EAAU,EAAS,CAC7B,KAAM,GAAY,KAAK,OAAO,UAE9B,EAAU,EAAM,UAAU,GAC1B,EAAQ,WAAa,CACnB,CAAC,EAAU,GAAG,QAAS,EAAU,IAAI,CAAC,KAAK,OAAO,KAAM,KAAK,gBAAgB,KAAK,OAAQ,UAE5F,EAAQ,oBAAsB,GAC9B,EAAQ,IAAM,GACd,EAAQ,MAAQ,GAEhB,KAAM,GAAS,KAAM,MAAK,IAAI,EAAU,GAExC,MAAO,UAAS,EAAO,MAAO,SAY1B,KAAI,EAAgB,EAAW,EAAS,CAC5C,AAAK,MAAM,QAAQ,IACjB,GAAY,CAAC,IAGf,EAAU,KACR,IAAK,IACF,GAFK,CAGR,MAAO,GACP,WAAY,CAAC,KAAK,WAClB,oBAAqB,KAGvB,KAAM,GAAsB,EAAU,IAAI,GACpC,YAAoB,MAAK,OACpB,EAAS,QAEX,EACJ,KAAK,WAAY,IAItB,EAAQ,MAAQ,EACb,EAAG,KAAM,CACR,EAAG,EAAG,IAAK,GACX,EAAQ,QAIZ,KAAM,GAAoB,KAAM,MAAK,IAAI,EAAgB,GAEzD,MAAO,GAAE,eAAe,EAAqB,EAC3C,CAAC,EAAG,IAAM,EAAE,QAAQ,EAAE,KAAK,WAAY,EAAE,KAAK,aAAa,SAAW,OAepE,KAAI,EAAgB,EAAsB,EAAS,CACvD,EAAU,GAAW,GAErB,KAAM,GAAY,KAAK,UACjB,EAAY,KAAK,UACjB,EAAa,KAAK,WAClB,EAAoB,KAAK,kBAE/B,AAAI,IAAyB,KAC3B,EAAuB,GAEvB,EAAuB,KAAK,gBAAgB,GAE9C,KAAM,GAAQ,IACX,GAAa,EAAe,IAAI,IAC9B,KAAK,QAAQ,OAGZ,EAAqB,KAAe,CACxC,KAAM,GAAuB,GACvB,EAAW,GACX,EAAoB,EAAQ,SAAW,GAEvC,EAAsB,EAAqB,OAAO,GACtD,CAAC,EAAY,KAAK,GAAc,EAAW,KAAuB,EAAI,IAAI,KAG5E,SAAW,KAAc,GAAa,CACpC,KAAM,GAAS,EAAqB,KAAK,GAAO,EAAW,KAAuB,EAAI,IAAI,IAE1F,GAAI,CAAC,EACH,EAAqB,KAAK,OACrB,CACL,GAAI,GAAoB,EAAO,KAAK,QAAQ,MAAM,MAElD,AAAI,YAA6B,MAAK,QAAQ,OAC5C,GAAoB,IAGtB,KAAM,GAAa,OAAK,GAAsB,GAE9C,AAAI,OAAO,KAAK,GAAY,QAC1B,EAAS,KACP,KAAK,QAAQ,MAAM,OAAO,EAAY,OAAO,OAAO,EAAS,CAC3D,MAAO,EACJ,GAAa,EAAe,IAAI,IAChC,GAAoB,EAAO,IAAI,SAsB5C,GAbI,EAAqB,OAAS,GAChC,EAAS,KACP,KAAK,QAAQ,MAAM,QAAQ,OACtB,GADsB,CAEzB,MAAO,IACJ,GAAa,EAAe,IAAI,IAChC,GAAoB,EAAqB,IAAI,GAAuB,EAAoB,KACtF,KAAK,QAAQ,WAMpB,EAAoB,OAAS,EAAG,CAClC,KAAM,GAAO,EAAoB,IAAI,GAC5B,WACF,GACA,EAAmB,KAAK,QAAQ,MAAM,OAFpC,EAGJ,GAAa,EAAe,IAAI,IAChC,GAAoB,EAAmB,IAAI,KACzC,KAAK,QAAQ,QAIpB,EAAS,KAAK,KAAK,QAAQ,MAAM,WAAW,EAAM,GAAE,SAAU,IAAS,KAGzE,MAAO,SAAQ,IAAI,IAhEM,sBAmE3B,GAAI,CACF,KAAM,GAAc,KAAM,MAAK,QAAQ,MAAM,QAAQ,OAAK,GAAL,CAAc,QAAO,IAAK,MAC/E,MAAO,MAAM,GAAmB,SACzB,EAAP,CACA,GAAI,YAAiB,GAAkB,MAAO,GAAmB,IACjE,KAAM,SAgBJ,KAAI,EAAgB,EAAc,EAAS,CAE/C,GAAI,CAAC,EAAc,MAAO,SAAQ,UAElC,EAAU,KAAK,GAEf,KAAM,GAAc,KACd,EAAY,EAAY,UACxB,EAAY,EAAY,UACxB,EAAa,EAAY,WACzB,EAAoB,EAAY,kBAChC,EAAoB,EAAQ,SAAW,GAE7C,EAAe,EAAY,gBAAgB,GAE3C,KAAM,GAAQ,IACX,GAAa,EAAe,IAAI,IAChC,GAAoB,EAAa,IAAI,GAAe,EAAY,IAAI,KAClE,EAAY,QAAQ,OAGnB,EAAqB,KAAe,CACxC,KAAM,GAAW,GACX,EAAsB,GACtB,EAAsB,GAC5B,SAAW,KAAO,GAAc,CAC9B,KAAM,GAAsB,GAAe,EAAY,KAAK,GAAW,EAAQ,KAAuB,EAAI,IAAI,IAE9G,GAAI,CAAC,EACH,EAAoB,KAAK,OACpB,CACL,KAAM,GAAoB,EAAI,EAAY,QAAQ,MAAM,MAClD,EAAa,OAAK,GAAsB,GAE9C,AAAI,OAAO,KAAK,GAAY,KAAK,GAAa,EAAW,KAAe,EAAoB,KAC1F,EAAoB,KAAK,IAK/B,GAAI,EAAoB,OAAS,EAAG,CAClC,KAAM,GAAO,EAAoB,IAAI,GAAsB,CACzD,KAAM,GAAoB,EAAmB,EAAY,QAAQ,MAAM,MACjE,EAAa,OAAK,GAAsB,GAE9C,SAAW,GAAc,EAAe,IAAI,GAC5C,EAAW,GAAqB,EAAmB,IAAI,GAEvD,OAAO,OAAO,EAAY,EAAY,QAAQ,OAEvC,IAGT,EAAS,KAAK,EAAY,QAAQ,MAAM,WAAW,EAAM,GAAE,SAAU,IAAS,KAGhF,SAAW,KAAS,GAAqB,CACvC,GAAI,GAAoB,EAAM,EAAY,QAAQ,MAAM,MACxD,KAAM,GAAa,OAAK,GAAsB,GAE9C,AAAI,YAA6B,GAAY,QAAQ,OACnD,GAAoB,IAGtB,EAAS,KAAK,EAAY,QAAQ,MAAM,OAAO,EAAY,OAAO,OAAO,EAAS,CAAE,MAAO,EACxF,GAAa,EAAe,IAAI,IAChC,GAAoB,EAAM,IAAI,QAInC,MAAO,SAAQ,IAAI,IAjDM,sBAoD3B,GAAI,CACF,KAAM,GAAc,KAAM,GAAY,QAAQ,MAAM,QAAQ,OAAK,GAAL,CAAc,QAAO,IAAK,MAChF,CAAC,GAAgB,KAAM,GAAmB,GAChD,MAAO,SACA,EAAP,CACA,GAAI,YAAiB,GAAkB,MAAO,KAC9C,KAAM,IAaV,OAAO,EAAgB,EAAsB,EAAS,CACpD,KAAM,GAAc,KAEpB,EAAU,GAAW,GAErB,EAAuB,EAAY,gBAAgB,GAEnD,KAAM,GAAQ,EACX,EAAY,YAAa,EAAe,IAAI,EAAY,YACxD,EAAY,mBAAoB,EAAqB,IAAI,GAAe,EAAY,IAAI,EAAY,aAGvG,MAAO,GAAY,QAAQ,MAAM,QAAQ,OAAK,GAAL,CAAc,gBAanD,QAAO,EAAgB,EAAQ,EAAS,CAC5C,KAAM,GAAc,KAEpB,EAAU,GAAW,GACrB,EAAS,GAAU,GAEf,MAAM,QAAQ,IAChB,GAAU,CACR,OAAQ,IAIR,EAAY,OACd,QAAO,OAAO,EAAQ,EAAY,OAC9B,EAAQ,QACV,GAAQ,OAAS,EAAQ,OAAO,OAAO,OAAO,KAAK,EAAY,UAKnE,KAAM,GAAsB,KAAM,GAAY,OAAO,OAAO,EAAQ,GAEpE,YAAM,GAAe,EAAY,UAAU,KAAK,EAAqB,EAAE,KAAK,EAAS,CAAC,YAC/E,EAGT,uBAAuB,EAAO,CAC5B,MAAI,OAAO,IAAU,SACZ,KAAK,KAAO,EAGjB,GAAS,EAAM,OACV,KAAK,KAAO,EAAM,OAGpB,CAAC,KAAK,WAvvBjB,qBA2vBA,OAAO,QAAU,EACjB,OAAO,QAAQ,cAAgB,EAC/B,OAAO,QAAQ,QAAU",
  "names": []
}
