{
  "version": 3,
  "sources": ["../../../../lib/dialects/mysql/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst util = require('util');\nconst Op = require('../../operators');\n\n\nconst JSON_FUNCTION_REGEX = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\nconst JSON_OPERATOR_REGEX = /^\\s*(->>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\nconst TOKEN_CAPTURE_REGEX = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\nconst FOREIGN_KEY_FIELDS = [\n  'CONSTRAINT_NAME as constraint_name',\n  'CONSTRAINT_NAME as constraintName',\n  'CONSTRAINT_SCHEMA as constraintSchema',\n  'CONSTRAINT_SCHEMA as constraintCatalog',\n  'TABLE_NAME as tableName',\n  'TABLE_SCHEMA as tableSchema',\n  'TABLE_SCHEMA as tableCatalog',\n  'COLUMN_NAME as columnName',\n  'REFERENCED_TABLE_SCHEMA as referencedTableSchema',\n  'REFERENCED_TABLE_SCHEMA as referencedTableCatalog',\n  'REFERENCED_TABLE_NAME as referencedTableName',\n  'REFERENCED_COLUMN_NAME as referencedColumnName'\n].join(',');\n\nconst typeWithoutDefault = new Set(['BLOB', 'TEXT', 'GEOMETRY', 'JSON']);\n\nclass MySQLQueryGenerator extends AbstractQueryGenerator {\n  constructor(options) {\n    super(options);\n\n    this.OperatorMap = {\n      ...this.OperatorMap,\n      [Op.regexp]: 'REGEXP',\n      [Op.notRegexp]: 'NOT REGEXP'\n    };\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = {\n      charset: null,\n      collate: null,\n      ...options\n    };\n\n    return Utils.joinSQLFragments([\n      'CREATE DATABASE IF NOT EXISTS',\n      this.quoteIdentifier(databaseName),\n      options.charset && `DEFAULT CHARACTER SET ${this.escape(options.charset)}`,\n      options.collate && `DEFAULT COLLATE ${this.escape(options.collate)}`,\n      ';'\n    ]);\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteIdentifier(databaseName)};`;\n  }\n\n  createSchema() {\n    return 'SHOW TABLES';\n  }\n\n  showSchemasQuery() {\n    return 'SHOW TABLES';\n  }\n\n  versionQuery() {\n    return 'SELECT VERSION() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = {\n      engine: 'InnoDB',\n      charset: null,\n      rowFormat: null,\n      ...options\n    };\n\n    const primaryKeys = [];\n    const foreignKeys = {};\n    const attrStr = [];\n\n    for (const attr in attributes) {\n      if (!Object.prototype.hasOwnProperty.call(attributes, attr)) continue;\n      const dataType = attributes[attr];\n      let match;\n\n      if (dataType.includes('PRIMARY KEY')) {\n        primaryKeys.push(attr);\n\n        if (dataType.includes('REFERENCES')) {\n          // MySQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attrStr.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attrStr.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n        }\n      } else if (dataType.includes('REFERENCES')) {\n        // MySQL doesn't support inline REFERENCES declarations: move to the end\n        match = dataType.match(/^(.+) (REFERENCES.*)$/);\n        attrStr.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n        foreignKeys[attr] = match[2];\n      } else {\n        attrStr.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attributesClause = attrStr.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClause += `, UNIQUE ${this.quoteIdentifier(indexName)} (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pkString})`;\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClause += `, FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`;\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'CREATE TABLE IF NOT EXISTS',\n      table,\n      `(${attributesClause})`,\n      `ENGINE=${options.engine}`,\n      options.comment && typeof options.comment === 'string' && `COMMENT ${this.escape(options.comment)}`,\n      options.charset && `DEFAULT CHARSET=${options.charset}`,\n      options.collate && `COLLATE ${options.collate}`,\n      options.initialAutoIncrement && `AUTO_INCREMENT=${options.initialAutoIncrement}`,\n      options.rowFormat && `ROW_FORMAT=${options.rowFormat}`,\n      ';'\n    ]);\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = this.quoteTable(\n      this.addSchema({\n        tableName,\n        _schema: schema,\n        _schemaDelimiter: schemaDelimiter\n      })\n    );\n\n    return `SHOW FULL COLUMNS FROM ${table};`;\n  }\n\n  showTablesQuery(database) {\n    let query = 'SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = \\'BASE TABLE\\'';\n    if (database) {\n      query += ` AND TABLE_SCHEMA = ${this.escape(database)}`;\n    } else {\n      query += ' AND TABLE_SCHEMA NOT IN (\\'MYSQL\\', \\'INFORMATION_SCHEMA\\', \\'PERFORMANCE_SCHEMA\\', \\'SYS\\')';\n    }\n    return `${query};`;\n  }\n\n  addColumnQuery(table, key, dataType) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, {\n        context: 'addColumn',\n        tableName: table,\n        foreignKey: key\n      }),\n      ';'\n    ]);\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [];\n    const constraintString = [];\n\n    for (const attributeName in attributes) {\n      let definition = attributes[attributeName];\n      if (definition.includes('REFERENCES')) {\n        const attrName = this.quoteIdentifier(attributeName);\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        constraintString.push(`FOREIGN KEY (${attrName}) ${definition}`);\n      } else {\n        attrString.push(`\\`${attributeName}\\` \\`${attributeName}\\` ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `CHANGE ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';'\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attrName in attributes) {\n      const definition = attributes[attrName];\n      attrString.push(`\\`${attrBefore}\\` \\`${attrName}\\` ${definition}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'CHANGE',\n      attrString.join(', '),\n      ';'\n    ]);\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the sqlite json functions\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    } else if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      } else if (smth.json && /boolean/i.test(smth.type)) {\n        // true or false cannot be casted as booleans within a JSON structure\n        smth.type = 'char';\n      } else if (/double precision/i.test(smth.type) || /boolean/i.test(smth.type) || /integer/i.test(smth.type)) {\n        smth.type = 'decimal';\n      } else if (/text/i.test(smth.type)) {\n        smth.type = 'char';\n      }\n    }\n\n    return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n  }\n\n  _toJSONValue(value) {\n    // true/false are stored as strings in mysql\n    if (typeof value === 'boolean') {\n      return value.toString();\n    }\n    // null is stored as a string in mysql\n    if (value === null) {\n      return 'null';\n    }\n    return value;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    let limit = '';\n    let query = `DELETE FROM ${this.quoteTable(tableName)}`;\n\n    if (options.limit) {\n      limit = ` LIMIT ${this.escape(options.limit)}`;\n    }\n\n    where = this.getWhereConditions(where, null, model, options);\n\n    if (where) {\n      query += ` WHERE ${where}`;\n    }\n\n    return query + limit;\n  }\n\n  showIndexesQuery(tableName, options) {\n    return Utils.joinSQLFragments([\n      `SHOW INDEX FROM ${this.quoteTable(tableName)}`,\n      options && options.database && `FROM \\`${options.database}\\``\n    ]);\n  }\n\n  showConstraintsQuery(table, constraintName) {\n    const tableName = table.tableName || table;\n    const schemaName = table.schema;\n\n    return Utils.joinSQLFragments([\n      'SELECT CONSTRAINT_CATALOG AS constraintCatalog,',\n      'CONSTRAINT_NAME AS constraintName,',\n      'CONSTRAINT_SCHEMA AS constraintSchema,',\n      'CONSTRAINT_TYPE AS constraintType,',\n      'TABLE_NAME AS tableName,',\n      'TABLE_SCHEMA AS tableSchema',\n      'from INFORMATION_SCHEMA.TABLE_CONSTRAINTS',\n      `WHERE table_name='${tableName}'`,\n      constraintName && `AND constraint_name = '${constraintName}'`,\n      schemaName && `AND TABLE_SCHEMA = '${schemaName}'`,\n      ';'\n    ]);\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return Utils.joinSQLFragments([\n      'DROP INDEX',\n      this.quoteIdentifier(indexName),\n      'ON',\n      this.quoteTable(tableName)\n    ]);\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    const attributeString = attribute.type.toString({ escape: this.escape.bind(this) });\n    let template = attributeString;\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' auto_increment';\n    }\n\n    // BLOB/TEXT/GEOMETRY/JSON cannot have a default value\n    if (!typeWithoutDefault.has(attributeString)\n      && attribute.type._binary !== true\n      && Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.comment) {\n      template += ` COMMENT ${this.escape(attribute.comment)}`;\n    }\n\n    if (attribute.first) {\n      template += ' FIRST';\n    }\n    if (attribute.after) {\n      template += ` AFTER ${this.quoteIdentifier(attribute.after)}`;\n    }\n\n    if (attribute.references) {\n      if (options && options.context === 'addColumn' && options.foreignKey) {\n        const attrName = this.quoteIdentifier(options.foreignKey);\n        const fkName = this.quoteIdentifier(`${options.tableName}_${attrName}_foreign_idx`);\n\n        template += `, ADD CONSTRAINT ${fkName} FOREIGN KEY (${attrName})`;\n      }\n\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   * @private\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = JSON_FUNCTION_REGEX.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = JSON_OPERATOR_REGEX.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = TOKEN_CAPTURE_REGEX.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    if (hasJsonFunction && (hasInvalidToken || openingBrackets !== closingBrackets)) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} schemaName The name of the schema.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(table, schemaName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      `FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE where TABLE_NAME = '${tableName}'`,\n      `AND CONSTRAINT_NAME!='PRIMARY' AND CONSTRAINT_SCHEMA='${schemaName}'`,\n      'AND REFERENCED_TABLE_NAME IS NOT NULL',\n      ';'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that returns the foreign key constraint of a given column.\n   *\n   * @param  {object} table  The table.\n   * @param  {string} columnName The name of the column.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeyQuery(table, columnName) {\n    const quotedSchemaName = table.schema ? wrapSingleQuote(table.schema) : '';\n    const quotedTableName = wrapSingleQuote(table.tableName || table);\n    const quotedColumnName = wrapSingleQuote(columnName);\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      FOREIGN_KEY_FIELDS,\n      'FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE',\n      'WHERE (',\n      [\n        `REFERENCED_TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND REFERENCED_TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND REFERENCED_COLUMN_NAME = ${quotedColumnName}`\n      ],\n      ') OR (',\n      [\n        `TABLE_NAME = ${quotedTableName}`,\n        table.schema && `AND TABLE_SCHEMA = ${quotedSchemaName}`,\n        `AND COLUMN_NAME = ${quotedColumnName}`,\n        'AND REFERENCED_TABLE_NAME IS NOT NULL'\n      ],\n      ')'\n    ]);\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP FOREIGN KEY',\n      this.quoteIdentifier(foreignKey),\n      ';'\n    ]);\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(identifier, '\\'');\n}\n\nmodule.exports = MySQLQueryGenerator;\n"],
  "mappings": "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",
  "names": []
}
