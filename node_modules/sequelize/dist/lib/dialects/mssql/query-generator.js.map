{
  "version": 3,
  "sources": ["../../../../lib/dialects/mssql/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst DataTypes = require('../../data-types');\nconst TableHints = require('../../table-hints');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst randomBytes = require('crypto').randomBytes;\nconst semver = require('semver');\nconst Op = require('../../operators');\n\n/* istanbul ignore next */\nconst throwMethodUndefined = function(methodName) {\n  throw new Error(`The method \"${methodName}\" is not defined! Please add it to your sql dialect.`);\n};\n\nclass MSSQLQueryGenerator extends AbstractQueryGenerator {\n  createDatabaseQuery(databaseName, options) {\n    options = { collate: null, ...options };\n\n    const collation = options.collate ? `COLLATE ${this.escape(options.collate)}` : '';\n\n    return [\n      'IF NOT EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'CREATE DATABASE', this.quoteIdentifier(databaseName),\n      `${collation};`,\n      'END;'\n    ].join(' ');\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return [\n      'IF EXISTS (SELECT * FROM sys.databases WHERE name =', wrapSingleQuote(databaseName), ')',\n      'BEGIN',\n      'DROP DATABASE', this.quoteIdentifier(databaseName), ';',\n      'END;'\n    ].join(' ');\n  }\n\n  createSchema(schema) {\n    return [\n      'IF NOT EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', wrapSingleQuote(schema), ')',\n      'BEGIN',\n      \"EXEC sp_executesql N'CREATE SCHEMA\",\n      this.quoteIdentifier(schema),\n      \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  dropSchema(schema) {\n    // Mimics Postgres CASCADE, will drop objects belonging to the schema\n    const quotedSchema = wrapSingleQuote(schema);\n    return [\n      'IF EXISTS (SELECT schema_name',\n      'FROM information_schema.schemata',\n      'WHERE schema_name =', quotedSchema, ')',\n      'BEGIN',\n      'DECLARE @id INT, @ms_sql NVARCHAR(2000);',\n      'DECLARE @cascade TABLE (',\n      'id INT NOT NULL IDENTITY PRIMARY KEY,',\n      'ms_sql NVARCHAR(2000) NOT NULL );',\n      'INSERT INTO @cascade ( ms_sql )',\n      \"SELECT CASE WHEN o.type IN ('F','PK')\",\n      \"THEN N'ALTER TABLE ['+ s.name + N'].[' + p.name + N'] DROP CONSTRAINT [' + o.name + N']'\",\n      \"ELSE N'DROP TABLE ['+ s.name + N'].[' + o.name + N']' END\",\n      'FROM sys.objects o',\n      'JOIN sys.schemas s on o.schema_id = s.schema_id',\n      'LEFT OUTER JOIN sys.objects p on o.parent_object_id = p.object_id',\n      \"WHERE o.type IN ('F', 'PK', 'U') AND s.name = \", quotedSchema,\n      'ORDER BY o.type ASC;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'WHILE @id IS NOT NULL',\n      'BEGIN',\n      'BEGIN TRY EXEC sp_executesql @ms_sql; END TRY',\n      'BEGIN CATCH BREAK; THROW; END CATCH;',\n      'DELETE FROM @cascade WHERE id = @id;',\n      'SELECT @id = NULL, @ms_sql = NULL;',\n      'SELECT TOP 1 @id = id, @ms_sql = ms_sql FROM @cascade ORDER BY id;',\n      'END',\n      \"EXEC sp_executesql N'DROP SCHEMA\", this.quoteIdentifier(schema), \";'\",\n      'END;'\n    ].join(' ');\n  }\n\n  showSchemasQuery() {\n    return [\n      'SELECT \"name\" as \"schema_name\" FROM sys.schemas as s',\n      'WHERE \"s\".\"name\" NOT IN (',\n      \"'INFORMATION_SCHEMA', 'dbo', 'guest', 'sys', 'archive'\",\n      ')', 'AND', '\"s\".\"name\" NOT LIKE', \"'db_%'\"\n    ].join(' ');\n  }\n\n  versionQuery() {\n    // Uses string manipulation to convert the MS Maj.Min.Patch.Build to semver Maj.Min.Patch\n    return [\n      'DECLARE @ms_ver NVARCHAR(20);',\n      \"SET @ms_ver = REVERSE(CONVERT(NVARCHAR(20), SERVERPROPERTY('ProductVersion')));\",\n      \"SELECT REVERSE(SUBSTRING(@ms_ver, CHARINDEX('.', @ms_ver)+1, 20)) AS 'version'\"\n    ].join(' ');\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    const primaryKeys = [],\n      foreignKeys = {},\n      attributesClauseParts = [];\n\n    let commentStr = '';\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        let dataType = attributes[attr];\n        let match;\n\n        if (dataType.includes('COMMENT ')) {\n          const commentMatch = dataType.match(/^(.+) (COMMENT.*)$/);\n          const commentText = commentMatch[2].replace('COMMENT', '').trim();\n          commentStr += this.commentTemplate(commentText, tableName, attr);\n          // remove comment related substring from dataType\n          dataType = commentMatch[1];\n        }\n\n        if (dataType.includes('PRIMARY KEY')) {\n          primaryKeys.push(attr);\n\n          if (dataType.includes('REFERENCES')) {\n            // MSSQL doesn't support inline REFERENCES declarations: move to the end\n            match = dataType.match(/^(.+) (REFERENCES.*)$/);\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1].replace('PRIMARY KEY', '')}`);\n            foreignKeys[attr] = match[2];\n          } else {\n            attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType.replace('PRIMARY KEY', '')}`);\n          }\n        } else if (dataType.includes('REFERENCES')) {\n          // MSSQL doesn't support inline REFERENCES declarations: move to the end\n          match = dataType.match(/^(.+) (REFERENCES.*)$/);\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${match[1]}`);\n          foreignKeys[attr] = match[2];\n        } else {\n          attributesClauseParts.push(`${this.quoteIdentifier(attr)} ${dataType}`);\n        }\n      }\n    }\n\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, (columns, indexName) => {\n        if (columns.customIndex) {\n          if (typeof indexName !== 'string') {\n            indexName = `uniq_${tableName}_${columns.fields.join('_')}`;\n          }\n          attributesClauseParts.push(`CONSTRAINT ${\n            this.quoteIdentifier(indexName)\n          } UNIQUE (${\n            columns.fields.map(field => this.quoteIdentifier(field)).join(', ')\n          })`);\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attributesClauseParts.push(`PRIMARY KEY (${pkString})`);\n    }\n\n    for (const fkey in foreignKeys) {\n      if (Object.prototype.hasOwnProperty.call(foreignKeys, fkey)) {\n        attributesClauseParts.push(`FOREIGN KEY (${this.quoteIdentifier(fkey)}) ${foreignKeys[fkey]}`);\n      }\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quotedTableName}', 'U') IS NULL`,\n      `CREATE TABLE ${quotedTableName} (${attributesClauseParts.join(', ')})`,\n      ';',\n      commentStr\n    ]);\n  }\n\n  describeTableQuery(tableName, schema) {\n    let sql = [\n      'SELECT',\n      \"c.COLUMN_NAME AS 'Name',\",\n      \"c.DATA_TYPE AS 'Type',\",\n      \"c.CHARACTER_MAXIMUM_LENGTH AS 'Length',\",\n      \"c.IS_NULLABLE as 'IsNull',\",\n      \"COLUMN_DEFAULT AS 'Default',\",\n      \"pk.CONSTRAINT_TYPE AS 'Constraint',\",\n      \"COLUMNPROPERTY(OBJECT_ID(c.TABLE_SCHEMA+'.'+c.TABLE_NAME), c.COLUMN_NAME, 'IsIdentity') as 'IsIdentity',\",\n      \"CAST(prop.value AS NVARCHAR) AS 'Comment'\",\n      'FROM',\n      'INFORMATION_SCHEMA.TABLES t',\n      'INNER JOIN',\n      'INFORMATION_SCHEMA.COLUMNS c ON t.TABLE_NAME = c.TABLE_NAME AND t.TABLE_SCHEMA = c.TABLE_SCHEMA',\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ',\n      'cu.column_name, tc.CONSTRAINT_TYPE ',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS tc ',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE  cu ',\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ',\n      'and tc.constraint_name=cu.constraint_name ',\n      'and tc.CONSTRAINT_TYPE=\\'PRIMARY KEY\\') pk ',\n      'ON pk.table_schema=c.table_schema ',\n      'AND pk.table_name=c.table_name ',\n      'AND pk.column_name=c.column_name ',\n      'INNER JOIN sys.columns AS sc',\n      \"ON sc.object_id = object_id(t.table_schema + '.' + t.table_name) AND sc.name = c.column_name\",\n      'LEFT JOIN sys.extended_properties prop ON prop.major_id = sc.object_id',\n      'AND prop.minor_id = sc.column_id',\n      \"AND prop.name = 'MS_Description'\",\n      'WHERE t.TABLE_NAME =', wrapSingleQuote(tableName)\n    ].join(' ');\n\n    if (schema) {\n      sql += `AND t.TABLE_SCHEMA =${wrapSingleQuote(schema)}`;\n    }\n\n    return sql;\n  }\n\n  renameTableQuery(before, after) {\n    return `EXEC sp_rename ${this.quoteTable(before)}, ${this.quoteTable(after)};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT TABLE_NAME, TABLE_SCHEMA FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_TYPE = 'BASE TABLE';\";\n  }\n\n  dropTableQuery(tableName) {\n    const quoteTbl = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      `IF OBJECT_ID('${quoteTbl}', 'U') IS NOT NULL`,\n      'DROP TABLE',\n      quoteTbl,\n      ';'\n    ]);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    // FIXME: attributeToSQL SHOULD be using attributes in addColumnQuery\n    //        but instead we need to pass the key along as the field here\n    dataType.field = key;\n    let commentStr = '';\n\n    if (dataType.comment && _.isString(dataType.comment)) {\n      commentStr = this.commentTemplate(dataType.comment, table, key);\n      // attributeToSQL will try to include `COMMENT 'Comment Text'` when it returns if the comment key\n      // is present. This is needed for createTable statement where that part is extracted with regex.\n      // Here we can intercept the object and remove comment property since we have the original object.\n      delete dataType['comment'];\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(table),\n      'ADD',\n      this.quoteIdentifier(key),\n      this.attributeToSQL(dataType, { context: 'addColumn' }),\n      ';',\n      commentStr\n    ]);\n  }\n\n  commentTemplate(comment, table, column) {\n    return ' EXEC sp_addextendedproperty ' +\n        `@name = N'MS_Description', @value = ${this.escape(comment)}, ` +\n        '@level0type = N\\'Schema\\', @level0name = \\'dbo\\', ' +\n        `@level1type = N'Table', @level1name = ${this.quoteIdentifier(table)}, ` +\n        `@level2type = N'Column', @level2name = ${this.quoteIdentifier(column)};`;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP COLUMN',\n      this.quoteIdentifier(attributeName),\n      ';'\n    ]);\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const attrString = [],\n      constraintString = [];\n    let commentString = '';\n\n    for (const attributeName in attributes) {\n      const quotedAttrName = this.quoteIdentifier(attributeName);\n      let definition = attributes[attributeName];\n      if (definition.includes('COMMENT ')) {\n        const commentMatch = definition.match(/^(.+) (COMMENT.*)$/);\n        const commentText = commentMatch[2].replace('COMMENT', '').trim();\n        commentString += this.commentTemplate(commentText, tableName, attributeName);\n        // remove comment related substring from dataType\n        definition = commentMatch[1];\n      }\n      if (definition.includes('REFERENCES')) {\n        constraintString.push(`FOREIGN KEY (${quotedAttrName}) ${definition.replace(/.+?(?=REFERENCES)/, '')}`);\n      } else {\n        attrString.push(`${quotedAttrName} ${definition}`);\n      }\n    }\n\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      attrString.length && `ALTER COLUMN ${attrString.join(', ')}`,\n      constraintString.length && `ADD ${constraintString.join(', ')}`,\n      ';',\n      commentString\n    ]);\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const newName = Object.keys(attributes)[0];\n    return Utils.joinSQLFragments([\n      'EXEC sp_rename',\n      `'${this.quoteTable(tableName)}.${attrBefore}',`,\n      `'${newName}',`,\n      \"'COLUMN'\",\n      ';'\n    ]);\n  }\n\n  bulkInsertQuery(tableName, attrValueHashes, options, attributes) {\n    const quotedTable = this.quoteTable(tableName);\n    options = options || {};\n    attributes = attributes || {};\n\n    const tuples = [];\n    const allAttributes = [];\n    const allQueries = [];\n\n    let needIdentityInsertWrapper = false,\n      outputFragment = '';\n\n    if (options.returning) {\n      const returnValues = this.generateReturnValues(attributes, options);\n\n      outputFragment = returnValues.outputFragment;\n    }\n\n    const emptyQuery = `INSERT INTO ${quotedTable}${outputFragment} DEFAULT VALUES`;\n\n    attrValueHashes.forEach(attrValueHash => {\n      // special case for empty objects with primary keys\n      const fields = Object.keys(attrValueHash);\n      const firstAttr = attributes[fields[0]];\n      if (fields.length === 1 && firstAttr && firstAttr.autoIncrement && attrValueHash[fields[0]] === null) {\n        allQueries.push(emptyQuery);\n        return;\n      }\n\n      // normal case\n      _.forOwn(attrValueHash, (value, key) => {\n        if (value !== null && attributes[key] && attributes[key].autoIncrement) {\n          needIdentityInsertWrapper = true;\n        }\n\n        if (!allAttributes.includes(key)) {\n          if (value === null && attributes[key] && attributes[key].autoIncrement)\n            return;\n\n          allAttributes.push(key);\n        }\n      });\n    });\n\n    if (allAttributes.length > 0) {\n      attrValueHashes.forEach(attrValueHash => {\n        tuples.push(`(${\n          allAttributes.map(key =>\n            this.escape(attrValueHash[key])).join(',')\n        })`);\n      });\n\n      const quotedAttributes = allAttributes.map(attr => this.quoteIdentifier(attr)).join(',');\n      allQueries.push(tupleStr => `INSERT INTO ${quotedTable} (${quotedAttributes})${outputFragment} VALUES ${tupleStr};`);\n    }\n    const commands = [];\n    let offset = 0;\n    const batch = Math.floor(250 / (allAttributes.length + 1)) + 1;\n    while (offset < Math.max(tuples.length, 1)) {\n      const tupleStr = tuples.slice(offset, Math.min(tuples.length, offset + batch));\n      let generatedQuery = allQueries.map(v => typeof v === 'string' ? v : v(tupleStr)).join(';');\n      if (needIdentityInsertWrapper) {\n        generatedQuery = `SET IDENTITY_INSERT ${quotedTable} ON; ${generatedQuery}; SET IDENTITY_INSERT ${quotedTable} OFF;`;\n      }\n      commands.push(generatedQuery);\n      offset += batch;\n    }\n    return commands.join(';');\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    const sql = super.updateQuery(tableName, attrValueHash, where, options, attributes);\n    if (options.limit) {\n      const updateArgs = `UPDATE TOP(${this.escape(options.limit)})`;\n      sql.query = sql.query.replace('UPDATE', updateArgs);\n    }\n    return sql;\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model) {\n    const targetTableAlias = this.quoteTable(`${tableName}_target`);\n    const sourceTableAlias = this.quoteTable(`${tableName}_source`);\n    const primaryKeysAttrs = [];\n    const identityAttrs = [];\n    const uniqueAttrs = [];\n    const tableNameQuoted = this.quoteTable(tableName);\n    let needIdentityInsertWrapper = false;\n\n    //Obtain primaryKeys, uniquekeys and identity attrs from rawAttributes as model is not passed\n    for (const key in model.rawAttributes) {\n      if (model.rawAttributes[key].primaryKey) {\n        primaryKeysAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].unique) {\n        uniqueAttrs.push(model.rawAttributes[key].field || key);\n      }\n      if (model.rawAttributes[key].autoIncrement) {\n        identityAttrs.push(model.rawAttributes[key].field || key);\n      }\n    }\n\n    //Add unique indexes defined by indexes option to uniqueAttrs\n    for (const index of model._indexes) {\n      if (index.unique && index.fields) {\n        for (const field of index.fields) {\n          const fieldName = typeof field === 'string' ? field : field.name || field.attribute;\n          if (!uniqueAttrs.includes(fieldName) && model.rawAttributes[fieldName]) {\n            uniqueAttrs.push(fieldName);\n          }\n        }\n      }\n    }\n\n    const updateKeys = Object.keys(updateValues);\n    const insertKeys = Object.keys(insertValues);\n    const insertKeysQuoted = insertKeys.map(key => this.quoteIdentifier(key)).join(', ');\n    const insertValuesEscaped = insertKeys.map(key => this.escape(insertValues[key])).join(', ');\n    const sourceTableQuery = `VALUES(${insertValuesEscaped})`; //Virtual Table\n    let joinCondition;\n\n    //IDENTITY_INSERT Condition\n    identityAttrs.forEach(key => {\n      if (updateValues[key] && updateValues[key] !== null) {\n        needIdentityInsertWrapper = true;\n        /*\n         * IDENTITY_INSERT Column Cannot be updated, only inserted\n         * http://stackoverflow.com/a/30176254/2254360\n         */\n      }\n    });\n\n    //Filter NULL Clauses\n    const clauses = where[Op.or].filter(clause => {\n      let valid = true;\n      /*\n       * Exclude NULL Composite PK/UK. Partial Composite clauses should also be excluded as it doesn't guarantee a single row\n       */\n      for (const key in clause) {\n        if (typeof clause[key] === 'undefined' || clause[key] == null) {\n          valid = false;\n          break;\n        }\n      }\n      return valid;\n    });\n\n    /*\n     * Generate ON condition using PK(s).\n     * If not, generate using UK(s). Else throw error\n     */\n    const getJoinSnippet = array => {\n      return array.map(key => {\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${sourceTableAlias}.${key}`;\n      });\n    };\n\n    if (clauses.length === 0) {\n      throw new Error('Primary Key or Unique key should be passed to upsert query');\n    } else {\n      // Search for primary key attribute in clauses -- Model can have two separate unique keys\n      for (const key in clauses) {\n        const keys = Object.keys(clauses[key]);\n        if (primaryKeysAttrs.includes(keys[0])) {\n          joinCondition = getJoinSnippet(primaryKeysAttrs).join(' AND ');\n          break;\n        }\n      }\n      if (!joinCondition) {\n        joinCondition = getJoinSnippet(uniqueAttrs).join(' AND ');\n      }\n    }\n\n    // Remove the IDENTITY_INSERT Column from update\n    const updateSnippet = updateKeys.filter(key => !identityAttrs.includes(key))\n      .map(key => {\n        const value = this.escape(updateValues[key]);\n        key = this.quoteIdentifier(key);\n        return `${targetTableAlias}.${key} = ${value}`;\n      }).join(', ');\n\n    const insertSnippet = `(${insertKeysQuoted}) VALUES(${insertValuesEscaped})`;\n    let query = `MERGE INTO ${tableNameQuoted} WITH(HOLDLOCK) AS ${targetTableAlias} USING (${sourceTableQuery}) AS ${sourceTableAlias}(${insertKeysQuoted}) ON ${joinCondition}`;\n    query += ` WHEN MATCHED THEN UPDATE SET ${updateSnippet} WHEN NOT MATCHED THEN INSERT ${insertSnippet} OUTPUT $action, INSERTED.*;`;\n    if (needIdentityInsertWrapper) {\n      query = `SET IDENTITY_INSERT ${tableNameQuoted} ON; ${query} SET IDENTITY_INSERT ${tableNameQuoted} OFF;`;\n    }\n    return query;\n  }\n\n  truncateTableQuery(tableName) {\n    return `TRUNCATE TABLE ${this.quoteTable(tableName)}`;\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    const whereClause = this.getWhereConditions(where, null, model, options);\n\n    return Utils.joinSQLFragments([\n      'DELETE',\n      options.limit && `TOP(${this.escape(options.limit)})`,\n      'FROM',\n      table,\n      whereClause && `WHERE ${whereClause}`,\n      ';',\n      'SELECT @@ROWCOUNT AS AFFECTEDROWS',\n      ';'\n    ]);\n  }\n\n  showIndexesQuery(tableName) {\n    return `EXEC sys.sp_helpindex @objname = N'${this.quoteTable(tableName)}';`;\n  }\n\n  showConstraintsQuery(tableName) {\n    return `EXEC sp_helpconstraint @objname = ${this.escape(this.quoteTable(tableName))};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX ${this.quoteIdentifiers(indexName)} ON ${this.quoteIdentifiers(tableName)}`;\n  }\n\n  attributeToSQL(attribute) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    // handle self referential constraints\n    if (attribute.references) {\n\n      if (attribute.Model && attribute.Model.tableName === attribute.references.model) {\n        this.sequelize.log('MSSQL does not support self referencial constraints, '\n          + 'we will remove it but we recommend restructuring your query');\n        attribute.onDelete = '';\n        attribute.onUpdate = '';\n      }\n    }\n\n    let template;\n\n    if (attribute.type instanceof DataTypes.ENUM) {\n      if (attribute.type.values && !attribute.values) attribute.values = attribute.type.values;\n\n      // enums are a special case\n      template = attribute.type.toSql();\n      template += ` CHECK (${this.quoteIdentifier(attribute.field)} IN(${attribute.values.map(value => {\n        return this.escape(value);\n      }).join(', ') }))`;\n      return template;\n    }\n    template = attribute.type.toString();\n\n    if (attribute.allowNull === false) {\n      template += ' NOT NULL';\n    } else if (!attribute.primaryKey && !Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ' NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      template += ' IDENTITY(1,1)';\n    }\n\n    // Blobs/texts cannot have a defaultValue\n    if (attribute.type !== 'TEXT' && attribute.type._binary !== true &&\n        Utils.defaultValueSchemable(attribute.defaultValue)) {\n      template += ` DEFAULT ${this.escape(attribute.defaultValue)}`;\n    }\n\n    if (attribute.unique === true) {\n      template += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      template += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      template += ` REFERENCES ${this.quoteTable(attribute.references.model)}`;\n\n      if (attribute.references.key) {\n        template += ` (${this.quoteIdentifier(attribute.references.key)})`;\n      } else {\n        template += ` (${this.quoteIdentifier('id')})`;\n      }\n\n      if (attribute.onDelete) {\n        template += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        template += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      template += ` COMMENT ${attribute.comment}`;\n    }\n\n    return template;\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {},\n      existingConstraints = [];\n    let key,\n      attribute;\n\n    for (key in attributes) {\n      attribute = attributes[key];\n\n      if (attribute.references) {\n        if (existingConstraints.includes(attribute.references.model.toString())) {\n          // no cascading constraints to a table more than once\n          attribute.onDelete = '';\n          attribute.onUpdate = '';\n        } else {\n          existingConstraints.push(attribute.references.model.toString());\n\n          // NOTE: this really just disables cascading updates for all\n          //       definitions. Can be made more robust to support the\n          //       few cases where MSSQL actually supports them\n          attribute.onUpdate = '';\n        }\n\n      }\n\n      if (key && !attribute.field) attribute.field = key;\n      result[attribute.field || key] = this.attributeToSQL(attribute, options);\n    }\n\n    return result;\n  }\n\n  createTrigger() {\n    throwMethodUndefined('createTrigger');\n  }\n\n  dropTrigger() {\n    throwMethodUndefined('dropTrigger');\n  }\n\n  renameTrigger() {\n    throwMethodUndefined('renameTrigger');\n  }\n\n  createFunction() {\n    throwMethodUndefined('createFunction');\n  }\n\n  dropFunction() {\n    throwMethodUndefined('dropFunction');\n  }\n\n  renameFunction() {\n    throwMethodUndefined('renameFunction');\n  }\n\n  /**\n   * Generate common SQL prefix for ForeignKeysQuery.\n   *\n   * @param {string} catalogName\n   * @returns {string}\n   */\n  _getForeignKeysQueryPrefix(catalogName) {\n    return `${'SELECT ' +\n        'constraint_name = OBJ.NAME, ' +\n        'constraintName = OBJ.NAME, '}${\n      catalogName ? `constraintCatalog = '${catalogName}', ` : ''\n    }constraintSchema = SCHEMA_NAME(OBJ.SCHEMA_ID), ` +\n        'tableName = TB.NAME, ' +\n        `tableSchema = SCHEMA_NAME(TB.SCHEMA_ID), ${\n          catalogName ? `tableCatalog = '${catalogName}', ` : ''\n        }columnName = COL.NAME, ` +\n        `referencedTableSchema = SCHEMA_NAME(RTB.SCHEMA_ID), ${\n          catalogName ? `referencedCatalog = '${catalogName}', ` : ''\n        }referencedTableName = RTB.NAME, ` +\n        'referencedColumnName = RCOL.NAME ' +\n      'FROM sys.foreign_key_columns FKC ' +\n        'INNER JOIN sys.objects OBJ ON OBJ.OBJECT_ID = FKC.CONSTRAINT_OBJECT_ID ' +\n        'INNER JOIN sys.tables TB ON TB.OBJECT_ID = FKC.PARENT_OBJECT_ID ' +\n        'INNER JOIN sys.columns COL ON COL.COLUMN_ID = PARENT_COLUMN_ID AND COL.OBJECT_ID = TB.OBJECT_ID ' +\n        'INNER JOIN sys.tables RTB ON RTB.OBJECT_ID = FKC.REFERENCED_OBJECT_ID ' +\n        'INNER JOIN sys.columns RCOL ON RCOL.COLUMN_ID = REFERENCED_COLUMN_ID AND RCOL.OBJECT_ID = RTB.OBJECT_ID';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * @param {string|object} table\n   * @param {string} catalogName database name\n   * @returns {string}\n   */\n  getForeignKeysQuery(table, catalogName) {\n    const tableName = table.tableName || table;\n    let sql = `${this._getForeignKeysQueryPrefix(catalogName)\n    } WHERE TB.NAME =${wrapSingleQuote(tableName)}`;\n\n    if (table.schema) {\n      sql += ` AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`;\n    }\n    return sql;\n  }\n\n  getForeignKeyQuery(table, attributeName) {\n    const tableName = table.tableName || table;\n    return Utils.joinSQLFragments([\n      this._getForeignKeysQueryPrefix(),\n      'WHERE',\n      `TB.NAME =${wrapSingleQuote(tableName)}`,\n      'AND',\n      `COL.NAME =${wrapSingleQuote(attributeName)}`,\n      table.schema && `AND SCHEMA_NAME(TB.SCHEMA_ID) =${wrapSingleQuote(table.schema)}`\n    ]);\n  }\n\n  getPrimaryKeyConstraintQuery(table, attributeName) {\n    const tableName = wrapSingleQuote(table.tableName || table);\n    return Utils.joinSQLFragments([\n      'SELECT K.TABLE_NAME AS tableName,',\n      'K.COLUMN_NAME AS columnName,',\n      'K.CONSTRAINT_NAME AS constraintName',\n      'FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS C',\n      'JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K',\n      'ON C.TABLE_NAME = K.TABLE_NAME',\n      'AND C.CONSTRAINT_CATALOG = K.CONSTRAINT_CATALOG',\n      'AND C.CONSTRAINT_SCHEMA = K.CONSTRAINT_SCHEMA',\n      'AND C.CONSTRAINT_NAME = K.CONSTRAINT_NAME',\n      'WHERE C.CONSTRAINT_TYPE = \\'PRIMARY KEY\\'',\n      `AND K.COLUMN_NAME = ${wrapSingleQuote(attributeName)}`,\n      `AND K.TABLE_NAME = ${tableName}`,\n      ';'\n    ]);\n  }\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP',\n      this.quoteIdentifier(foreignKey)\n    ]);\n  }\n\n  getDefaultConstraintQuery(tableName, attributeName) {\n    const quotedTable = this.quoteTable(tableName);\n    return Utils.joinSQLFragments([\n      'SELECT name FROM sys.default_constraints',\n      `WHERE PARENT_OBJECT_ID = OBJECT_ID('${quotedTable}', 'U')`,\n      `AND PARENT_COLUMN_ID = (SELECT column_id FROM sys.columns WHERE NAME = ('${attributeName}')`,\n      `AND object_id = OBJECT_ID('${quotedTable}', 'U'))`,\n      ';'\n    ]);\n  }\n\n  dropConstraintQuery(tableName, constraintName) {\n    return Utils.joinSQLFragments([\n      'ALTER TABLE',\n      this.quoteTable(tableName),\n      'DROP CONSTRAINT',\n      this.quoteIdentifier(constraintName),\n      ';'\n    ]);\n  }\n\n  setIsolationLevelQuery() {\n\n  }\n\n  generateTransactionId() {\n    return randomBytes(10).toString('hex');\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVE TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'BEGIN TRANSACTION;';\n  }\n\n  commitTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return;\n    }\n\n    return 'COMMIT TRANSACTION;';\n  }\n\n  rollbackTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `ROLLBACK TRANSACTION ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return 'ROLLBACK TRANSACTION;';\n  }\n\n  selectFromTableFragment(options, model, attributes, tables, mainTableAs, where) {\n    this._throwOnEmptyAttributes(attributes, { modelName: model && model.name, as: mainTableAs });\n\n    const dbVersion = this.sequelize.options.databaseVersion;\n    const isSQLServer2008 = semver.valid(dbVersion) && semver.lt(dbVersion, '11.0.0');\n\n    if (isSQLServer2008 && options.offset) {\n      // For earlier versions of SQL server, we need to nest several queries\n      // in order to emulate the OFFSET behavior.\n      //\n      // 1. The outermost query selects all items from the inner query block.\n      //    This is due to a limitation in SQL server with the use of computed\n      //    columns (e.g. SELECT ROW_NUMBER()...AS x) in WHERE clauses.\n      // 2. The next query handles the LIMIT and OFFSET behavior by getting\n      //    the TOP N rows of the query where the row number is > OFFSET\n      // 3. The innermost query is the actual set we want information from\n\n      const offset = options.offset || 0;\n      const isSubQuery = options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation;\n      let orders = { mainQueryOrder: [] };\n      if (options.order) {\n        orders = this.getQueryOrders(options, model, isSubQuery);\n      }\n\n      if (orders.mainQueryOrder.length === 0) {\n        orders.mainQueryOrder.push(this.quoteIdentifier(model.primaryKeyField));\n      }\n\n      const tmpTable = mainTableAs || 'OffsetTable';\n\n      if (options.include) {\n        const subQuery = options.subQuery === undefined ? options.limit && options.hasMultiAssociation : options.subQuery;\n        const mainTable = {\n          name: mainTableAs,\n          quotedName: null,\n          as: null,\n          model\n        };\n        const topLevelInfo = {\n          names: mainTable,\n          options,\n          subQuery\n        };\n\n        let mainJoinQueries = [];\n        for (const include of options.include) {\n          if (include.separate) {\n            continue;\n          }\n          const joinQueries = this.generateInclude(include, { externalAs: mainTableAs, internalAs: mainTableAs }, topLevelInfo);\n          mainJoinQueries = mainJoinQueries.concat(joinQueries.mainQuery);\n        }\n\n        return Utils.joinSQLFragments([\n          'SELECT TOP 100 PERCENT',\n          attributes.join(', '),\n          'FROM (',\n          [\n            'SELECT',\n            options.limit && `TOP ${options.limit}`,\n            '* FROM (',\n            [\n              'SELECT ROW_NUMBER() OVER (',\n              [\n                'ORDER BY',\n                orders.mainQueryOrder.join(', ')\n              ],\n              `) as row_num, ${tmpTable}.* FROM (`,\n              [\n                'SELECT DISTINCT',\n                `${tmpTable}.* FROM ${tables} AS ${tmpTable}`,\n                mainJoinQueries,\n                where && `WHERE ${where}`\n              ],\n              `) AS ${tmpTable}`\n            ],\n            `) AS ${tmpTable} WHERE row_num > ${offset}`\n          ],\n          `) AS ${tmpTable}`\n        ]);\n      }\n      return Utils.joinSQLFragments([\n        'SELECT TOP 100 PERCENT',\n        attributes.join(', '),\n        'FROM (',\n        [\n          'SELECT',\n          options.limit && `TOP ${options.limit}`,\n          '* FROM (',\n          [\n            'SELECT ROW_NUMBER() OVER (',\n            [\n              'ORDER BY',\n              orders.mainQueryOrder.join(', ')\n            ],\n            `) as row_num, * FROM ${tables} AS ${tmpTable}`,\n            where && `WHERE ${where}`\n          ],\n          `) AS ${tmpTable} WHERE row_num > ${offset}`\n        ],\n        `) AS ${tmpTable}`\n      ]);\n    }\n\n    return Utils.joinSQLFragments([\n      'SELECT',\n      isSQLServer2008 && options.limit && `TOP ${options.limit}`,\n      attributes.join(', '),\n      `FROM ${tables}`,\n      mainTableAs && `AS ${mainTableAs}`,\n      options.tableHint && TableHints[options.tableHint] && `WITH (${TableHints[options.tableHint]})`\n    ]);\n  }\n\n  addLimitAndOffset(options, model) {\n    // Skip handling of limit and offset as postfixes for older SQL Server versions\n    if (semver.valid(this.sequelize.options.databaseVersion) && semver.lt(this.sequelize.options.databaseVersion, '11.0.0')) {\n      return '';\n    }\n\n    const offset = options.offset || 0;\n    const isSubQuery = options.subQuery === undefined\n      ? options.hasIncludeWhere || options.hasIncludeRequired || options.hasMultiAssociation\n      : options.subQuery;\n\n    let fragment = '';\n    let orders = {};\n\n    if (options.order) {\n      orders = this.getQueryOrders(options, model, isSubQuery);\n    }\n\n    if (options.limit || options.offset) {\n      if (!options.order || !options.order.length || options.include && !orders.subQueryOrder.length) {\n        const tablePkFragment = `${this.quoteTable(options.tableAs || model.name)}.${this.quoteIdentifier(model.primaryKeyField)}`;\n        if (!options.order || !options.order.length) {\n          fragment += ` ORDER BY ${tablePkFragment}`;\n        } else {\n          const orderFieldNames = _.map(options.order, order => order[0]);\n          const primaryKeyFieldAlreadyPresent = _.includes(orderFieldNames, model.primaryKeyField);\n\n          if (!primaryKeyFieldAlreadyPresent) {\n            fragment += options.order && !isSubQuery ? ', ' : ' ORDER BY ';\n            fragment += tablePkFragment;\n          }\n        }\n      }\n\n      if (options.offset || options.limit) {\n        fragment += ` OFFSET ${this.escape(offset)} ROWS`;\n      }\n\n      if (options.limit) {\n        fragment += ` FETCH NEXT ${this.escape(options.limit)} ROWS ONLY`;\n      }\n    }\n\n    return fragment;\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n}\n\n// private methods\nfunction wrapSingleQuote(identifier) {\n  return Utils.addTicks(Utils.removeTicks(identifier, \"'\"), \"'\");\n}\n\nmodule.exports = MSSQLQueryGenerator;\n"],
  "mappings": "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",
  "names": []
}
