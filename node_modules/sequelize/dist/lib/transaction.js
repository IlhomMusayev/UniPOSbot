"use strict";var a=Object.defineProperty;var r=Object.getOwnPropertySymbols;var E=Object.prototype.hasOwnProperty,p=Object.prototype.propertyIsEnumerable;var c=(e,t,i)=>t in e?a(e,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):e[t]=i,h=(e,t)=>{for(var i in t||(t={}))E.call(t,i)&&c(e,i,t[i]);if(r)for(var i of r(t))p.call(t,i)&&c(e,i,t[i]);return e};var l=(e,t)=>a(e,"name",{value:t,configurable:!0});class s{constructor(t,i){this.sequelize=t,this.savepoints=[],this._afterCommitHooks=[];const n=this.sequelize.dialect.queryGenerator.generateTransactionId;this.options=h({type:t.options.transactionType,isolationLevel:t.options.isolationLevel,readOnly:!1},i),this.parent=this.options.transaction,this.parent?(this.id=this.parent.id,this.parent.savepoints.push(this),this.name=`${this.id}-sp-${this.parent.savepoints.length}`):this.id=this.name=n(),delete this.options.transaction}async commit(){if(this.finished)throw new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`);try{return await this.sequelize.getQueryInterface().commitTransaction(this,this.options)}finally{this.finished="commit",this.cleanup();for(const t of this._afterCommitHooks)await t.apply(this,[this])}}async rollback(){if(this.finished)throw new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`);if(!this.connection)throw new Error("Transaction cannot be rolled back because it never started");try{return await this.sequelize.getQueryInterface().rollbackTransaction(this,this.options)}finally{this.cleanup()}}async prepareEnvironment(t){let i;if(t===void 0&&(t=!0),this.parent)i=Promise.resolve(this.parent.connection);else{const o={uuid:this.id};this.options.readOnly&&(o.type="SELECT"),i=this.sequelize.connectionManager.getConnection(o)}let n;const u=await i;this.connection=u,this.connection.uuid=this.id;try{await this.begin(),n=await this.setDeferrable()}catch(o){try{n=await this.rollback()}finally{throw o}}return t&&this.sequelize.constructor._cls&&this.sequelize.constructor._cls.set("transaction",this),n}async setDeferrable(){if(this.options.deferrable)return await this.sequelize.getQueryInterface().deferConstraints(this,this.options)}async begin(){const t=this.sequelize.getQueryInterface();return this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction?(await t.startTransaction(this,this.options),t.setIsolationLevel(this,this.options.isolationLevel,this.options)):(await t.setIsolationLevel(this,this.options.isolationLevel,this.options),t.startTransaction(this,this.options))}cleanup(){if(this.parent||this.connection.uuid===void 0)return;this._clearCls();const t=this.sequelize.connectionManager.releaseConnection(this.connection);return this.connection.uuid=void 0,t}_clearCls(){const t=this.sequelize.constructor._cls;t&&t.get("transaction")===this&&t.set("transaction",null)}afterCommit(t){if(!t||typeof t!="function")throw new Error('"fn" must be a function');this._afterCommitHooks.push(t)}static get TYPES(){return{DEFERRED:"DEFERRED",IMMEDIATE:"IMMEDIATE",EXCLUSIVE:"EXCLUSIVE"}}static get ISOLATION_LEVELS(){return{READ_UNCOMMITTED:"READ UNCOMMITTED",READ_COMMITTED:"READ COMMITTED",REPEATABLE_READ:"REPEATABLE READ",SERIALIZABLE:"SERIALIZABLE"}}static get LOCK(){return{UPDATE:"UPDATE",SHARE:"SHARE",KEY_SHARE:"KEY SHARE",NO_KEY_UPDATE:"NO KEY UPDATE"}}get LOCK(){return s.LOCK}}l(s,"Transaction"),module.exports=s,module.exports.Transaction=s,module.exports.default=s;
//# sourceMappingURL=transaction.js.map
