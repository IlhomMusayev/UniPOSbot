"use strict";var I=Object.defineProperty;var n=(r,e)=>I(r,"name",{value:e,configurable:!0});const L=require("wkx"),S=require("lodash"),O=require("moment-timezone");module.exports=r=>{r.ABSTRACT.prototype.dialectTypes="https://dev.mysql.com/doc/refman/5.7/en/data-types.html",r.DATE.types.mysql=["DATETIME"],r.STRING.types.mysql=["VAR_STRING"],r.CHAR.types.mysql=["STRING"],r.TEXT.types.mysql=["BLOB"],r.TINYINT.types.mysql=["TINY"],r.SMALLINT.types.mysql=["SHORT"],r.MEDIUMINT.types.mysql=["INT24"],r.INTEGER.types.mysql=["LONG"],r.BIGINT.types.mysql=["LONGLONG"],r.FLOAT.types.mysql=["FLOAT"],r.TIME.types.mysql=["TIME"],r.DATEONLY.types.mysql=["DATE"],r.BOOLEAN.types.mysql=["TINY"],r.BLOB.types.mysql=["TINYBLOB","BLOB","LONGBLOB"],r.DECIMAL.types.mysql=["NEWDECIMAL"],r.UUID.types.mysql=!1,r.ENUM.types.mysql=!1,r.REAL.types.mysql=["DOUBLE"],r.DOUBLE.types.mysql=["DOUBLE"],r.GEOMETRY.types.mysql=["GEOMETRY"],r.JSON.types.mysql=["JSON"];class e extends r.DECIMAL{toSql(){let t=super.toSql();return this._unsigned&&(t+=" UNSIGNED"),this._zerofill&&(t+=" ZEROFILL"),t}}n(e,"DECIMAL");class m extends r.DATE{toSql(){return this._length?`DATETIME(${this._length})`:"DATETIME"}_stringify(t,s){return t=this._applyTimezone(t,s),this._length?t.format("YYYY-MM-DD HH:mm:ss.SSS"):t.format("YYYY-MM-DD HH:mm:ss")}static parse(t,s){return t=t.string(),t===null||(O.tz.zone(s.timezone)?t=O.tz(t,s.timezone).toDate():t=new Date(`${t} ${s.timezone}`)),t}}n(m,"DATE");class E extends r.DATEONLY{static parse(t){return t.string()}}n(E,"DATEONLY");class l extends r.UUID{toSql(){return"CHAR(36) BINARY"}}n(l,"UUID");const o=["POINT","LINESTRING","POLYGON"];class N extends r.GEOMETRY{constructor(t,s){super(t,s);if(S.isEmpty(this.type)){this.sqlType=this.key;return}if(o.includes(this.type)){this.sqlType=this.type;return}throw new Error(`Supported geometry types are: ${o.join(", ")}`)}static parse(t){return t=t.buffer(),!t||t.length===0?null:(t=t.slice(4),L.Geometry.parse(t).toGeoJSON({shortCrs:!0}))}toSql(){return this.sqlType}}n(N,"GEOMETRY");class q extends r.ENUM{toSql(t){return`ENUM(${this.values.map(s=>t.escape(s)).join(", ")})`}}n(q,"ENUM");class y extends r.JSON{_stringify(t,s){return s.operation==="where"&&typeof t=="string"?t:JSON.stringify(t)}}return n(y,"JSONTYPE"),{ENUM:q,DATE:m,DATEONLY:E,UUID:l,GEOMETRY:N,DECIMAL:e,JSON:y}};
//# sourceMappingURL=data-types.js.map
