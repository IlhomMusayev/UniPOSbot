"use strict";var s=Object.defineProperty;var i=(e,r)=>s(e,"name",{value:r,configurable:!0});function d(e){if(Object.prototype.hasOwnProperty.call(e.source.rawAttributes,e.as))throw new Error(`Naming collision between attribute '${e.as}' and association '${e.as}' on model ${e.source.name}. To remedy this, change either foreignKey or as in your association definition`)}i(d,"checkNamingCollision"),exports.checkNamingCollision=d;function l(e,r,a,n,t){if(n.foreignKeyConstraint||n.onDelete||n.onUpdate){const o=Object.keys(r.primaryKeys).map(c=>r.rawAttributes[c].field||c);(o.length===1||!o.includes(t))&&(e.references={model:r.getTableName(),key:t||o[0]},e.onDelete=n.onDelete,e.onUpdate=n.onUpdate)}}i(l,"addForeignKeyConstraints"),exports.addForeignKeyConstraints=l;function f(e,r,a,n){n=n||{};for(const t of a)if(!Object.prototype.hasOwnProperty.call(r,e.accessors[t])){const o=n[t]||t;r[e.accessors[t]]=function(){return e[o](this,...Array.from(arguments))}}}i(f,"mixinMethods"),exports.mixinMethods=f;
//# sourceMappingURL=helpers.js.map
