"use strict";var Y=Object.defineProperty;var n=(r,f)=>Y(r,"name",{value:f,configurable:!0});const D=require("lodash"),C=require("wkx");module.exports=r=>{const f=r.ABSTRACT.warn.bind(void 0,"http://www.postgresql.org/docs/9.4/static/datatype.html");function d(e){(e._length||e.options.length||e._unsigned||e._zerofill)&&(f(`PostgresSQL does not support '${e.key}' with LENGTH, UNSIGNED or ZEROFILL. Plain '${e.key}' will be used instead.`),e._length=void 0,e.options.length=void 0,e._unsigned=void 0,e._zerofill=void 0)}n(d,"removeUnsupportedIntegerOptions"),r.UUID.types.postgres=["uuid"],r.CIDR.types.postgres=["cidr"],r.INET.types.postgres=["inet"],r.MACADDR.types.postgres=["macaddr"],r.TSVECTOR.types.postgres=["tsvector"],r.JSON.types.postgres=["json"],r.JSONB.types.postgres=["jsonb"],r.TIME.types.postgres=["time"];class a extends r.DATEONLY{_stringify(t,i){return t===1/0?"Infinity":t===-1/0?"-Infinity":super._stringify(t,i)}_sanitize(t,i){if((!i||i&&!i.raw)&&t!==1/0&&t!==-1/0){if(typeof t=="string"){const s=t.toLowerCase();if(s==="infinity")return 1/0;if(s==="-infinity")return-1/0}return super._sanitize(t)}return t}static parse(t){return t==="infinity"?1/0:t==="-infinity"?-1/0:t}}n(a,"DATEONLY"),r.DATEONLY.types.postgres=["date"];class E extends r.DECIMAL{static parse(t){return t}}n(E,"DECIMAL"),r.DECIMAL.types.postgres=["numeric"];class _ extends r.STRING{toSql(){return this._binary?"BYTEA":super.toSql()}}n(_,"STRING"),r.STRING.types.postgres=["varchar"];class I extends r.TEXT{toSql(){return this._length&&(f("PostgreSQL does not support TEXT with options. Plain `TEXT` will be used instead."),this._length=void 0),"TEXT"}}n(I,"TEXT"),r.TEXT.types.postgres=["text"];class A extends r.CITEXT{static parse(t){return t}}n(A,"CITEXT"),r.CITEXT.types.postgres=["citext"];class m extends r.CHAR{toSql(){return this._binary?"BYTEA":super.toSql()}}n(m,"CHAR"),r.CHAR.types.postgres=["char","bpchar"];class p extends r.BOOLEAN{toSql(){return"BOOLEAN"}_sanitize(t){if(t!=null){if(Buffer.isBuffer(t)&&t.length===1&&(t=t[0]),typeof t=="string")return t==="true"||t==="t"?!0:t==="false"||t==="f"?!1:t;if(typeof t=="number")return t===1?!0:t===0?!1:t}return t}}n(p,"BOOLEAN"),p.parse=p.prototype._sanitize,r.BOOLEAN.types.postgres=["bool"];class O extends r.DATE{toSql(){return"TIMESTAMP WITH TIME ZONE"}validate(t){return t!==1/0&&t!==-1/0?super.validate(t):!0}_stringify(t,i){return t===1/0?"Infinity":t===-1/0?"-Infinity":super._stringify(t,i)}_sanitize(t,i){if((!i||i&&!i.raw)&&!(t instanceof Date)&&!!t&&t!==1/0&&t!==-1/0){if(typeof t=="string"){const s=t.toLowerCase();if(s==="infinity")return 1/0;if(s==="-infinity")return-1/0}return new Date(t)}return t}}n(O,"DATE"),r.DATE.types.postgres=["timestamptz"];class S extends r.TINYINT{constructor(t){super(t);d(this)}}n(S,"TINYINT"),r.TINYINT.types.postgres=["int2"];class N extends r.SMALLINT{constructor(t){super(t);d(this)}}n(N,"SMALLINT"),r.SMALLINT.types.postgres=["int2"];class g extends r.INTEGER{constructor(t){super(t);d(this)}}n(g,"INTEGER"),g.parse=n(function(t){return parseInt(t,10)},"parse"),r.INTEGER.types.postgres=["int4"];class b extends r.BIGINT{constructor(t){super(t);d(this)}}n(b,"BIGINT"),r.BIGINT.types.postgres=["int8"];class L extends r.REAL{constructor(t){super(t);d(this)}}n(L,"REAL"),r.REAL.types.postgres=["float4"];class R extends r.DOUBLE{constructor(t){super(t);d(this)}}n(R,"DOUBLE"),r.DOUBLE.types.postgres=["float8"];class h extends r.FLOAT{constructor(t,i){super(t,i);this._decimals&&(f("PostgreSQL does not support FLOAT with decimals. Plain `FLOAT` will be used instead."),this._length=void 0,this.options.length=void 0,this._decimals=void 0),this._unsigned&&(f("PostgreSQL does not support FLOAT unsigned. `UNSIGNED` was removed."),this._unsigned=void 0),this._zerofill&&(f("PostgreSQL does not support FLOAT zerofill. `ZEROFILL` was removed."),this._zerofill=void 0)}}n(h,"FLOAT"),delete h.parse;class G extends r.BLOB{toSql(){return this._length&&(f("PostgreSQL does not support BLOB (BYTEA) with options. Plain `BYTEA` will be used instead."),this._length=void 0),"BYTEA"}_hexify(t){return`E'\\\\x${t}'`}}n(G,"BLOB"),r.BLOB.types.postgres=["bytea"];class x extends r.GEOMETRY{toSql(){let t=this.key;return this.type&&(t+=`(${this.type}`,this.srid&&(t+=`,${this.srid}`),t+=")"),t}static parse(t){const i=Buffer.from(t,"hex");return C.Geometry.parse(i).toGeoJSON({shortCrs:!0})}_stringify(t,i){return`ST_GeomFromGeoJSON(${i.escape(JSON.stringify(t))})`}_bindParam(t,i){return`ST_GeomFromGeoJSON(${i.bindParam(t)})`}}n(x,"GEOMETRY"),r.GEOMETRY.types.postgres=["geometry"];class P extends r.GEOGRAPHY{toSql(){let t="GEOGRAPHY";return this.type&&(t+=`(${this.type}`,this.srid&&(t+=`,${this.srid}`),t+=")"),t}static parse(t){const i=Buffer.from(t,"hex");return C.Geometry.parse(i).toGeoJSON({shortCrs:!0})}_stringify(t,i){return`ST_GeomFromGeoJSON(${i.escape(JSON.stringify(t))})`}bindParam(t,i){return`ST_GeomFromGeoJSON(${i.bindParam(t)})`}}n(P,"GEOGRAPHY"),r.GEOGRAPHY.types.postgres=["geography"];let u;class l extends r.HSTORE{constructor(){super();u||(u=require("./hstore"))}_value(t){return u||(u=require("./hstore")),u.stringify(t)}_stringify(t){return`'${this._value(t)}'`}_bindParam(t,i){return i.bindParam(this._value(t))}static parse(t){return u||(u=require("./hstore")),u.parse(t)}}n(l,"HSTORE"),l.prototype.escape=!1,r.HSTORE.types.postgres=["hstore"];class y extends r.RANGE{_value(t,i){if(!Array.isArray(t))return this.options.subtype.stringify(t,i);const s=[!0,!1],c=t.map((o,$)=>(D.isObject(o)&&Object.prototype.hasOwnProperty.call(o,"value")&&(Object.prototype.hasOwnProperty.call(o,"inclusive")&&(s[$]=o.inclusive),o=o.value),o===null||o===-1/0||o===1/0?o:this.options.subtype.stringify?this.options.subtype.stringify(o,i):i.escape(o)));return c.inclusive=s,w.stringify(c)}_stringify(t,i){const s=this._value(t,i);return Array.isArray(t)?`'${s}'`:`'${s}'::${this.toCastType()}`}_bindParam(t,i){const s=this._value(t,i);return Array.isArray(t)?i.bindParam(s):`${i.bindParam(s)}::${this.toCastType()}`}toSql(){return r.RANGE.types.postgres.subtypes[this._subtype.toLowerCase()]}toCastType(){return r.RANGE.types.postgres.castTypes[this._subtype.toLowerCase()]}static parse(t,i={parser:s=>s}){return w.parse(t,i.parser)}}n(y,"RANGE");const w=require("./range");y.prototype.escape=!1,r.RANGE.types.postgres={subtypes:{integer:"int4range",decimal:"numrange",date:"tstzrange",dateonly:"daterange",bigint:"int8range"},castTypes:{integer:"int4",decimal:"numeric",date:"timestamptz",dateonly:"date",bigint:"int8"}},r.ARRAY.prototype.escape=!1,r.ARRAY.prototype._value=n(function(t,i){return t.map(s=>i&&i.bindParam&&this.type&&this.type._value?this.type._value(s,i):this.type&&this.type.stringify&&(s=this.type.stringify(s,i),this.type.escape===!1)?s:i.escape(s),this)},"_value"),r.ARRAY.prototype._stringify=n(function(t,i){let s=`ARRAY[${this._value(t,i).join(",")}]`;if(this.type){const c=require("../../utils");let o=this.toSql();this.type instanceof r.ENUM&&(o=`${c.addTicks(c.generateEnumName(i.field.Model.getTableName(),i.field.field),'"')}[]`),s+=`::${o}`}return s},"_stringify"),r.ARRAY.prototype._bindParam=n(function(t,i){return i.bindParam(this._value(t,i))},"_bindParam");class q extends r.ENUM{static parse(t){return t}}return n(q,"ENUM"),r.ENUM.types.postgres=[null],{DECIMAL:E,BLOB:G,STRING:_,CHAR:m,TEXT:I,CITEXT:A,TINYINT:S,SMALLINT:N,INTEGER:g,BIGINT:b,BOOLEAN:p,DATE:O,DATEONLY:a,REAL:L,"DOUBLE PRECISION":R,FLOAT:h,GEOMETRY:x,GEOGRAPHY:P,HSTORE:l,RANGE:y,ENUM:q}};
//# sourceMappingURL=data-types.js.map
