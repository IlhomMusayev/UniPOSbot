"use strict";var g=Object.defineProperty,d=Object.defineProperties;var m=Object.getOwnPropertyDescriptors;var l=Object.getOwnPropertySymbols;var O=Object.prototype.hasOwnProperty,j=Object.prototype.propertyIsEnumerable;var K=(r,t,e)=>t in r?g(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e,u=(r,t)=>{for(var e in t||(t={}))O.call(t,e)&&K(r,e,t[e]);if(l)for(var e of l(t))j.call(t,e)&&K(r,e,t[e]);return r},y=(r,t)=>d(r,m(t));var p=(r,t)=>g(r,"name",{value:t,configurable:!0});const a=require("./../utils"),c=require("./helpers"),A=require("lodash"),D=require("./base"),b=require("../operators");class w extends D{constructor(t,e,i){super(t,e,i);if(this.associationType="HasOne",this.isSingleAssociation=!0,this.foreignKeyAttribute={},this.as?(this.isAliased=!0,this.options.name={singular:this.as}):(this.as=this.target.options.name.singular,this.options.name=this.target.options.name),A.isObject(this.options.foreignKey)?(this.foreignKeyAttribute=this.options.foreignKey,this.foreignKey=this.foreignKeyAttribute.name||this.foreignKeyAttribute.fieldName):this.options.foreignKey&&(this.foreignKey=this.options.foreignKey),this.foreignKey||(this.foreignKey=a.camelize([a.singularize(this.options.as||this.source.name),this.source.primaryKeyAttribute].join("_"))),this.options.sourceKey&&!this.source.rawAttributes[this.options.sourceKey])throw new Error(`Unknown attribute "${this.options.sourceKey}" passed as sourceKey, define this attribute on model "${this.source.name}" first`);this.sourceKey=this.sourceKeyAttribute=this.options.sourceKey||this.source.primaryKeyAttribute,this.sourceKeyField=this.source.rawAttributes[this.sourceKey].field||this.sourceKey,this.sourceKeyIsPrimary=this.sourceKey===this.source.primaryKeyAttribute,this.associationAccessor=this.as,this.options.useHooks=i.useHooks,this.target.rawAttributes[this.foreignKey]&&(this.identifierField=this.target.rawAttributes[this.foreignKey].field||this.foreignKey);const s=A.upperFirst(this.options.name.singular);this.accessors={get:`get${s}`,set:`set${s}`,create:`create${s}`}}_injectAttributes(){const t={[this.foreignKey]:u({type:this.options.keyType||this.source.rawAttributes[this.sourceKey].type,allowNull:!0},this.foreignKeyAttribute)};if(this.options.constraints!==!1){const e=this.target.rawAttributes[this.foreignKey]||t[this.foreignKey];this.options.onDelete=this.options.onDelete||(e.allowNull?"SET NULL":"CASCADE"),this.options.onUpdate=this.options.onUpdate||"CASCADE"}return c.addForeignKeyConstraints(t[this.foreignKey],this.source,this.target,this.options,this.sourceKeyField),a.mergeDefaults(this.target.rawAttributes,t),this.target.refreshAttributes(),this.identifierField=this.target.rawAttributes[this.foreignKey].field||this.foreignKey,c.checkNamingCollision(this),this}mixin(t){const e=["get","set","create"];c.mixinMethods(this,t,e)}async get(t,e){const i={};let s=this.target,h;if(e=a.cloneDeep(e),Object.prototype.hasOwnProperty.call(e,"scope")&&(e.scope?s=s.scope(e.scope):s=s.unscoped()),Object.prototype.hasOwnProperty.call(e,"schema")&&(s=s.schema(e.schema,e.schemaDelimiter)),Array.isArray(t)||(h=t,t=void 0),t?i[this.foreignKey]={[b.in]:t.map(o=>o.get(this.sourceKey))}:i[this.foreignKey]=h.get(this.sourceKey),this.scope&&Object.assign(i,this.scope),e.where=e.where?{[b.and]:[i,e.where]}:i,t){const o=await s.findAll(e),f={};for(const n of t)f[n.get(this.sourceKey,{raw:!0})]=null;for(const n of o)f[n.get(this.foreignKey,{raw:!0})]=n;return f}return s.findOne(e)}async set(t,e,i){i=y(u({},i),{scope:!1});const s=await t[this.accessors.get](i),h=s&&e&&this.target.primaryKeyAttributes.every(o=>s.get(o,{raw:!0})===(e.get?e.get(o,{raw:!0}):e));if(s&&!h&&(s[this.foreignKey]=null,await s.save(y(u({},i),{fields:[this.foreignKey],allowNull:[this.foreignKey],association:!0}))),e&&!h){if(!(e instanceof this.target)){const o={};o[this.target.primaryKeyAttribute]=e,e=this.target.build(o,{isNewRecord:!1})}return Object.assign(e,this.scope),e.set(this.foreignKey,t.get(this.sourceKeyAttribute)),e.save(i)}return null}async create(t,e,i){if(e=e||{},i=i||{},this.scope)for(const s of Object.keys(this.scope))e[s]=this.scope[s],i.fields&&i.fields.push(s);return e[this.foreignKey]=t.get(this.sourceKeyAttribute),i.fields&&i.fields.push(this.foreignKey),await this.target.create(e,i)}verifyAssociationAlias(t){return typeof t=="string"?this.as===t:t&&t.singular?this.as===t.singular:!this.isAliased}}p(w,"HasOne"),module.exports=w;
//# sourceMappingURL=has-one.js.map
