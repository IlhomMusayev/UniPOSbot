"use strict";var h=Object.defineProperty;var a=(d,e)=>h(d,"name",{value:e,configurable:!0});const{Pool:l,TimeoutError:w}=require("sequelize-pool"),n=require("lodash"),c=require("semver"),m=require("../../errors"),{logger:f}=require("../../utils/logger"),q=require("../../utils/deprecations"),r=f.debugContext("pool");class s{constructor(e,o){const i=n.cloneDeep(o.config);if(this.sequelize=o,this.config=i,this.dialect=e,this.versionPromise=null,this.dialectName=this.sequelize.options.dialect,i.pool===!1)throw new Error("Support for pool:false was removed in v4.0");i.pool=n.defaults(i.pool||{},{max:5,min:0,idle:1e4,acquire:6e4,evict:1e3,validate:this._validate.bind(this)}),this.initPools()}refreshTypeParser(e){n.each(e,o=>{if(Object.prototype.hasOwnProperty.call(o,"parse"))if(o.types[this.dialectName])this._refreshTypeParser(o);else throw new Error(`Parse function not supported for type ${o.key} in dialect ${this.dialectName}`)})}_loadDialectModule(e){try{return this.sequelize.config.dialectModulePath?require(this.sequelize.config.dialectModulePath):this.sequelize.config.dialectModule?this.sequelize.config.dialectModule:require(e)}catch(o){throw o.code==="MODULE_NOT_FOUND"?this.sequelize.config.dialectModulePath?new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`):new Error(`Please install ${e} package manually`):o}}async _onProcessExit(){if(!!this.pool)return await this.pool.drain(),r("connection drain due to process exit"),await this.pool.destroyAllNow()}async close(){return this.getConnection=a(async function(){throw new Error("ConnectionManager.getConnection was called after the connection manager was closed!")},"getConnection"),await this._onProcessExit()}initPools(){const e=this.config;if(!e.replication){this.pool=new l({name:"sequelize",create:()=>this._connect(e),destroy:async i=>{const t=await this._disconnect(i);return r("connection destroy"),t},validate:e.pool.validate,max:e.pool.max,min:e.pool.min,acquireTimeoutMillis:e.pool.acquire,idleTimeoutMillis:e.pool.idle,reapIntervalMillis:e.pool.evict,maxUses:e.pool.maxUses}),r(`pool created with max/min: ${e.pool.max}/${e.pool.min}, no replication`);return}Array.isArray(e.replication.read)||(e.replication.read=[e.replication.read]),e.replication.write=n.defaults(e.replication.write,n.omit(e,"replication")),e.replication.read=e.replication.read.map(i=>n.defaults(i,n.omit(this.config,"replication")));let o=0;this.pool={release:i=>{i.queryType==="read"?this.pool.read.release(i):this.pool.write.release(i)},acquire:(i,t)=>(t=t===void 0?!1:t,i==="SELECT"&&!t?this.pool.read.acquire():this.pool.write.acquire()),destroy:i=>{this.pool[i.queryType].destroy(i),r("connection destroy")},destroyAllNow:async()=>{await Promise.all([this.pool.read.destroyAllNow(),this.pool.write.destroyAllNow()]),r("all connections destroyed")},drain:async()=>Promise.all([this.pool.write.drain(),this.pool.read.drain()]),read:new l({name:"sequelize:read",create:async()=>{const i=o++%e.replication.read.length,t=await this._connect(e.replication.read[i]);return t.queryType="read",t},destroy:i=>this._disconnect(i),validate:e.pool.validate,max:e.pool.max,min:e.pool.min,acquireTimeoutMillis:e.pool.acquire,idleTimeoutMillis:e.pool.idle,reapIntervalMillis:e.pool.evict,maxUses:e.pool.maxUses}),write:new l({name:"sequelize:write",create:async()=>{const i=await this._connect(e.replication.write);return i.queryType="write",i},destroy:i=>this._disconnect(i),validate:e.pool.validate,max:e.pool.max,min:e.pool.min,acquireTimeoutMillis:e.pool.acquire,idleTimeoutMillis:e.pool.idle,reapIntervalMillis:e.pool.evict,maxUses:e.pool.maxUses})},r(`pool created with max/min: ${e.pool.max}/${e.pool.min}, with replication`)}async getConnection(e){e=e||{},this.sequelize.options.databaseVersion===0&&(this.versionPromise||(this.versionPromise=(async()=>{try{const i=await this._connect(this.config.replication.write||this.config),t={};if(t.transaction={connection:i},t.logging=()=>{},t.logging.__testLoggingFn=!0,this.sequelize.options.databaseVersion===0){const u=await this.sequelize.databaseVersion(t),p=n.get(c.coerce(u),"version")||u;this.sequelize.options.databaseVersion=c.valid(p)?p:this.dialect.defaultVersion}return c.lt(this.sequelize.options.databaseVersion,this.dialect.defaultVersion)&&(q.unsupportedEngine(),r(`Unsupported database engine version ${this.sequelize.options.databaseVersion}`)),this.versionPromise=null,await this._disconnect(i)}catch(i){throw this.versionPromise=null,i}})()),await this.versionPromise);let o;try{o=await this.pool.acquire(e.type,e.useMaster)}catch(i){throw i instanceof w?new m.ConnectionAcquireTimeoutError(i):i}return r("connection acquired"),o}async releaseConnection(e){this.pool.release(e),r("connection released")}async _connect(e){await this.sequelize.runHooks("beforeConnect",e);const o=await this.dialect.connectionManager.connect(e);return await this.sequelize.runHooks("afterConnect",o,e),o}async _disconnect(e){return await this.sequelize.runHooks("beforeDisconnect",e),await this.dialect.connectionManager.disconnect(e),this.sequelize.runHooks("afterDisconnect",e)}_validate(e){return this.dialect.connectionManager.validate?this.dialect.connectionManager.validate(e):!0}}a(s,"ConnectionManager"),module.exports=s,module.exports.ConnectionManager=s,module.exports.default=s;
//# sourceMappingURL=connection-manager.js.map
