{
  "version": 3,
  "sources": ["../../../../lib/dialects/sqlite/connection-manager.js"],
  "sourcesContent": ["'use strict';\n\nconst fs = require('fs');\nconst path = require('path');\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('connection:sqlite');\nconst dataTypes = require('../../data-types').sqlite;\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { promisify } = require('util');\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    super(dialect, sequelize);\n\n    // We attempt to parse file location from a connection uri\n    // but we shouldn't match sequelize default host.\n    if (this.sequelize.options.host === 'localhost') {\n      delete this.sequelize.options.host;\n    }\n\n    this.connections = {};\n    this.lib = this._loadDialectModule('sqlite3');\n    this.refreshTypeParser(dataTypes);\n  }\n\n  async _onProcessExit() {\n    await Promise.all(\n      Object.getOwnPropertyNames(this.connections)\n        .map(connection => promisify(callback => this.connections[connection].close(callback))())\n    );\n    return super._onProcessExit.call(this);\n  }\n\n  // Expose this as a method so that the parsing may be updated when the user has added additional, custom types\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  async getConnection(options) {\n    options = options || {};\n    options.uuid = options.uuid || 'default';\n\n    if (!!this.sequelize.options.storage !== null && this.sequelize.options.storage !== undefined) {\n      // Check explicitely for the storage option to not be set since an empty string signals\n      // SQLite will create a temporary disk-based database in that case.\n      options.storage = this.sequelize.options.storage;\n    } else {\n      options.storage = this.sequelize.options.host || ':memory:';\n    }\n\n    options.inMemory = options.storage === ':memory:' ? 1 : 0;\n\n    const dialectOptions = this.sequelize.options.dialectOptions;\n    const defaultReadWriteMode = this.lib.OPEN_READWRITE | this.lib.OPEN_CREATE;\n\n    options.readWriteMode = dialectOptions && dialectOptions.mode || defaultReadWriteMode;\n\n    if (this.connections[options.inMemory || options.uuid]) {\n      return this.connections[options.inMemory || options.uuid];\n    }\n\n    if (!options.inMemory && (options.readWriteMode & this.lib.OPEN_CREATE) !== 0) {\n      // automatic path provision for `options.storage`\n      fs.mkdirSync(path.dirname(options.storage), { recursive: true });\n    }\n\n    const connection = await new Promise((resolve, reject) => {\n      this.connections[options.inMemory || options.uuid] = new this.lib.Database(\n        options.storage,\n        options.readWriteMode,\n        err => {\n          if (err) return reject(new sequelizeErrors.ConnectionError(err));\n          debug(`connection acquired ${options.uuid}`);\n          resolve(this.connections[options.inMemory || options.uuid]);\n        }\n      );\n    });\n\n    if (this.sequelize.config.password) {\n      // Make it possible to define and use password for sqlite encryption plugin like sqlcipher\n      connection.run(`PRAGMA KEY=${this.sequelize.escape(this.sequelize.config.password)}`);\n    }\n    if (this.sequelize.options.foreignKeys !== false) {\n      // Make it possible to define and use foreign key constraints unless\n      // explicitly disallowed. It's still opt-in per relation\n      connection.run('PRAGMA FOREIGN_KEYS=ON');\n    }\n\n    return connection;\n  }\n\n  releaseConnection(connection, force) {\n    if (connection.filename === ':memory:' && force !== true) return;\n\n    if (connection.uuid) {\n      connection.close();\n      debug(`connection released ${connection.uuid}`);\n      delete this.connections[connection.uuid];\n    }\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],
  "mappings": "4FAEA,KAAM,GAAK,QAAQ,MACb,EAAO,QAAQ,QACf,EAA4B,QAAQ,kCACpC,CAAE,UAAW,QAAQ,sBACrB,EAAQ,EAAO,aAAa,qBAC5B,EAAY,QAAQ,oBAAoB,OACxC,EAAkB,QAAQ,gBAC1B,EAAc,QAAQ,kBAAkB,UACxC,CAAE,aAAc,QAAQ,QAE9B,eAAgC,EAA0B,CACxD,YAAY,EAAS,EAAW,CAC9B,MAAM,EAAS,GAIf,AAAI,KAAK,UAAU,QAAQ,OAAS,aAClC,MAAO,MAAK,UAAU,QAAQ,KAGhC,KAAK,YAAc,GACnB,KAAK,IAAM,KAAK,mBAAmB,WACnC,KAAK,kBAAkB,QAGnB,iBAAiB,CACrB,YAAM,SAAQ,IACZ,OAAO,oBAAoB,KAAK,aAC7B,IAAI,GAAc,EAAU,GAAY,KAAK,YAAY,GAAY,MAAM,QAEzE,MAAM,eAAe,KAAK,MAInC,mBAAmB,EAAU,CAC3B,EAAY,QAAQ,GAGtB,kBAAmB,CACjB,EAAY,aAGR,eAAc,EAAS,CAC3B,EAAU,GAAW,GACrB,EAAQ,KAAO,EAAQ,MAAQ,UAE/B,AAAI,CAAC,CAAC,KAAK,UAAU,QAAQ,UAAY,MAAQ,KAAK,UAAU,QAAQ,UAAY,OAGlF,EAAQ,QAAU,KAAK,UAAU,QAAQ,QAEzC,EAAQ,QAAU,KAAK,UAAU,QAAQ,MAAQ,WAGnD,EAAQ,SAAW,EAAQ,UAAY,WAAa,EAAI,EAExD,KAAM,GAAiB,KAAK,UAAU,QAAQ,eACxC,EAAuB,KAAK,IAAI,eAAiB,KAAK,IAAI,YAIhE,GAFA,EAAQ,cAAgB,GAAkB,EAAe,MAAQ,EAE7D,KAAK,YAAY,EAAQ,UAAY,EAAQ,MAC/C,MAAO,MAAK,YAAY,EAAQ,UAAY,EAAQ,MAGtD,AAAI,CAAC,EAAQ,UAAa,GAAQ,cAAgB,KAAK,IAAI,cAAiB,GAE1E,EAAG,UAAU,EAAK,QAAQ,EAAQ,SAAU,CAAE,UAAW,KAG3D,KAAM,GAAa,KAAM,IAAI,SAAQ,CAAC,EAAS,IAAW,CACxD,KAAK,YAAY,EAAQ,UAAY,EAAQ,MAAQ,GAAI,MAAK,IAAI,SAChE,EAAQ,QACR,EAAQ,cACR,GAAO,CACL,GAAI,EAAK,MAAO,GAAO,GAAI,GAAgB,gBAAgB,IAC3D,EAAM,uBAAuB,EAAQ,QACrC,EAAQ,KAAK,YAAY,EAAQ,UAAY,EAAQ,WAK3D,MAAI,MAAK,UAAU,OAAO,UAExB,EAAW,IAAI,cAAc,KAAK,UAAU,OAAO,KAAK,UAAU,OAAO,aAEvE,KAAK,UAAU,QAAQ,cAAgB,IAGzC,EAAW,IAAI,0BAGV,EAGT,kBAAkB,EAAY,EAAO,CACnC,AAAI,EAAW,WAAa,YAAc,IAAU,IAEhD,EAAW,MACb,GAAW,QACX,EAAM,uBAAuB,EAAW,QACxC,MAAO,MAAK,YAAY,EAAW,QA3FzC,yBAgGA,OAAO,QAAU,EACjB,OAAO,QAAQ,kBAAoB,EACnC,OAAO,QAAQ,QAAU",
  "names": []
}
