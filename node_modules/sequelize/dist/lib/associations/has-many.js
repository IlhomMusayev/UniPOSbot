"use strict";var m=Object.defineProperty,M=Object.defineProperties;var F=Object.getOwnPropertyDescriptors;var b=Object.getOwnPropertySymbols;var j=Object.prototype.hasOwnProperty,$=Object.prototype.propertyIsEnumerable;var w=(o,t,e)=>t in o?m(o,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[t]=e,u=(o,t)=>{for(var e in t||(t={}))j.call(t,e)&&w(o,e,t[e]);if(b)for(var e of b(t))$.call(t,e)&&w(o,e,t[e]);return o},y=(o,t)=>M(o,F(t));var O=(o,t)=>m(o,"name",{value:t,configurable:!0});const f=require("./../utils"),A=require("./helpers"),g=require("lodash"),q=require("./base"),d=require("../operators");class p extends q{constructor(t,e,i){super(t,e,i);if(this.associationType="HasMany",this.targetAssociation=null,this.sequelize=t.sequelize,this.isMultiAssociation=!0,this.foreignKeyAttribute={},this.options.through)throw new Error("N:M associations are not supported with hasMany. Use belongsToMany instead");this.isSelfAssociation&&(this.targetAssociation=this),this.as?(this.isAliased=!0,g.isPlainObject(this.as)?(this.options.name=this.as,this.as=this.as.plural):this.options.name={plural:this.as,singular:f.singularize(this.as)}):(this.as=this.target.options.name.plural,this.options.name=this.target.options.name),g.isObject(this.options.foreignKey)?(this.foreignKeyAttribute=this.options.foreignKey,this.foreignKey=this.foreignKeyAttribute.name||this.foreignKeyAttribute.fieldName):this.options.foreignKey&&(this.foreignKey=this.options.foreignKey),this.foreignKey||(this.foreignKey=f.camelize([this.source.options.name.singular,this.source.primaryKeyAttribute].join("_"))),this.target.rawAttributes[this.foreignKey]&&(this.identifierField=this.target.rawAttributes[this.foreignKey].field||this.foreignKey,this.foreignKeyField=this.target.rawAttributes[this.foreignKey].field||this.foreignKey),this.sourceKey=this.options.sourceKey||this.source.primaryKeyAttribute,this.source.rawAttributes[this.sourceKey]?(this.sourceKeyAttribute=this.sourceKey,this.sourceKeyField=this.source.rawAttributes[this.sourceKey].field||this.sourceKey):(this.sourceKeyAttribute=this.source.primaryKeyAttribute,this.sourceKeyField=this.source.primaryKeyField);const s=g.upperFirst(this.options.name.plural),r=g.upperFirst(this.options.name.singular);this.associationAccessor=this.as,this.accessors={get:`get${s}`,set:`set${s}`,addMultiple:`add${s}`,add:`add${r}`,create:`create${r}`,remove:`remove${r}`,removeMultiple:`remove${s}`,hasSingle:`has${r}`,hasAll:`has${s}`,count:`count${s}`}}_injectAttributes(){const t={[this.foreignKey]:u({type:this.options.keyType||this.source.rawAttributes[this.sourceKeyAttribute].type,allowNull:!0},this.foreignKeyAttribute)},e=u({},this.options);if(this.options.constraints!==!1){const i=this.target.rawAttributes[this.foreignKey]||t[this.foreignKey];e.onDelete=e.onDelete||(i.allowNull?"SET NULL":"CASCADE"),e.onUpdate=e.onUpdate||"CASCADE"}return A.addForeignKeyConstraints(t[this.foreignKey],this.source,this.target,e,this.sourceKeyField),f.mergeDefaults(this.target.rawAttributes,t),this.target.refreshAttributes(),this.source.refreshAttributes(),this.identifierField=this.target.rawAttributes[this.foreignKey].field||this.foreignKey,this.foreignKeyField=this.target.rawAttributes[this.foreignKey].field||this.foreignKey,this.sourceKeyField=this.source.rawAttributes[this.sourceKey].field||this.sourceKey,A.checkNamingCollision(this),this}mixin(t){const e=["get","count","hasSingle","hasAll","set","add","addMultiple","remove","removeMultiple","create"],i={hasSingle:"has",hasAll:"has",addMultiple:"add",removeMultiple:"remove"};A.mixinMethods(this,t,e,i)}async get(t,e={}){const i={};let s=this.target,r,h;Array.isArray(t)||(r=t,t=void 0),e=u({},e),this.scope&&Object.assign(i,this.scope),t?(h=t.map(a=>a.get(this.sourceKey,{raw:!0})),e.limit&&t.length>1?(e.groupedLimit={limit:e.limit,on:this,values:h},delete e.limit):(i[this.foreignKey]={[d.in]:h},delete e.groupedLimit)):i[this.foreignKey]=r.get(this.sourceKey,{raw:!0}),e.where=e.where?{[d.and]:[i,e.where]}:i,Object.prototype.hasOwnProperty.call(e,"scope")&&(e.scope?s=s.scope(e.scope):s=s.unscoped()),Object.prototype.hasOwnProperty.call(e,"schema")&&(s=s.schema(e.schema,e.schemaDelimiter));const c=await s.findAll(e);if(r)return c;const l={};for(const a of t)l[a.get(this.sourceKey,{raw:!0})]=[];for(const a of c)l[a.get(this.foreignKey,{raw:!0})].push(a);return l}async count(t,e){e=f.cloneDeep(e),e.attributes=[[this.sequelize.fn("COUNT",this.sequelize.col(`${this.target.name}.${this.target.primaryKeyField}`)),"count"]],e.raw=!0,e.plain=!0;const i=await this.get(t,e);return parseInt(i.count,10)}async has(t,e,i){const s={};return Array.isArray(e)||(e=[e]),i=y(u({},i),{scope:!1,attributes:[this.target.primaryKeyAttribute],raw:!0}),s[d.or]=e.map(h=>h instanceof this.target?h.where():{[this.target.primaryKeyAttribute]:h}),i.where={[d.and]:[s,i.where]},(await this.get(t,i)).length===e.length}async set(t,e,i){e===null?e=[]:e=this.toInstanceArray(e);const s=await this.get(t,y(u({},i),{scope:!1,raw:!0})),r=[],h=s.filter(n=>!e.find(K=>K[this.target.primaryKeyAttribute]===n[this.target.primaryKeyAttribute])),c=e.filter(n=>!s.find(K=>n[this.target.primaryKeyAttribute]===K[this.target.primaryKeyAttribute]));let l,a;return h.length>0&&(a={},a[this.foreignKey]=null,l={[this.target.primaryKeyAttribute]:h.map(n=>n[this.target.primaryKeyAttribute])},r.push(this.target.unscoped().update(a,y(u({},i),{where:l})))),c.length>0&&(l={},a={},a[this.foreignKey]=t.get(this.sourceKey),Object.assign(a,this.scope),l[this.target.primaryKeyAttribute]=c.map(n=>n[this.target.primaryKeyAttribute]),r.push(this.target.unscoped().update(a,y(u({},i),{where:l})))),await Promise.all(r),t}async add(t,e,i={}){if(!e)return Promise.resolve();e=this.toInstanceArray(e);const s=u({[this.foreignKey]:t.get(this.sourceKey)},this.scope),r={[this.target.primaryKeyAttribute]:e.map(h=>h.get(this.target.primaryKeyAttribute))};return await this.target.unscoped().update(s,y(u({},i),{where:r})),t}async remove(t,e,i={}){const s={[this.foreignKey]:null};e=this.toInstanceArray(e);const r={[this.foreignKey]:t.get(this.sourceKey),[this.target.primaryKeyAttribute]:e.map(h=>h.get(this.target.primaryKeyAttribute))};return await this.target.unscoped().update(s,y(u({},i),{where:r})),this}async create(t,e,i={}){if(Array.isArray(i)&&(i={fields:i}),e===void 0&&(e={}),this.scope)for(const s of Object.keys(this.scope))e[s]=this.scope[s],i.fields&&i.fields.push(s);return e[this.foreignKey]=t.get(this.sourceKey),i.fields&&i.fields.push(this.foreignKey),await this.target.create(e,i)}verifyAssociationAlias(t){return typeof t=="string"?this.as===t:t&&t.plural?this.as===t.plural:!this.isAliased}}O(p,"HasMany"),module.exports=p,module.exports.HasMany=p,module.exports.default=p;
//# sourceMappingURL=has-many.js.map
