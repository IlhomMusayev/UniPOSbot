"use strict";var b=Object.defineProperty,v=Object.defineProperties;var A=Object.getOwnPropertyDescriptors;var E=Object.getOwnPropertySymbols;var D=Object.prototype.hasOwnProperty,S=Object.prototype.propertyIsEnumerable;var T=(n,e,t)=>e in n?b(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,l=(n,e)=>{for(var t in e||(e={}))D.call(e,t)&&T(n,t,e[t]);if(E)for(var t of E(e))S.call(e,t)&&T(n,t,e[t]);return n},k=(n,e)=>v(n,A(e));var p=(n,e)=>b(n,"name",{value:e,configurable:!0});const j=require("url"),M=require("path"),I=require("pg-connection-string"),V=require("retry-as-promised"),f=require("lodash"),h=require("./utils"),O=require("./model"),d=require("./data-types"),Q=require("./deferrable"),x=require("./model-manager"),y=require("./transaction"),m=require("./query-types"),L=require("./table-hints"),$=require("./index-hints"),w=require("./errors"),P=require("./hooks"),H=require("./associations/index"),U=require("./utils/validator-extras").validator,q=require("./operators"),g=require("./utils/deprecations");class r{constructor(e,t,a,s){let o;if(arguments.length===1&&typeof e=="object")s=e,o=f.pick(s,"host","port","database","username","password");else if(arguments.length===1&&typeof e=="string"||arguments.length===2&&typeof t=="object"){o={},s=t||{};const i=j.parse(arguments[0],!0);if(s.dialect=i.protocol.replace(/:$/,""),s.host=i.hostname,s.dialect==="sqlite"&&i.pathname&&!i.pathname.startsWith("/:memory")){const u=M.join(s.host,i.pathname);s.storage=M.resolve(s.storage||u)}if(i.pathname&&(o.database=i.pathname.replace(/^\//,"")),i.port&&(s.port=i.port),i.auth){const u=i.auth.split(":");o.username=u[0],u.length>1&&(o.password=u.slice(1).join(":"))}if(i.query){if(i.query.host&&(s.host=i.query.host),s.dialectOptions)Object.assign(s.dialectOptions,i.query);else if(s.dialectOptions=i.query,i.query.options)try{const u=JSON.parse(i.query.options);s.dialectOptions.options=u}catch(u){}}(s.dialect==="postgres"||s.dialect==="postgresql")&&Object.assign(s.dialectOptions,I.parse(arguments[0]))}else s=s||{},o={database:e,username:t,password:a};if(r.runHooks("beforeInit",o,s),this.options=l({dialect:null,dialectModule:null,dialectModulePath:null,host:"localhost",protocol:"tcp",define:{},query:{},sync:{},timezone:"+00:00",clientMinMessages:"warning",standardConformingStrings:!0,logging:console.log,omitNull:!1,native:!1,replication:!1,ssl:void 0,pool:{},quoteIdentifiers:!0,hooks:{},retry:{max:5,match:["SQLITE_BUSY: database is locked"]},transactionType:y.TYPES.DEFERRED,isolationLevel:null,databaseVersion:0,typeValidation:!1,benchmark:!1,minifyAliases:!1,logQueryParameters:!1},s),!this.options.dialect)throw new Error("Dialect needs to be explicitly supplied as of v4.0.0");if(this.options.dialect==="postgresql"&&(this.options.dialect="postgres"),this.options.dialect==="sqlite"&&this.options.timezone!=="+00:00")throw new Error("Setting a custom timezone is not supported by SQLite, dates are always returned as UTC. Please remove the custom timezone parameter.");this.options.logging===!0&&(g.noTrueLogging(),this.options.logging=console.log),this._setupHooks(s.hooks),this.config={database:o.database||this.options.database,username:o.username||this.options.username,password:o.password||this.options.password||null,host:o.host||this.options.host,port:o.port||this.options.port,pool:this.options.pool,protocol:this.options.protocol,native:this.options.native,ssl:this.options.ssl,replication:this.options.replication,dialectModule:this.options.dialectModule,dialectModulePath:this.options.dialectModulePath,keepDefaultTimezone:this.options.keepDefaultTimezone,dialectOptions:this.options.dialectOptions};let c;switch(this.getDialect()){case"mariadb":c=require("./dialects/mariadb");break;case"mssql":c=require("./dialects/mssql");break;case"mysql":c=require("./dialects/mysql");break;case"postgres":c=require("./dialects/postgres");break;case"sqlite":c=require("./dialects/sqlite");break;default:throw new Error(`The dialect ${this.getDialect()} is not supported. Supported dialects: mssql, mariadb, mysql, postgres, and sqlite.`)}this.dialect=new c(this),this.dialect.queryGenerator.typeValidation=s.typeValidation,f.isPlainObject(this.options.operatorsAliases)?(g.noStringOperators(),this.dialect.queryGenerator.setOperatorsAliases(this.options.operatorsAliases)):typeof this.options.operatorsAliases=="boolean"&&g.noBoolOperatorAliases(),this.queryInterface=this.dialect.queryInterface,this.models={},this.modelManager=new x(this),this.connectionManager=this.dialect.connectionManager,r.runHooks("afterInit",this)}refreshTypes(){this.connectionManager.refreshTypeParser(d)}getDialect(){return this.options.dialect}getDatabaseName(){return this.config.database}getQueryInterface(){return this.queryInterface}define(e,t,a={}){a.modelName=e,a.sequelize=this;const s=p(class extends O{},"model");return s.init(t,a),s}model(e){if(!this.isDefined(e))throw new Error(`${e} has not been defined`);return this.modelManager.getModel(e)}isDefined(e){return!!this.modelManager.models.find(t=>t.name===e)}async query(e,t){if(t=l(l({},this.options.query),t),t.instance&&!t.model&&(t.model=t.instance.constructor),!t.instance&&!t.model&&(t.raw=!0),t.mapToModel&&(t.fieldMap=f.get(t,"model.fieldAttributeMap",{})),t=f.defaults(t,{logging:Object.prototype.hasOwnProperty.call(this.options,"logging")?this.options.logging:console.log,searchPath:Object.prototype.hasOwnProperty.call(this.options,"searchPath")?this.options.searchPath:"DEFAULT"}),t.type||(t.model||t.nest||t.plain?t.type=m.SELECT:t.type=m.RAW),!this.dialect.supports.searchPath||!this.options.dialectOptions||!this.options.dialectOptions.prependSearchPath||t.supportsSearchPath===!1?delete t.searchPath:t.searchPath||(t.searchPath="DEFAULT"),typeof e=="object"){if(e.values!==void 0){if(t.replacements!==void 0)throw new Error("Both `sql.values` and `options.replacements` cannot be set at the same time");t.replacements=e.values}if(e.bind!==void 0){if(t.bind!==void 0)throw new Error("Both `sql.bind` and `options.bind` cannot be set at the same time");t.bind=e.bind}e.query!==void 0&&(e=e.query)}if(e=e.trim(),t.replacements&&t.bind)throw new Error("Both `replacements` and `bind` cannot be set at the same time");t.replacements&&(Array.isArray(t.replacements)?e=h.format([e].concat(t.replacements),this.options.dialect):e=h.formatNamedParameters(e,t.replacements,this.options.dialect));let a;t.bind&&([e,a]=this.dialect.Query.formatBindParameters(e,t.bind,this.options.dialect));const s=p(()=>{if(t.transaction&&t.transaction.finished&&!t.completesTransaction){const c=new Error(`${t.transaction.finished} has been called on this transaction(${t.transaction.id}), you can no longer use it. (The rejected query is attached as the 'sql' property of this error)`);throw c.sql=e,c}},"checkTransaction"),o=l(l({},this.options.retry),t.retry);return V(async()=>{t.transaction===void 0&&r._cls&&(t.transaction=r._cls.get("transaction")),s();const c=await(t.transaction?t.transaction.connection:this.connectionManager.getConnection(t)),i=new this.dialect.Query(c,this,t);try{return await this.runHooks("beforeQuery",t,i),s(),await i.run(e,a)}finally{await this.runHooks("afterQuery",t,i),t.transaction||await this.connectionManager.releaseConnection(c)}},o)}async set(e,t){if(t=l(l({},this.options.set),typeof t=="object"&&t),this.options.dialect!=="mysql")throw new Error("sequelize.set is only supported for mysql");if(!t.transaction||!(t.transaction instanceof y))throw new TypeError("options.transaction is required");t.raw=!0,t.plain=!0,t.type="SET";const a=`SET ${f.map(e,(s,o)=>`@${o} := ${typeof s=="string"?`"${s}"`:s}`).join(", ")}`;return await this.query(a,t)}escape(e){return this.dialect.queryGenerator.escape(e)}async createSchema(e,t){return await this.getQueryInterface().createSchema(e,t)}async showAllSchemas(e){return await this.getQueryInterface().showAllSchemas(e)}async dropSchema(e,t){return await this.getQueryInterface().dropSchema(e,t)}async dropAllSchemas(e){return await this.getQueryInterface().dropAllSchemas(e)}async sync(e){if(e=k(l(l(l({},this.options),this.options.sync),e),{hooks:e?e.hooks!==!1:!0}),e.match&&!e.match.test(this.config.database))throw new Error(`Database "${this.config.database}" does not match sync match parameter "${e.match}"`);e.hooks&&await this.runHooks("beforeBulkSync",e),e.force&&await this.drop(e);const t=[];if(this.modelManager.forEachModel(a=>{a&&t.push(a)}),!t.length)await this.authenticate(e);else for(const a of t)await a.sync(e);return e.hooks&&await this.runHooks("afterBulkSync",e),this}async truncate(e){const t=[];if(this.modelManager.forEachModel(a=>{a&&t.push(a)},{reverse:!1}),e&&e.cascade)for(const a of t)await a.truncate(e);else await Promise.all(t.map(a=>a.truncate(e)))}async drop(e){const t=[];this.modelManager.forEachModel(a=>{a&&t.push(a)},{reverse:!1});for(const a of t)await a.drop(e)}async authenticate(e){e=l({raw:!0,plain:!0,type:m.SELECT},e),await this.query("SELECT 1+1 AS result",e)}async databaseVersion(e){return await this.getQueryInterface().databaseVersion(e)}random(){const e=this.getDialect();return e==="postgres"||e==="sqlite"?this.fn("RANDOM"):this.fn("RAND")}static fn(e,...t){return new h.Fn(e,t)}static col(e){return new h.Col(e)}static cast(e,t){return new h.Cast(e,t)}static literal(e){return new h.Literal(e)}static and(...e){return{[q.and]:e}}static or(...e){return{[q.or]:e}}static json(e,t){return new h.Json(e,t)}static where(e,t,a){return new h.Where(e,t,a)}async transaction(e,t){typeof e=="function"&&(t=e,e=void 0);const a=new y(this,e);return t?r._clsRun(async()=>{try{await a.prepareEnvironment();const s=await t(a);return await a.commit(),await s}catch(s){try{a.finished?await a.cleanup():await a.rollback()}catch(o){}throw s}}):(await a.prepareEnvironment(!1),a)}static useCLS(e){if(!e||typeof e!="object"||typeof e.bind!="function"||typeof e.run!="function")throw new Error("Must provide CLS namespace");return r._cls=e,this}static _clsRun(e){const t=r._cls;if(!t)return e();let a;return t.run(s=>a=e(s)),a}log(...e){let t;const a=f.last(e);a&&f.isPlainObject(a)&&Object.prototype.hasOwnProperty.call(a,"logging")?(t=a,t.logging===console.log&&e.splice(e.length-1,1)):t=this.options,t.logging&&(t.logging===!0&&(g.noTrueLogging(),t.logging=console.log),(this.options.benchmark||t.benchmark)&&t.logging===console.log&&(e=[`${e[0]} Elapsed time: ${e[1]}ms`]),t.logging(...e))}close(){return this.connectionManager.close()}normalizeDataType(e){let t=typeof e=="function"?new e:e;const a=this.dialect.DataTypes||{};if(a[t.key]&&(t=a[t.key].extend(t)),t instanceof d.ARRAY){if(!t.type)throw new Error("ARRAY is missing type definition for its values.");a[t.type.key]&&(t.type=a[t.type.key].extend(t.type))}return t}normalizeAttribute(e){if(f.isPlainObject(e)||(e={type:e}),!e.type)return e;if(e.type=this.normalizeDataType(e.type),Object.prototype.hasOwnProperty.call(e,"defaultValue")&&typeof e.defaultValue=="function"&&(e.defaultValue===d.NOW||e.defaultValue===d.UUIDV1||e.defaultValue===d.UUIDV4)&&(e.defaultValue=new e.defaultValue),e.type instanceof d.ENUM&&(e.values?e.type.values=e.type.options.values=e.values:e.values=e.type.values,!e.values.length))throw new Error("Values for ENUM have not been defined.");return e}}p(r,"Sequelize"),r.prototype.fn=r.fn,r.prototype.col=r.col,r.prototype.cast=r.cast,r.prototype.literal=r.literal,r.prototype.and=r.and,r.prototype.or=r.or,r.prototype.json=r.json,r.prototype.where=r.where,r.prototype.validate=r.prototype.authenticate,Object.defineProperty(r,"version",{enumerable:!0,get(){return require("../../package.json").version}}),r.options={hooks:{}},r.Utils=h,r.Op=q,r.TableHints=L,r.IndexHints=$,r.Transaction=y,r.prototype.Sequelize=r,r.prototype.QueryTypes=r.QueryTypes=m,r.prototype.Validator=r.Validator=U,r.Model=O,r.DataTypes=d;for(const n in d)r[n]=d[n];r.Deferrable=Q,r.prototype.Association=r.Association=H,r.useInflection=h.useInflection,P.applyTo(r),P.applyTo(r.prototype),r.Error=w.BaseError;for(const n of Object.keys(w))r[n]=w[n];module.exports=r,module.exports.Sequelize=r,module.exports.default=r;
//# sourceMappingURL=sequelize.js.map
