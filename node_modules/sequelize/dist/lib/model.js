"use strict";var R=Object.defineProperty,$=Object.defineProperties;var B=Object.getOwnPropertyDescriptors;var H=Object.getOwnPropertySymbols;var U=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable;var M=(I,e,t)=>e in I?R(I,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):I[e]=t,y=(I,e)=>{for(var t in e||(e={}))U.call(e,t)&&M(I,t,e[t]);if(H)for(var t of H(e))L.call(e,t)&&M(I,t,e[t]);return I},N=(I,e)=>$(I,B(e));var v=(I,e)=>R(I,"name",{value:e,configurable:!0});const C=require("assert"),l=require("lodash"),x=require("dottie"),h=require("./utils"),{logger:F}=require("./utils/logger"),z=require("./associations/belongs-to"),T=require("./associations/belongs-to-many"),Q=require("./instance-validator"),P=require("./query-types"),k=require("./errors"),G=require("./associations/base"),W=require("./associations/has-many"),j=require("./data-types"),J=require("./hooks"),Y=require("./associations/mixin"),S=require("./operators"),{noDoubleNestedGroup:X}=require("./utils/deprecations"),Z=new Set(["where","attributes","paranoid","include","order","limit","offset","transaction","lock","raw","logging","benchmark","having","searchPath","rejectOnEmpty","plain","scope","group","through","defaults","distinct","primary","exception","type","hooks","force","name"]),ee=["include","attributes","originalAttributes","order","where","limit","offset","plain","group","having"];class D{static get queryInterface(){return this.sequelize.getQueryInterface()}static get queryGenerator(){return this.queryInterface.queryGenerator}get sequelize(){return this.constructor.sequelize}constructor(e={},t={}){t=y({isNewRecord:!0,_schema:this.constructor._schema,_schemaDelimiter:this.constructor._schemaDelimiter},t),t.attributes&&(t.attributes=t.attributes.map(s=>Array.isArray(s)?s[1]:s)),t.includeValidated||(this.constructor._conformIncludes(t,this.constructor),t.include&&(this.constructor._expandIncludeAll(t),this.constructor._validateIncludedElements(t))),this.dataValues={},this._previousDataValues={},this._changed=new Set,this._options=t||{},this.isNewRecord=t.isNewRecord,this._initValues(e,t)}_initValues(e,t){let s,a;if(e=y({},e),t.isNewRecord){s={},this.constructor._hasDefaultValues&&(s=l.mapValues(this.constructor._defaultValues,r=>{const i=r();return i&&i instanceof h.SequelizeMethod?i:l.cloneDeep(i)})),this.constructor.primaryKeyAttributes.length&&this.constructor.primaryKeyAttributes.forEach(r=>{Object.prototype.hasOwnProperty.call(s,r)||(s[r]=null)}),this.constructor._timestampAttributes.createdAt&&s[this.constructor._timestampAttributes.createdAt]&&(this.dataValues[this.constructor._timestampAttributes.createdAt]=h.toDefaultValue(s[this.constructor._timestampAttributes.createdAt],this.sequelize.options.dialect),delete s[this.constructor._timestampAttributes.createdAt]),this.constructor._timestampAttributes.updatedAt&&s[this.constructor._timestampAttributes.updatedAt]&&(this.dataValues[this.constructor._timestampAttributes.updatedAt]=h.toDefaultValue(s[this.constructor._timestampAttributes.updatedAt],this.sequelize.options.dialect),delete s[this.constructor._timestampAttributes.updatedAt]),this.constructor._timestampAttributes.deletedAt&&s[this.constructor._timestampAttributes.deletedAt]&&(this.dataValues[this.constructor._timestampAttributes.deletedAt]=h.toDefaultValue(s[this.constructor._timestampAttributes.deletedAt],this.sequelize.options.dialect),delete s[this.constructor._timestampAttributes.deletedAt]);for(a in s)e[a]===void 0&&(this.set(a,h.toDefaultValue(s[a],this.sequelize.options.dialect),{raw:!0}),delete e[a])}this.set(e,t)}static _paranoidClause(e,t={}){if(t.include)for(const u of t.include)this._paranoidClause(u.model,u);if(l.get(t,"groupedLimit.on.options.paranoid")){const u=l.get(t,"groupedLimit.on.through.model");u&&(t.groupedLimit.through=this._paranoidClause(u,t.groupedLimit.through))}if(!e.options.timestamps||!e.options.paranoid||t.paranoid===!1)return t;const s=e._timestampAttributes.deletedAt,a=e.rawAttributes[s],r={};let i=Object.prototype.hasOwnProperty.call(a,"defaultValue")?a.defaultValue:null;return i=i||{[S.eq]:null},r[a.field||s]=i,h.isWhereEmpty(t.where)?t.where=r:t.where={[S.and]:[r,t.where]},t}static _addDefaultAttributes(){const e={};let t={};if(!l.some(this.rawAttributes,"primaryKey")){if("id"in this.rawAttributes)throw new Error(`A column called 'id' was added to the attributes of '${this.tableName}' but not marked with 'primaryKey: true'`);t={id:{type:new j.INTEGER,allowNull:!1,primaryKey:!0,autoIncrement:!0,_autoGenerated:!0}}}this._timestampAttributes.createdAt&&(e[this._timestampAttributes.createdAt]={type:j.DATE,allowNull:!1,_autoGenerated:!0}),this._timestampAttributes.updatedAt&&(e[this._timestampAttributes.updatedAt]={type:j.DATE,allowNull:!1,_autoGenerated:!0}),this._timestampAttributes.deletedAt&&(e[this._timestampAttributes.deletedAt]={type:j.DATE,_autoGenerated:!0}),this._versionAttribute&&(e[this._versionAttribute]={type:j.INTEGER,allowNull:!1,defaultValue:0,_autoGenerated:!0});const s=y(y({},t),this.rawAttributes);l.each(e,(a,r)=>{s[r]===void 0&&(s[r]=a)}),this.rawAttributes=s,Object.keys(this.primaryKeys).length||(this.primaryKeys.id=this.rawAttributes.id)}static _findAutoIncrementAttribute(){this.autoIncrementAttribute=null;for(const e in this.rawAttributes)if(Object.prototype.hasOwnProperty.call(this.rawAttributes,e)){const t=this.rawAttributes[e];if(t&&t.autoIncrement){if(this.autoIncrementAttribute)throw new Error("Invalid Instance definition. Only one autoincrement field allowed.");this.autoIncrementAttribute=e}}}static _conformIncludes(e,t){if(!!e.include){if(!Array.isArray(e.include))e.include=[e.include];else if(!e.include.length){delete e.include;return}e.include=e.include.map(s=>this._conformInclude(s,t))}}static _transformStringAssociation(e,t){if(t&&typeof e=="string"){if(!Object.prototype.hasOwnProperty.call(t.associations,e))throw new Error(`Association with alias "${e}" does not exist on ${t.name}`);return t.associations[e]}return e}static _conformInclude(e,t){if(e){let s;if(e._pseudo)return e;if(e=this._transformStringAssociation(e,t),e instanceof G)return t&&e.target.name===t.name?s=e.source:s=e.target,{model:s,association:e,as:e.as};if(e.prototype&&e.prototype instanceof D)return{model:e};if(l.isPlainObject(e)){if(e.association)return e.association=this._transformStringAssociation(e.association,t),t&&e.association.target.name===t.name?s=e.association.source:s=e.association.target,e.model||(e.model=s),e.as||(e.as=e.association.as),this._conformIncludes(e,s),e;if(e.model)return this._conformIncludes(e,e.model),e;if(e.all)return this._conformIncludes(e),e}}throw new Error("Include unexpected. Element has to be either a Model, an Association or an object.")}static _expandIncludeAllElement(e,t){let s=t.all;if(delete t.all,s!==!0){Array.isArray(s)||(s=[s]);const i={BelongsTo:!0,HasOne:!0,HasMany:!0,One:["BelongsTo","HasOne"],Has:["HasOne","HasMany"],Many:["HasMany"]};for(let u=0;u<s.length;u++){const n=s[u];if(n==="All"){s=!0;break}const c=i[n];if(!c)throw new k.EagerLoadingError(`include all '${n}' is not valid - must be BelongsTo, HasOne, HasMany, One, Has, Many or All`);if(c!==!0){s.splice(u,1),u--;for(let o=0;o<c.length;o++)s.includes(c[o])||(s.unshift(c[o]),u++)}}}const a=t.nested;a&&(delete t.nested,t.include?Array.isArray(t.include)||(t.include=[t.include]):t.include=[]);const r=[];v(function i(u,n){l.forEach(u.associations,c=>{if(s!==!0&&!s.includes(c.associationType))return;const o=c.target,g=c.options.as,d={model:o};if(g&&(d.as=g),l.some(n,d)||a&&r.includes(o))return;r.push(u);const b=h.cloneDeep(t);b.model=o,g&&(b.as=g),n.push(b),a&&(i(o,b.include),b.include.length===0&&delete b.include)}),r.pop()},"addAllIncludes")(this,e)}static _validateIncludedElements(e,t){e.model||(e.model=this),t=t||{},e.includeNames=[],e.includeMap={},e.hasSingleAssociation=!1,e.hasMultiAssociation=!1,e.parent||(e.topModel=e.model,e.topLimit=e.limit),e.include=e.include.map(s=>(s=this._conformInclude(s),s.parent=e,s.topLimit=e.topLimit,this._validateIncludedElement.call(e.model,s,t,e),s.duplicating===void 0&&(s.duplicating=s.association.isMultiAssociation),s.hasDuplicating=s.hasDuplicating||s.duplicating,s.hasRequired=s.hasRequired||s.required,e.hasDuplicating=e.hasDuplicating||s.hasDuplicating,e.hasRequired=e.hasRequired||s.required,e.hasWhere=e.hasWhere||s.hasWhere||!!s.where,s));for(const s of e.include)s.hasParentWhere=e.hasParentWhere||!!e.where,s.hasParentRequired=e.hasParentRequired||!!e.required,s.subQuery!==!1&&e.hasDuplicating&&e.topLimit?s.duplicating?(s.subQuery=s.subQuery||!1,s.subQueryFilter=s.hasRequired):(s.subQuery=s.hasRequired,s.subQueryFilter=!1):(s.subQuery=s.subQuery||!1,s.duplicating?s.subQueryFilter=s.subQuery:(s.subQueryFilter=!1,s.subQuery=s.subQuery||s.hasParentRequired&&s.hasRequired&&!s.separate)),e.includeMap[s.as]=s,e.includeNames.push(s.as),e.topModel===e.model&&e.subQuery===void 0&&e.topLimit&&(s.subQuery?e.subQuery=s.subQuery:s.hasDuplicating&&(e.subQuery=!0)),e.hasIncludeWhere=e.hasIncludeWhere||s.hasIncludeWhere||!!s.where,e.hasIncludeRequired=e.hasIncludeRequired||s.hasIncludeRequired||!!s.required,(s.association.isMultiAssociation||s.hasMultiAssociation)&&(e.hasMultiAssociation=!0),(s.association.isSingleAssociation||s.hasSingleAssociation)&&(e.hasSingleAssociation=!0);return e.topModel===e.model&&e.subQuery===void 0&&(e.subQuery=!1),e}static _validateIncludedElement(e,t,s){if(t[e.model.getTableName()]=!0,e.attributes&&!s.raw?(e.model._expandAttributes(e),e.originalAttributes=e.model._injectDependentVirtualAttributes(e.attributes),e=h.mapFinderOptions(e,e.model),e.attributes.length&&l.each(e.model.primaryKeys,(i,u)=>{e.attributes.some(n=>i.field!==u?Array.isArray(n)&&n[0]===i.field&&n[1]===u:n===u)||e.attributes.unshift(u)})):e=h.mapFinderOptions(e,e.model),e._pseudo)return e.attributes||(e.attributes=Object.keys(e.model.tableAttributes)),h.mapFinderOptions(e,e.model);const a=e.association||this._getIncludedAssociation(e.model,e.as);if(e.association=a,e.as=a.as,e.association.through&&Object(e.association.through.model)===e.association.through.model){e.include||(e.include=[]);const i=e.association.through;e.through=l.defaults(e.through||{},{model:i.model,as:i.model.name,association:{isSingleAssociation:!0},_pseudo:!0,parent:e}),i.scope&&(e.through.where=e.through.where?{[S.and]:[e.through.where,i.scope]}:i.scope),e.include.push(e.through),t[i.tableName]=!0}let r;if(e.model.scoped===!0?r=e.model:r=e.association.target.name===e.model.name?e.association.target:e.association.source,r._injectScope(e),e.attributes||(e.attributes=Object.keys(e.model.tableAttributes)),e=h.mapFinderOptions(e,e.model),e.required===void 0&&(e.required=!!e.where),e.association.scope&&(e.where=e.where?{[S.and]:[e.where,e.association.scope]}:e.association.scope),e.limit&&e.separate===void 0&&(e.separate=!0),e.separate===!0){if(!(e.association instanceof W))throw new Error("Only HasMany associations support include.separate");e.duplicating=!1,s.attributes&&s.attributes.length&&!l.flattenDepth(s.attributes,2).includes(a.sourceKey)&&s.attributes.push(a.sourceKey),e.attributes&&e.attributes.length&&!l.flattenDepth(e.attributes,2).includes(a.foreignKey)&&e.attributes.push(a.foreignKey)}return Object.prototype.hasOwnProperty.call(e,"include")&&this._validateIncludedElements.call(e.model,e,t),e}static _getIncludedAssociation(e,t){const s=this.getAssociations(e);let a=null;if(s.length===0)throw new k.EagerLoadingError(`${e.name} is not associated to ${this.name}!`);if(s.length===1){if(a=this.getAssociationForAlias(e,t),a)return a;if(t){const r=this.getAssociations(e).map(i=>i.as);throw new k.EagerLoadingError(`${e.name} is associated to ${this.name} using an alias. You've included an alias (${t}), but it does not match the alias(es) defined in your association (${r.join(", ")}).`)}throw new k.EagerLoadingError(`${e.name} is associated to ${this.name} using an alias. You must use the 'as' keyword to specify the alias within your include statement.`)}if(a=this.getAssociationForAlias(e,t),!a)throw new k.EagerLoadingError(`${e.name} is associated to ${this.name} multiple times. To identify the correct association, you must use the 'as' keyword to specify the alias of the association you want to include.`);return a}static _expandIncludeAll(e){const t=e.include;if(!!t){for(let s=0;s<t.length;s++){const a=t[s];a.all&&(t.splice(s,1),s--,this._expandIncludeAllElement(t,a))}t.forEach(s=>{this._expandIncludeAll.call(s.model,s)})}}static _conformIndex(e){if(!e.fields)throw new Error('Missing "fields" property for index definition');return e=l.defaults(e,{type:"",parser:null}),e.type&&e.type.toLowerCase()==="unique"&&(e.unique=!0,delete e.type),e}static _uniqIncludes(e){!e.include||(e.include=l(e.include).groupBy(t=>`${t.model&&t.model.name}-${t.as}`).map(t=>this._assignOptions(...t)).value())}static _baseMerge(...e){return l.assignWith(...e),this._conformIncludes(e[0],this),this._uniqIncludes(e[0]),e[0]}static _mergeFunction(e,t,s){if(Array.isArray(e)&&Array.isArray(t))return l.union(e,t);if(s==="where"||s==="having"){if(t instanceof h.SequelizeMethod&&(t={[S.and]:t}),l.isPlainObject(e)&&l.isPlainObject(t))return Object.assign(e,t)}else if(s==="attributes"&&l.isPlainObject(e)&&l.isPlainObject(t))return l.assignWith(e,t,(a,r)=>{if(Array.isArray(a)&&Array.isArray(r))return l.union(a,r)});return t?h.cloneDeep(t,!0):t===void 0?e:t}static _assignOptions(...e){return this._baseMerge(...e,this._mergeFunction)}static _defaultsOptions(e,t){return this._baseMerge(e,t,(s,a,r)=>this._mergeFunction(a,s,r))}static init(e,t={}){if(!t.sequelize)throw new Error("No Sequelize instance passed");this.sequelize=t.sequelize;const s=this.sequelize.options;t=h.merge(l.cloneDeep(s.define),t),t.modelName||(t.modelName=this.name),t=h.merge({name:{plural:h.pluralize(t.modelName),singular:h.singularize(t.modelName)},indexes:[],omitNull:s.omitNull,schema:s.schema},t),this.sequelize.runHooks("beforeDefine",e,t),t.modelName!==this.name&&Object.defineProperty(this,"name",{value:t.modelName}),delete t.modelName,this.options=y({timestamps:!0,validate:{},freezeTableName:!1,underscored:!1,paranoid:!1,rejectOnEmpty:!1,whereCollection:null,schema:null,schemaDelimiter:"",defaultScope:{},scopes:{},indexes:[]},t),this.sequelize.isDefined(this.name)&&this.sequelize.modelManager.removeModel(this.sequelize.modelManager.getModel(this.name)),this.associations={},this._setupHooks(t.hooks),this.underscored=this.options.underscored,this.options.tableName?this.tableName=this.options.tableName:this.tableName=this.options.freezeTableName?this.name:h.underscoredIf(h.pluralize(this.name),this.underscored),this._schema=this.options.schema,this._schemaDelimiter=this.options.schemaDelimiter,l.each(t.validate,(r,i)=>{if(Object.prototype.hasOwnProperty.call(e,i))throw new Error(`A model validator function must not have the same name as a field. Model: ${this.name}, field/validation name: ${i}`);if(typeof r!="function")throw new Error(`Members of the validate option must be functions. Model: ${this.name}, error with validate member ${i}`)}),this.rawAttributes=l.mapValues(e,(r,i)=>{if(r=this.sequelize.normalizeAttribute(r),r.type===void 0)throw new Error(`Unrecognized datatype for attribute "${this.name}.${i}"`);if(r.allowNull!==!1&&l.get(r,"validate.notNull"))throw new Error(`Invalid definition for "${this.name}.${i}", "notNull" validator is only allowed with "allowNull:false"`);return l.get(r,"references.model.prototype")instanceof D&&(r.references.model=r.references.model.getTableName()),r});const a=this.getTableName();if(this._indexes=this.options.indexes.map(r=>h.nameIndex(this._conformIndex(r),a)),this.primaryKeys={},this._readOnlyAttributes=new Set,this._timestampAttributes={},this.options.timestamps){for(const r of["createdAt","updatedAt","deletedAt"]){if(!["undefined","string","boolean"].includes(typeof this.options[r]))throw new Error(`Value for "${r}" option must be a string or a boolean, got ${typeof this.options[r]}`);if(this.options[r]==="")throw new Error(`Value for "${r}" option cannot be an empty string`)}this.options.createdAt!==!1&&(this._timestampAttributes.createdAt=typeof this.options.createdAt=="string"?this.options.createdAt:"createdAt",this._readOnlyAttributes.add(this._timestampAttributes.createdAt)),this.options.updatedAt!==!1&&(this._timestampAttributes.updatedAt=typeof this.options.updatedAt=="string"?this.options.updatedAt:"updatedAt",this._readOnlyAttributes.add(this._timestampAttributes.updatedAt)),this.options.paranoid&&this.options.deletedAt!==!1&&(this._timestampAttributes.deletedAt=typeof this.options.deletedAt=="string"?this.options.deletedAt:"deletedAt",this._readOnlyAttributes.add(this._timestampAttributes.deletedAt))}return this.options.version&&(this._versionAttribute=typeof this.options.version=="string"?this.options.version:"version",this._readOnlyAttributes.add(this._versionAttribute)),this._hasReadOnlyAttributes=this._readOnlyAttributes.size>0,this._addDefaultAttributes(),this.refreshAttributes(),this._findAutoIncrementAttribute(),this._scope=this.options.defaultScope,this._scopeNames=["defaultScope"],this.sequelize.modelManager.addModel(this),this.sequelize.runHooks("afterDefine",this),this}static refreshAttributes(){const e={};this.prototype._customGetters={},this.prototype._customSetters={},["get","set"].forEach(t=>{const s=`${t}terMethods`,a=y({},this.options[s]),r=t==="get"?this.prototype._customGetters:this.prototype._customSetters;l.each(a,(i,u)=>{r[u]=i,t==="get"&&(a[u]=function(){return this.get(u)}),t==="set"&&(a[u]=function(n){return this.set(u,n)})}),l.each(this.rawAttributes,(i,u)=>{Object.prototype.hasOwnProperty.call(i,t)&&(r[u]=i[t]),t==="get"&&(a[u]=function(){return this.get(u)}),t==="set"&&(a[u]=function(n){return this.set(u,n)})}),l.each(a,(i,u)=>{e[u]||(e[u]={configurable:!0}),e[u][t]=i})}),this._dataTypeChanges={},this._dataTypeSanitizers={},this._hasBooleanAttributes=!1,this._hasDateAttributes=!1,this._jsonAttributes=new Set,this._virtualAttributes=new Set,this._defaultValues={},this.prototype.validators={},this.fieldRawAttributesMap={},this.primaryKeys={},this.uniqueKeys={},l.each(this.rawAttributes,(t,s)=>{if(t.type=this.sequelize.normalizeDataType(t.type),t.Model=this,t.fieldName=s,t._modelAttribute=!0,t.field===void 0&&(t.field=h.underscoredIf(s,this.underscored)),t.primaryKey===!0&&(this.primaryKeys[s]=t),this.fieldRawAttributesMap[t.field]=t,t.type._sanitize&&(this._dataTypeSanitizers[s]=t.type._sanitize),t.type._isChanged&&(this._dataTypeChanges[s]=t.type._isChanged),t.type instanceof j.BOOLEAN?this._hasBooleanAttributes=!0:t.type instanceof j.DATE||t.type instanceof j.DATEONLY?this._hasDateAttributes=!0:t.type instanceof j.JSON?this._jsonAttributes.add(s):t.type instanceof j.VIRTUAL&&this._virtualAttributes.add(s),Object.prototype.hasOwnProperty.call(t,"defaultValue")&&(this._defaultValues[s]=()=>h.toDefaultValue(t.defaultValue,this.sequelize.options.dialect)),Object.prototype.hasOwnProperty.call(t,"unique")&&t.unique){let a;typeof t.unique=="object"&&Object.prototype.hasOwnProperty.call(t.unique,"name")?a=t.unique.name:typeof t.unique=="string"?a=t.unique:a=`${this.tableName}_${s}_unique`;const r=this.uniqueKeys[a]||{fields:[]};r.fields.push(t.field),r.msg=r.msg||t.unique.msg||null,r.name=a||!1,r.column=s,r.customIndex=t.unique!==!0,this.uniqueKeys[a]=r}Object.prototype.hasOwnProperty.call(t,"validate")&&(this.prototype.validators[s]=t.validate),t.index===!0&&t.type instanceof j.JSONB&&(this._indexes.push(h.nameIndex(this._conformIndex({fields:[t.field||s],using:"gin"}),this.getTableName())),delete t.index)}),this.fieldAttributeMap=l.reduce(this.fieldRawAttributesMap,(t,s,a)=>(a!==s.fieldName&&(t[a]=s.fieldName),t),{}),this._hasJsonAttributes=!!this._jsonAttributes.size,this._hasVirtualAttributes=!!this._virtualAttributes.size,this._hasDefaultValues=!l.isEmpty(this._defaultValues),this.tableAttributes=l.omitBy(this.rawAttributes,(t,s)=>this._virtualAttributes.has(s)),this.prototype._hasCustomGetters=Object.keys(this.prototype._customGetters).length,this.prototype._hasCustomSetters=Object.keys(this.prototype._customSetters).length;for(const t of Object.keys(e)){if(Object.prototype.hasOwnProperty.call(D.prototype,t)){this.sequelize.log(`Not overriding built-in method from model attribute: ${t}`);continue}Object.defineProperty(this.prototype,t,e[t])}this.prototype.rawAttributes=this.rawAttributes,this.prototype._isAttribute=t=>Object.prototype.hasOwnProperty.call(this.prototype.rawAttributes,t),this.primaryKeyAttributes=Object.keys(this.primaryKeys),this.primaryKeyAttribute=this.primaryKeyAttributes[0],this.primaryKeyAttribute&&(this.primaryKeyField=this.rawAttributes[this.primaryKeyAttribute].field||this.primaryKeyAttribute),this._hasPrimaryKeys=this.primaryKeyAttributes.length>0,this._isPrimaryKey=t=>this.primaryKeyAttributes.includes(t)}static removeAttribute(e){delete this.rawAttributes[e],this.refreshAttributes()}static async sync(e){e=y(y({},this.options),e),e.hooks=e.hooks===void 0?!0:!!e.hooks;const t=this.tableAttributes,s=this.fieldRawAttributesMap;e.hooks&&await this.runHooks("beforeSync",e),e.force&&await this.drop(e);const a=this.getTableName(e);if(await this.queryInterface.createTable(a,t,e,this),e.alter){const i=await Promise.all([this.queryInterface.describeTable(a,e),this.queryInterface.getForeignKeyReferencesForTable(a,e)]),u=i[0],n=i[1],c={};for(const o in t)!Object.prototype.hasOwnProperty.call(t,o)||!u[o]&&!u[t[o].field]&&await this.queryInterface.addColumn(a,t[o].field||o,t[o],e);if(e.alter===!0||typeof e.alter=="object"&&e.alter.drop!==!1)for(const o in u){if(!Object.prototype.hasOwnProperty.call(u,o))continue;const g=s[o];if(!g){await this.queryInterface.removeColumn(a,o,e);continue}if(g.primaryKey)continue;const d=g.references;if(g.references){const b=this.sequelize.config.database,m=this.sequelize.config.schema;for(const w of n){const A=w.constraintName;!!A&&w.tableCatalog===b&&(m?w.tableSchema===m:!0)&&w.referencedTableName===d.model&&w.referencedColumnName===d.key&&(m?w.referencedTableSchema===m:!0)&&!c[A]&&(await this.queryInterface.removeConstraint(a,A,e),c[A]=!0)}}await this.queryInterface.changeColumn(a,o,g,e)}}let r=await this.queryInterface.showIndex(a,e);r=this._indexes.filter(i=>!r.some(u=>i.name===u.name)).sort((i,u)=>{if(this.sequelize.options.dialect==="postgres"){if(i.concurrently===!0)return 1;if(u.concurrently===!0)return-1}return 0});for(const i of r)await this.queryInterface.addIndex(a,y(y({},e),i));return e.hooks&&await this.runHooks("afterSync",e),this}static async drop(e){return await this.queryInterface.dropTable(this.getTableName(e),e)}static async dropSchema(e){return await this.queryInterface.dropSchema(e)}static schema(e,t){const s=v(class extends this{},"clone");return Object.defineProperty(s,"name",{value:this.name}),s._schema=e,t&&(typeof t=="string"?s._schemaDelimiter=t:t.schemaDelimiter&&(s._schemaDelimiter=t.schemaDelimiter)),s}static getTableName(){return this.queryGenerator.addSchema(this)}static unscoped(){return this.scope()}static addScope(e,t,s){if(s=y({override:!1},s),(e==="defaultScope"&&Object.keys(this.options.defaultScope).length>0||e in this.options.scopes)&&s.override===!1)throw new Error(`The scope ${e} already exists. Pass { override: true } as options to silence this error`);e==="defaultScope"?this.options.defaultScope=this._scope=t:this.options.scopes[e]=t}static scope(e){const t=v(class extends this{},"self");let s,a;if(Object.defineProperty(t,"name",{value:this.name}),t._scope={},t._scopeNames=[],t.scoped=!0,!e)return t;const r=l.flatten(arguments);for(const i of r)if(s=null,a=null,l.isPlainObject(i)?i.method?Array.isArray(i.method)&&!!t.options.scopes[i.method[0]]?(a=i.method[0],s=t.options.scopes[a].apply(t,i.method.slice(1))):t.options.scopes[i.method]&&(a=i.method,s=t.options.scopes[a].apply(t)):s=i:i==="defaultScope"&&l.isPlainObject(t.options.defaultScope)?s=t.options.defaultScope:(a=i,s=t.options.scopes[a],typeof s=="function"&&(s=s())),s)this._conformIncludes(s,this),this._assignOptions(t._scope,h.cloneDeep(s)),t._scopeNames.push(a||"defaultScope");else throw new k.SequelizeScopeError(`Invalid scope ${a} called.`);return t}static async findAll(e){if(e!==void 0&&!l.isPlainObject(e))throw new k.QueryError("The argument passed to findAll must be an options object, use findByPk if you wish to pass a single primary key value");if(e!==void 0&&e.attributes&&!Array.isArray(e.attributes)&&!l.isPlainObject(e.attributes))throw new k.QueryError("The attributes option must be an array of column names or an object");this.warnOnInvalidOptions(e,Object.keys(this.rawAttributes));const t={};t[this.getTableName(e)]=!0,e=h.cloneDeep(e),l.defaults(e,{hooks:!0}),e.rejectOnEmpty=Object.prototype.hasOwnProperty.call(e,"rejectOnEmpty")?e.rejectOnEmpty:this.options.rejectOnEmpty,this._injectScope(e),e.hooks&&await this.runHooks("beforeFind",e),this._conformIncludes(e,this),this._expandAttributes(e),this._expandIncludeAll(e),e.hooks&&await this.runHooks("beforeFindAfterExpandIncludeAll",e),e.originalAttributes=this._injectDependentVirtualAttributes(e.attributes),e.include&&(e.hasJoin=!0,this._validateIncludedElements(e,t),e.attributes&&!e.raw&&this.primaryKeyAttribute&&!e.attributes.includes(this.primaryKeyAttribute)&&(!e.group||!e.hasSingleAssociation||e.hasMultiAssociation)&&(e.attributes=[this.primaryKeyAttribute].concat(e.attributes))),e.attributes||(e.attributes=Object.keys(this.rawAttributes),e.originalAttributes=this._injectDependentVirtualAttributes(e.attributes)),this.options.whereCollection=e.where||null,h.mapFinderOptions(e,this),e=this._paranoidClause(this,e),e.hooks&&await this.runHooks("beforeFindAfterOptions",e);const s=N(y({},e),{tableNames:Object.keys(t)}),a=await this.queryInterface.select(this,this.getTableName(s),s);if(e.hooks&&await this.runHooks("afterFind",a,e),l.isEmpty(a)&&e.rejectOnEmpty)throw typeof e.rejectOnEmpty=="function"?new e.rejectOnEmpty:typeof e.rejectOnEmpty=="object"?e.rejectOnEmpty:new k.EmptyResultError;return await D._findSeparate(a,e)}static warnOnInvalidOptions(e,t){if(!l.isPlainObject(e))return;const s=Object.keys(e).filter(r=>!Z.has(r)),a=l.intersection(s,t);!e.where&&a.length>0&&F.warn(`Model attributes (${a.join(", ")}) passed into finder method options of model ${this.name}, but the options.where object is empty. Did you forget to use options.where?`)}static _injectDependentVirtualAttributes(e){if(!this._hasVirtualAttributes||!e||!Array.isArray(e))return e;for(const t of e)this._virtualAttributes.has(t)&&this.rawAttributes[t].type.fields&&(e=e.concat(this.rawAttributes[t].type.fields));return e=l.uniq(e),e}static async _findSeparate(e,t){if(!t.include||t.raw||!e)return e;const s=e;return t.plain&&(e=[e]),e.length&&await Promise.all(t.include.map(async a=>{if(!a.separate)return await D._findSeparate(e.reduce((i,u)=>{let n=u.get(a.association.as);if(!n)return i;Array.isArray(n)||(n=[n]);for(let c=0,o=n.length;c!==o;++c)i.push(n[c]);return i},[]),N(y({},l.omit(t,"include","attributes","order","where","limit","offset","plain","scope")),{include:a.include||[]}));const r=await a.association.get(e,y(y({},l.omit(t,ee)),l.omit(a,["parent","association","as","originalAttributes"])));for(const i of e)i.set(a.association.as,r[i.get(a.association.sourceKey)],{raw:!0})})),s}static async findByPk(e,t){if([null,void 0].includes(e))return null;if(t=h.cloneDeep(t)||{},typeof e=="number"||typeof e=="string"||Buffer.isBuffer(e))t.where={[this.primaryKeyAttribute]:e};else throw new Error(`Argument passed to findByPk is invalid: ${e}`);return await this.findOne(t)}static async findOne(e){if(e!==void 0&&!l.isPlainObject(e))throw new Error("The argument passed to findOne must be an options object, use findByPk if you wish to pass a single primary key value");if(e=h.cloneDeep(e),e.limit===void 0){const t=l.chain(this.uniqueKeys).values().filter(s=>s.fields.length===1).map("column").value();(!e.where||!l.some(e.where,(s,a)=>(a===this.primaryKeyAttribute||t.includes(a))&&(h.isPrimitive(s)||Buffer.isBuffer(s))))&&(e.limit=1)}return await this.findAll(l.defaults(e,{plain:!0}))}static async aggregate(e,t,s){s=h.cloneDeep(s);const a=s.attributes;this._injectScope(s),s.attributes=a,this._conformIncludes(s,this),s.include&&(this._expandIncludeAll(s),this._validateIncludedElements(s));const r=this.rawAttributes[e],i=r&&r.field||e;let u=this.sequelize.col(i);s.distinct&&(u=this.sequelize.fn("DISTINCT",u));let{group:n}=s;return Array.isArray(n)&&Array.isArray(n[0])&&(X(),n=l.flatten(n)),s.attributes=l.unionBy(s.attributes,n,[[this.sequelize.fn(t,u),t]],o=>Array.isArray(o)?o[1]:o),s.dataType?s.dataType=this.sequelize.normalizeDataType(s.dataType):r?s.dataType=r.type:s.dataType=new j.FLOAT,h.mapOptionFieldNames(s,this),s=this._paranoidClause(this,s),await this.queryInterface.rawSelect(this.getTableName(s),s,t,this)}static async count(e){e=h.cloneDeep(e),e=l.defaults(e,{hooks:!0}),e.raw=!0,e.hooks&&await this.runHooks("beforeCount",e);let t=e.col||"*";e.include&&(t=`${this.name}.${e.col||this.primaryKeyField}`),e.distinct&&t==="*"&&(t=this.primaryKeyField),e.plain=!e.group,e.dataType=new j.INTEGER,e.includeIgnoreAttributes=!1,e.limit=null,e.offset=null,e.order=null;const s=await this.aggregate(t,"count",e);return Array.isArray(s)?s.map(a=>N(y({},a),{count:Number(a.count)})):s}static async findAndCountAll(e){if(e!==void 0&&!l.isPlainObject(e))throw new Error("The argument passed to findAndCountAll must be an options object, use findByPk if you wish to pass a single primary key value");const t=h.cloneDeep(e);t.attributes&&(t.attributes=void 0);const[s,a]=await Promise.all([this.count(t),this.findAll(e)]);return{count:s,rows:s===0?[]:a}}static async max(e,t){return await this.aggregate(e,"max",t)}static async min(e,t){return await this.aggregate(e,"min",t)}static async sum(e,t){return await this.aggregate(e,"sum",t)}static build(e,t){return Array.isArray(e)?this.bulkBuild(e,t):new this(e,t)}static bulkBuild(e,t){return t=y({isNewRecord:!0},t),t.includeValidated||(this._conformIncludes(t,this),t.include&&(this._expandIncludeAll(t),this._validateIncludedElements(t))),t.attributes&&(t.attributes=t.attributes.map(s=>Array.isArray(s)?s[1]:s)),e.map(s=>this.build(s,t))}static async create(e,t){return t=h.cloneDeep(t||{}),await this.build(e,{isNewRecord:!0,attributes:t.fields,include:t.include,raw:t.raw,silent:t.silent}).save(t)}static async findOrBuild(e){if(!e||!e.where||arguments.length>1)throw new Error("Missing where attribute in the options parameter passed to findOrBuild. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)");let t,s=await this.findOne(e);return s===null?(t=y({},e.defaults),l.isPlainObject(e.where)&&(t=h.defaults(t,e.where)),s=this.build(t,e),[s,!0]):[s,!1]}static async findOrCreate(e){if(!e||!e.where||arguments.length>1)throw new Error("Missing where attribute in the options parameter passed to findOrCreate. Please note that the API has changed, and is now options only (an object with where, defaults keys, transaction etc.)");if(e=y({},e),e.defaults){const i=Object.keys(e.defaults).filter(u=>!this.rawAttributes[u]);i.length&&F.warn(`Unknown attributes (${i}) passed to defaults option of findOrCreate`)}if(e.transaction===void 0&&this.sequelize.constructor._cls){const r=this.sequelize.constructor._cls.get("transaction");r&&(e.transaction=r)}const t=!e.transaction;let s,a;try{const r=await this.sequelize.transaction(e);a=r,e.transaction=r;const i=await this.findOne(h.defaults({transaction:a},e));if(i!==null)return[i,!1];s=y({},e.defaults),l.isPlainObject(e.where)&&(s=h.defaults(s,e.where)),e.exception=!0,e.returning=!0;try{const u=await this.create(s,e);if(u.get(this.primaryKeyAttribute,{raw:!0})===null)throw new k.UniqueConstraintError;return[u,!0]}catch(u){if(!(u instanceof k.UniqueConstraintError))throw u;const n=h.flattenObjectDeep(e.where),o=Object.keys(n).map(w=>l.last(w.split("."))).map(w=>l.get(this.rawAttributes,`${w}.field`,w)),g=e.defaults&&Object.keys(e.defaults).filter(w=>this.rawAttributes[w]).map(w=>this.rawAttributes[w].field||w),d=Object.keys(u.fields),b=h.intersects(d,o);if(g&&!b&&h.intersects(d,g))throw u;b&&l.each(u.fields,(w,A)=>{const _=this.fieldRawAttributesMap[A].fieldName;if(w.toString()!==e.where[_].toString())throw new Error(`${this.name}#findOrCreate: value used for ${_} was not equal for both the find and the create calls, '${e.where[_]}' vs '${w}'`)});const m=await this.findOne(h.defaults({transaction:t?null:a},e));if(m===null)throw u;return[m,!1]}}finally{t&&a&&await a.commit()}}static async findCreateFind(e){if(!e||!e.where)throw new Error("Missing where attribute in the options parameter passed to findCreateFind.");let t=y({},e.defaults);l.isPlainObject(e.where)&&(t=h.defaults(t,e.where));const s=await this.findOne(e);if(s)return[s,!1];try{const a=y({},e);return this.sequelize.options.dialect==="postgres"&&e.transaction&&(a.ignoreDuplicates=!0),[await this.create(t,a),!0]}catch(a){if(!(a instanceof k.UniqueConstraintError||a instanceof k.EmptyResultError))throw a;return[await this.findOne(e),!1]}}static async upsert(e,t){t=y({hooks:!0,returning:!0,validate:!0},h.cloneDeep(t));const s=this._timestampAttributes.createdAt,a=this._timestampAttributes.updatedAt,r=this.primaryKeyField in e||this.primaryKeyAttribute in e,i=this.build(e);t.model=this,t.instance=i;const u=Array.from(i._changed);t.fields||(t.fields=u),t.validate&&await i.validate(t);const n=l.pick(i.dataValues,u),c=h.mapValueFieldNames(i.dataValues,Object.keys(i.rawAttributes),this),o=h.mapValueFieldNames(n,t.fields,this),g=h.now(this.sequelize.options.dialect);if(s&&!c[s]){const m=this.rawAttributes[s].field||s;c[m]=this._getDefaultTimestamp(s)||g}if(a&&!c[a]){const m=this.rawAttributes[a].field||a;c[m]=o[m]=this._getDefaultTimestamp(a)||g}!r&&this.primaryKeyAttribute&&!this.rawAttributes[this.primaryKeyAttribute].defaultValue&&(delete c[this.primaryKeyField],delete o[this.primaryKeyField]),t.hooks&&await this.runHooks("beforeUpsert",e,t);const d=await this.queryInterface.upsert(this.getTableName(t),c,o,i.where(),t),[b]=d;return b.isNewRecord=!1,t.hooks&&await this.runHooks("afterUpsert",d,t),d}static async bulkCreate(e,t={}){if(!e.length)return[];const s=this.sequelize.options.dialect,a=h.now(this.sequelize.options.dialect);t=h.cloneDeep(t),t.model=this,t.includeValidated||(this._conformIncludes(t,this),t.include&&(this._expandIncludeAll(t),this._validateIncludedElements(t)));const r=e.map(u=>this.build(u,{isNewRecord:!0,include:t.include})),i=v(async(u,n)=>{if(n=y({validate:!1,hooks:!0,individualHooks:!1,ignoreDuplicates:!1},n),n.returning===void 0&&(n.association?n.returning=!1:n.returning=!0),n.ignoreDuplicates&&["mssql"].includes(s))throw new Error(`${s} does not support the ignoreDuplicates option.`);if(n.updateOnDuplicate&&s!=="mysql"&&s!=="mariadb"&&s!=="sqlite"&&s!=="postgres")throw new Error(`${s} does not support the updateOnDuplicate option.`);const c=n.model;n.fields=n.fields||Object.keys(c.rawAttributes);const o=c._timestampAttributes.createdAt,g=c._timestampAttributes.updatedAt;if(n.updateOnDuplicate!==void 0)if(Array.isArray(n.updateOnDuplicate)&&n.updateOnDuplicate.length)n.updateOnDuplicate=l.intersection(l.without(Object.keys(c.tableAttributes),o),n.updateOnDuplicate);else throw new Error("updateOnDuplicate option only supports non-empty array.");if(n.hooks&&await c.runHooks("beforeBulkCreate",u,n),n.validate){const d=[],b=y({},n);if(b.hooks=n.individualHooks,await Promise.all(u.map(async m=>{try{await m.validate(b)}catch(w){d.push(new k.BulkRecordError(w,m))}})),delete n.skip,d.length)throw new k.AggregateError(d)}if(n.individualHooks)await Promise.all(u.map(async d=>{const b=N(y({},n),{validate:!1,hooks:!0});delete b.fields,delete b.individualHooks,delete b.ignoreDuplicates,await d.save(b)}));else{n.include&&n.include.length&&await Promise.all(n.include.filter(m=>m.association instanceof z).map(async m=>{const w=[],A=[];for(const p of u){const O=p.get(m.as);O&&(w.push(O),A.push(p))}if(!w.length)return;const _=l(h.cloneDeep(m)).omit(["association"]).defaults({transaction:n.transaction,logging:n.logging}).value(),f=await i(w,_);for(const p in f){const O=f[p],q=A[p];await m.association.set(q,O,{save:!1,logging:n.logging})}})),e=u.map(m=>{const w=m.dataValues;o&&!w[o]&&(w[o]=a,n.fields.includes(o)||n.fields.push(o)),g&&!w[g]&&(w[g]=a,n.fields.includes(g)||n.fields.push(g));const A=h.mapValueFieldNames(w,n.fields,c);for(const _ of c._virtualAttributes)delete A[_];return A});const d={};for(const m in c.tableAttributes)d[c.rawAttributes[m].field||m]=c.rawAttributes[m];if(n.updateOnDuplicate){n.updateOnDuplicate=n.updateOnDuplicate.map(A=>c.rawAttributes[A].field||A);const m=[];for(const A of c._indexes)A.unique&&!A.where&&m.push(...A.fields);const w=Object.values(c.uniqueKeys).find(A=>A.fields.length>0);w&&w.fields&&m.push(...w.fields),n.upsertKeys=m.length>0?m:Object.values(c.primaryKeys).map(A=>A.field)}n.returning&&Array.isArray(n.returning)&&(n.returning=n.returning.map(m=>l.get(c.rawAttributes[m],"field",m)));const b=await c.queryInterface.bulkInsert(c.getTableName(n),e,n,d);Array.isArray(b)&&b.forEach((m,w)=>{const A=u[w];for(const _ in m)if(!(!A||_===c.primaryKeyAttribute&&A.get(c.primaryKeyAttribute)&&["mysql","mariadb","sqlite"].includes(s))&&Object.prototype.hasOwnProperty.call(m,_)){const f=m[_],p=l.find(c.rawAttributes,O=>O.fieldName===_||O.field===_);A.dataValues[p&&p.fieldName||_]=f}})}return n.include&&n.include.length&&await Promise.all(n.include.filter(d=>!(d.association instanceof z||d.parent&&d.parent.association instanceof T)).map(async d=>{const b=[],m=[];for(const _ of u){let f=_.get(d.as);Array.isArray(f)||(f=[f]);for(const p of f)p&&(d.association instanceof T||(p.set(d.association.foreignKey,_.get(d.association.sourceKey||_.constructor.primaryKeyAttribute,{raw:!0}),{raw:!0}),Object.assign(p,d.association.scope)),b.push(p),m.push(_))}if(!b.length)return;const w=l(h.cloneDeep(d)).omit(["association"]).defaults({transaction:n.transaction,logging:n.logging}).value(),A=await i(b,w);if(d.association instanceof T){const _=[];for(const O in A){const q=A[O],V=m[O],E=y({[d.association.foreignKey]:V.get(V.constructor.primaryKeyAttribute,{raw:!0}),[d.association.otherKey]:q.get(q.constructor.primaryKeyAttribute,{raw:!0})},d.association.through.scope);if(q[d.association.through.model.name])for(const K of Object.keys(d.association.through.model.rawAttributes))d.association.through.model.rawAttributes[K]._autoGenerated||K===d.association.foreignKey||K===d.association.otherKey||typeof q[d.association.through.model.name][K]===void 0||(E[K]=q[d.association.through.model.name][K]);_.push(E)}const f=l(h.cloneDeep(d)).omit(["association","attributes"]).defaults({transaction:n.transaction,logging:n.logging}).value();f.model=d.association.throughModel;const p=d.association.throughModel.bulkBuild(_,f);await i(p,f)}})),u.forEach(d=>{for(const b in c.rawAttributes)c.rawAttributes[b].field&&d.dataValues[c.rawAttributes[b].field]!==void 0&&c.rawAttributes[b].field!==b&&(d.dataValues[b]=d.dataValues[c.rawAttributes[b].field],delete d.dataValues[c.rawAttributes[b].field]),d._previousDataValues[b]=d.dataValues[b],d.changed(b,!1);d.isNewRecord=!1}),n.hooks&&await c.runHooks("afterBulkCreate",u,n),u},"recursiveBulkCreate");return await i(r,t)}static async truncate(e){return e=h.cloneDeep(e)||{},e.truncate=!0,await this.destroy(e)}static async destroy(e){if(e=h.cloneDeep(e),this._injectScope(e),!e||!(e.where||e.truncate))throw new Error("Missing where or truncate attribute in the options parameter of model.destroy.");if(!e.truncate&&!l.isPlainObject(e.where)&&!Array.isArray(e.where)&&!(e.where instanceof h.SequelizeMethod))throw new Error("Expected plain object, array or sequelize method in the options.where parameter of model.destroy.");e=l.defaults(e,{hooks:!0,individualHooks:!1,force:!1,cascade:!1,restartIdentity:!1}),e.type=P.BULKDELETE,h.mapOptionFieldNames(e,this),e.model=this,e.hooks&&await this.runHooks("beforeBulkDestroy",e);let t;e.individualHooks&&(t=await this.findAll({where:e.where,transaction:e.transaction,logging:e.logging,benchmark:e.benchmark}),await Promise.all(t.map(a=>this.runHooks("beforeDestroy",a,e))));let s;if(this._timestampAttributes.deletedAt&&!e.force){e.type=P.BULKUPDATE;const a={},r=this.rawAttributes[this._timestampAttributes.deletedAt],i=this.rawAttributes[this._timestampAttributes.deletedAt].field,u={[i]:Object.prototype.hasOwnProperty.call(r,"defaultValue")?r.defaultValue:null};a[i]=h.now(this.sequelize.options.dialect),s=await this.queryInterface.bulkUpdate(this.getTableName(e),a,Object.assign(u,e.where),e,this.rawAttributes)}else s=await this.queryInterface.bulkDelete(this.getTableName(e),e.where,e,this);return e.individualHooks&&await Promise.all(t.map(a=>this.runHooks("afterDestroy",a,e))),e.hooks&&await this.runHooks("afterBulkDestroy",e),s}static async restore(e){if(!this._timestampAttributes.deletedAt)throw new Error("Model is not paranoid");e=y({hooks:!0,individualHooks:!1},e),e.type=P.RAW,e.model=this,h.mapOptionFieldNames(e,this),e.hooks&&await this.runHooks("beforeBulkRestore",e);let t;e.individualHooks&&(t=await this.findAll({where:e.where,transaction:e.transaction,logging:e.logging,benchmark:e.benchmark,paranoid:!1}),await Promise.all(t.map(n=>this.runHooks("beforeRestore",n,e))));const s={},a=this._timestampAttributes.deletedAt,r=this.rawAttributes[a],i=Object.prototype.hasOwnProperty.call(r,"defaultValue")?r.defaultValue:null;s[r.field||a]=i,e.omitNull=!1;const u=await this.queryInterface.bulkUpdate(this.getTableName(e),s,e.where,e,this.rawAttributes);return e.individualHooks&&await Promise.all(t.map(n=>this.runHooks("afterRestore",n,e))),e.hooks&&await this.runHooks("afterBulkRestore",e),u}static async update(e,t){if(t=h.cloneDeep(t),this._injectScope(t),this._optionsMustContainWhere(t),t=this._paranoidClause(this,l.defaults(t,{validate:!0,hooks:!0,individualHooks:!1,returning:!1,force:!1,sideEffects:!0})),t.type=P.BULKUPDATE,e=l.omitBy(e,u=>u===void 0),t.fields&&t.fields instanceof Array)for(const u of Object.keys(e))t.fields.includes(u)||delete e[u];else{const u=this._timestampAttributes.updatedAt;t.fields=l.intersection(Object.keys(e),Object.keys(this.tableAttributes)),u&&!t.fields.includes(u)&&t.fields.push(u)}this._timestampAttributes.updatedAt&&!t.silent&&(e[this._timestampAttributes.updatedAt]=this._getDefaultTimestamp(this._timestampAttributes.updatedAt)||h.now(this.sequelize.options.dialect)),t.model=this;let s;if(t.validate){const u=this.build(e);u.set(this._timestampAttributes.updatedAt,e[this._timestampAttributes.updatedAt],{raw:!0}),t.sideEffects&&(Object.assign(e,l.pick(u.get(),u.changed())),t.fields=l.union(t.fields,Object.keys(e))),t.skip=l.difference(Object.keys(this.rawAttributes),Object.keys(e));const n=await u.validate(t);t.skip=void 0,n&&n.dataValues&&(e=l.pick(n.dataValues,Object.keys(e)))}t.hooks&&(t.attributes=e,await this.runHooks("beforeBulkUpdate",t),e=t.attributes,delete t.attributes),s=e;let a,r=!1;if(t.individualHooks&&(a=await this.findAll({where:t.where,transaction:t.transaction,logging:t.logging,benchmark:t.benchmark,paranoid:t.paranoid}),a.length)){let u,n=!1;if(a=await Promise.all(a.map(async c=>{if(Object.assign(c.dataValues,e),l.forIn(s,(o,g)=>{o!==c._previousDataValues[g]&&c.setDataValue(g,o)}),await this.runHooks("beforeUpdate",c,t),!n){const o={};l.forIn(c.dataValues,(g,d)=>{g!==c._previousDataValues[d]&&(o[d]=g)}),u?n=!l.isEqual(u,o):u=o}return c})),n)a=await Promise.all(a.map(async c=>{const o=N(y({},t),{hooks:!1,validate:!1});return delete o.individualHooks,c.save(o)})),r=!0;else{const c=Object.keys(u);c.length&&(s=u,t.fields=l.union(t.fields,c))}}let i;if(r)i=[a.length,a];else if(l.isEmpty(s)||Object.keys(s).length===1&&s[this._timestampAttributes.updatedAt])i=[0];else{s=h.mapValueFieldNames(s,t.fields,this),t=h.mapOptionFieldNames(t,this),t.hasTrigger=this.options?this.options.hasTrigger:!1;const u=await this.queryInterface.bulkUpdate(this.getTableName(t),s,t.where,t,this.tableAttributes);t.returning?(i=[u.length,u],a=u):i=[u]}return t.individualHooks&&(await Promise.all(a.map(u=>this.runHooks("afterUpdate",u,t))),i[1]=a),t.hooks&&(t.attributes=e,await this.runHooks("afterBulkUpdate",t),delete t.attributes),i}static async describe(e,t){return await this.queryInterface.describeTable(this.tableName,y({schema:e||this._schema||void 0},t))}static _getDefaultTimestamp(e){if(!!this.rawAttributes[e]&&!!this.rawAttributes[e].defaultValue)return h.toDefaultValue(this.rawAttributes[e].defaultValue,this.sequelize.options.dialect)}static _expandAttributes(e){if(!l.isPlainObject(e.attributes))return;let t=Object.keys(this.rawAttributes);e.attributes.exclude&&(t=t.filter(s=>!e.attributes.exclude.includes(s))),e.attributes.include&&(t=t.concat(e.attributes.include)),e.attributes=t}static _injectScope(e){const t=h.cloneDeep(this._scope);this._defaultsOptions(e,t)}static[Symbol.for("nodejs.util.inspect.custom")](){return this.name}static hasAlias(e){return Object.prototype.hasOwnProperty.call(this.associations,e)}static async increment(e,t){t=t||{},typeof e=="string"&&(e=[e]),Array.isArray(e)&&(e=e.map(o=>this.rawAttributes[o]&&this.rawAttributes[o].field&&this.rawAttributes[o].field!==o?this.rawAttributes[o].field:o)),this._injectScope(t),this._optionsMustContainWhere(t),t=h.defaults({},t,{by:1,where:{},increment:!0});const s=!t.increment;h.mapOptionFieldNames(t,this);const a=y({},t.where);let r={};if(Array.isArray(e)){r={};for(const o of e)r[o]=t.by}else r=e;this._versionAttribute&&(r[this._versionAttribute]=s?-1:1);const i={},u=this._timestampAttributes.updatedAt;if(!t.silent&&u&&!r[u]){const o=this.rawAttributes[u].field||u;i[o]=this._getDefaultTimestamp(u)||h.now(this.sequelize.options.dialect)}const n=this.getTableName(t);let c;return s?c=await this.queryInterface.decrement(this,n,a,r,i,t):c=await this.queryInterface.increment(this,n,a,r,i,t),t.returning?[c,c.length]:[c]}static async decrement(e,t){return this.increment(e,N(y({by:1},t),{increment:!1}))}static _optionsMustContainWhere(e){C(e&&e.where,"Missing where attribute in the options parameter"),C(l.isPlainObject(e.where)||Array.isArray(e.where)||e.where instanceof h.SequelizeMethod,"Expected plain object, array or sequelize method in the options.where parameter")}where(e){const t=this.constructor.primaryKeyAttributes.reduce((a,r)=>(a[r]=this.get(r,{raw:!0}),a),{});if(l.size(t)===0)return this.constructor.options.whereCollection;const s=this.constructor._versionAttribute;return e&&s&&(t[s]=this.get(s,{raw:!0})),h.mapWhereFieldNames(t,this.constructor)}toString(){return`[object SequelizeInstance:${this.constructor.name}]`}getDataValue(e){return this.dataValues[e]}setDataValue(e,t){const s=this._previousDataValues[e];l.isEqual(t,s)||this.changed(e,!0),this.dataValues[e]=t}get(e,t){if(t===void 0&&typeof e=="object"&&(t=e,e=void 0),t=t||{},e)return Object.prototype.hasOwnProperty.call(this._customGetters,e)&&!t.raw?this._customGetters[e].call(this,e,t):t.plain&&this._options.include&&this._options.includeNames.includes(e)?Array.isArray(this.dataValues[e])?this.dataValues[e].map(s=>s.get(t)):this.dataValues[e]instanceof D?this.dataValues[e].get(t):this.dataValues[e]:this.dataValues[e];if(this._hasCustomGetters||t.plain&&this._options.include||t.clone){const s={};let a;if(this._hasCustomGetters)for(a in this._customGetters)this._options.attributes&&!this._options.attributes.includes(a)||Object.prototype.hasOwnProperty.call(this._customGetters,a)&&(s[a]=this.get(a,t));for(a in this.dataValues)!Object.prototype.hasOwnProperty.call(s,a)&&Object.prototype.hasOwnProperty.call(this.dataValues,a)&&(s[a]=this.get(a,t));return s}return this.dataValues}set(e,t,s){let a,r;if(typeof e=="object"&&e!==null){if(a=e,s=t||{},s.reset){this.dataValues={};for(const i in a)this.changed(i,!1)}if(s.raw&&!(this._options&&this._options.include)&&!(s&&s.attributes)&&!this.constructor._hasDateAttributes&&!this.constructor._hasBooleanAttributes)Object.keys(this.dataValues).length?Object.assign(this.dataValues,a):this.dataValues=a,this._previousDataValues=y({},this.dataValues);else{if(s.attributes){const i=v(u=>{for(const n of u)a[n]!==void 0&&this.set(n,a[n],s)},"setKeys");i(s.attributes),this.constructor._hasVirtualAttributes&&i(this.constructor._virtualAttributes),this._options.includeNames&&i(this._options.includeNames)}else for(const i in a)this.set(i,a[i],s);s.raw&&(this._previousDataValues=y({},this.dataValues))}return this}if(s||(s={}),s.raw||(r=this.dataValues[e]),!s.raw&&this._customSetters[e]){this._customSetters[e].call(this,t,e);const i=this.dataValues[e];l.isEqual(i,r)||(this._previousDataValues[e]=r,this.changed(e,!0))}else{if(this._options&&this._options.include&&this._options.includeNames.includes(e))return this._setInclude(e,t,s),this;if(!s.raw){if(!this._isAttribute(e)){if(e.includes(".")&&this.constructor._jsonAttributes.has(e.split(".")[0])){const i=x.get(this.dataValues,e);l.isEqual(i,t)||(x.set(this.dataValues,e,t),this.changed(e.split(".")[0],!0))}return this}if(this.constructor._hasPrimaryKeys&&r&&this.constructor._isPrimaryKey(e))return this;if(!this.isNewRecord&&this.constructor._hasReadOnlyAttributes&&this.constructor._readOnlyAttributes.has(e))return this}!(t instanceof h.SequelizeMethod)&&Object.prototype.hasOwnProperty.call(this.constructor._dataTypeSanitizers,e)&&(t=this.constructor._dataTypeSanitizers[e].call(this,t,s)),!s.raw&&(t instanceof h.SequelizeMethod||!(t instanceof h.SequelizeMethod)&&this.constructor._dataTypeChanges[e]&&this.constructor._dataTypeChanges[e].call(this,t,r,s)||!this.constructor._dataTypeChanges[e]&&!l.isEqual(t,r))&&(this._previousDataValues[e]=r,this.changed(e,!0)),this.dataValues[e]=t}return this}setAttributes(e){return this.set(e)}changed(e,t){return e===void 0?this._changed.size>0?Array.from(this._changed):!1:t===!0?(this._changed.add(e),this):t===!1?(this._changed.delete(e),this):this._changed.has(e)}previous(e){return e?this._previousDataValues[e]:l.pickBy(this._previousDataValues,(t,s)=>this.changed(s))}_setInclude(e,t,s){Array.isArray(t)||(t=[t]),t[0]instanceof D&&(t=t.map(o=>o.dataValues));const a=this._options.includeMap[e],r=a.association,i=e,u=a.model.primaryKeyAttribute,n={isNewRecord:this.isNewRecord,include:a.include,includeNames:a.includeNames,includeMap:a.includeMap,includeValidated:!0,raw:s.raw,attributes:a.originalAttributes};let c;(a.originalAttributes===void 0||a.originalAttributes.length)&&(r.isSingleAssociation?(Array.isArray(t)&&(t=t[0]),c=t&&t[u]===null||t===null,this[i]=this.dataValues[i]=c?null:a.model.build(t,n)):(c=t[0]&&t[0][u]===null,this[i]=this.dataValues[i]=c?[]:a.model.bulkBuild(t,n)))}async save(e){if(arguments.length>1)throw new Error("The second argument was removed in favor of the options object.");e=h.cloneDeep(e),e=l.defaults(e,{hooks:!0,validate:!0}),e.fields||(this.isNewRecord?e.fields=Object.keys(this.constructor.rawAttributes):e.fields=l.intersection(this.changed(),Object.keys(this.constructor.rawAttributes)),e.defaultFields=e.fields),e.returning===void 0&&(e.association?e.returning=!1:this.isNewRecord&&(e.returning=!0));const t=this.constructor.primaryKeyAttribute,s=t&&this.constructor.rawAttributes[t],a=this.constructor._timestampAttributes.createdAt,r=this.constructor._versionAttribute,i=this.isNewRecord?"Create":"Update",u=this.isNewRecord,n=h.now(this.sequelize.options.dialect);let c=this.constructor._timestampAttributes.updatedAt;if(c&&e.fields.length>0&&!e.fields.includes(c)&&e.fields.push(c),r&&e.fields.length>0&&!e.fields.includes(r)&&e.fields.push(r),e.silent===!0&&!(this.isNewRecord&&this.get(c,{raw:!0}))&&(l.remove(e.fields,f=>f===c),c=!1),this.isNewRecord===!0&&(a&&!e.fields.includes(a)&&e.fields.push(a),s&&s.defaultValue&&!e.fields.includes(t)&&e.fields.unshift(t)),this.isNewRecord===!1&&t&&this.get(t,{raw:!0})===void 0)throw new Error("You attempted to save an instance with no primary key, this is not allowed since it would result in a global update");if(c&&!e.silent&&e.fields.includes(c)&&(this.dataValues[c]=this.constructor._getDefaultTimestamp(c)||n),this.isNewRecord&&a&&!this.dataValues[a]&&(this.dataValues[a]=this.constructor._getDefaultTimestamp(a)||n),e.validate&&await this.validate(e),e.hooks){const f=l.pick(this.dataValues,e.fields);let p=l.difference(this.changed(),e.fields),O,q;if(c&&e.fields.includes(c)&&(p=l.without(p,c)),await this.constructor.runHooks(`before${i}`,this,e),e.defaultFields&&!this.isNewRecord){q=l.pick(this.dataValues,l.difference(this.changed(),p)),O=[];for(const V of Object.keys(q))q[V]!==f[V]&&O.push(V);e.fields=l.uniq(e.fields.concat(O))}O&&e.validate&&(e.skip=l.difference(Object.keys(this.constructor.rawAttributes),O),await this.validate(e),delete e.skip)}if(e.fields.length&&this.isNewRecord&&this._options.include&&this._options.include.length&&await Promise.all(this._options.include.filter(f=>f.association instanceof z).map(async f=>{const p=this.get(f.as);if(!p)return;const O=l(h.cloneDeep(f)).omit(["association"]).defaults({transaction:e.transaction,logging:e.logging,parentRecord:this}).value();await p.save(O),await this[f.association.accessors.set](p,{save:!1,logging:e.logging})})),!e.fields.filter(f=>!this.constructor._virtualAttributes.has(f)).length)return this;if(!this.changed()&&!this.isNewRecord)return this;const g=l.get(this.constructor.rawAttributes[r],"field")||r,d=h.mapValueFieldNames(this.dataValues,e.fields,this.constructor);let b=null,m=[],w;this.isNewRecord?(b="insert",m=[this,this.constructor.getTableName(e),d,e]):(w=this.where(!0),r&&(d[g]=parseInt(d[g],10)+1),b="update",m=[this,this.constructor.getTableName(e),d,w,e]);const[A,_]=await this.constructor.queryInterface[b](...m);if(r){if(_<1)throw new k.OptimisticLockError({modelName:this.constructor.name,values:d,where:w});A.dataValues[r]=d[g]}for(const f of Object.keys(this.constructor.rawAttributes))this.constructor.rawAttributes[f].field&&d[this.constructor.rawAttributes[f].field]!==void 0&&this.constructor.rawAttributes[f].field!==f&&(d[f]=d[this.constructor.rawAttributes[f].field],delete d[this.constructor.rawAttributes[f].field]);Object.assign(d,A.dataValues),Object.assign(A.dataValues,d),u&&this._options.include&&this._options.include.length&&await Promise.all(this._options.include.filter(f=>!(f.association instanceof z||f.parent&&f.parent.association instanceof T)).map(async f=>{let p=this.get(f.as);if(!p)return;Array.isArray(p)||(p=[p]);const O=l(h.cloneDeep(f)).omit(["association"]).defaults({transaction:e.transaction,logging:e.logging,parentRecord:this}).value();await Promise.all(p.map(async q=>{if(f.association instanceof T){await q.save(O);const V=y({[f.association.foreignKey]:this.get(this.constructor.primaryKeyAttribute,{raw:!0}),[f.association.otherKey]:q.get(q.constructor.primaryKeyAttribute,{raw:!0})},f.association.through.scope);if(q[f.association.through.model.name])for(const E of Object.keys(f.association.through.model.rawAttributes))f.association.through.model.rawAttributes[E]._autoGenerated||E===f.association.foreignKey||E===f.association.otherKey||typeof q[f.association.through.model.name][E]===void 0||(V[E]=q[f.association.through.model.name][E]);await f.association.throughModel.create(V,O)}else q.set(f.association.foreignKey,this.get(f.association.sourceKey||this.constructor.primaryKeyAttribute,{raw:!0}),{raw:!0}),Object.assign(q,f.association.scope),await q.save(O)}))})),e.hooks&&await this.constructor.runHooks(`after${i}`,A,e);for(const f of e.fields)A._previousDataValues[f]=A.dataValues[f],this.changed(f,!1);return this.isNewRecord=!1,A}async reload(e){e=h.defaults({where:this.where()},e,{include:this._options.include||void 0});const t=await this.constructor.findOne(e);if(!t)throw new k.InstanceError("Instance could not be reloaded because it does not exist anymore (find call returned null)");return this._options=t._options,this.set(t.dataValues,{raw:!0,reset:!e.attributes}),this}async validate(e){return new Q(this,e).validate()}async update(e,t){e=l.omitBy(e,u=>u===void 0);const s=this.changed()||[];t=t||{},Array.isArray(t)&&(t={fields:t}),t=h.cloneDeep(t);const a=h.cloneDeep(t);a.attributes=t.fields,this.set(e,a);const r=l.without(this.changed(),...s),i=l.union(Object.keys(e),r);return t.fields||(t.fields=l.intersection(i,this.changed()),t.defaultFields=t.fields),await this.save(t)}async destroy(e){e=y({hooks:!0,force:!1},e),e.hooks&&await this.constructor.runHooks("beforeDestroy",this,e);const t=this.where(!0);let s;if(this.constructor._timestampAttributes.deletedAt&&e.force===!1){const a=this.constructor._timestampAttributes.deletedAt,r=this.constructor.rawAttributes[a],i=Object.prototype.hasOwnProperty.call(r,"defaultValue")?r.defaultValue:null,u=this.getDataValue(a);(u==null&&i==null||l.isEqual(u,i))&&this.setDataValue(a,new Date),s=await this.save(N(y({},e),{hooks:!1}))}else s=await this.constructor.queryInterface.delete(this,this.constructor.getTableName(e),t,y({type:P.DELETE,limit:null},e));return e.hooks&&await this.constructor.runHooks("afterDestroy",this,e),s}isSoftDeleted(){if(!this.constructor._timestampAttributes.deletedAt)throw new Error("Model is not paranoid");const e=this.constructor.rawAttributes[this.constructor._timestampAttributes.deletedAt],t=Object.prototype.hasOwnProperty.call(e,"defaultValue")?e.defaultValue:null;return(this.get(this.constructor._timestampAttributes.deletedAt)||null)!==t}async restore(e){if(!this.constructor._timestampAttributes.deletedAt)throw new Error("Model is not paranoid");e=y({hooks:!0,force:!1},e),e.hooks&&await this.constructor.runHooks("beforeRestore",this,e);const t=this.constructor._timestampAttributes.deletedAt,s=this.constructor.rawAttributes[t],a=Object.prototype.hasOwnProperty.call(s,"defaultValue")?s.defaultValue:null;this.setDataValue(t,a);const r=await this.save(N(y({},e),{hooks:!1,omitNull:!1}));return e.hooks&&await this.constructor.runHooks("afterRestore",this,e),r}async increment(e,t){const s=this.where();return t=h.cloneDeep(t),t.where=y(y({},t.where),s),t.instance=this,await this.constructor.increment(e,t),this}async decrement(e,t){return this.increment(e,N(y({by:1},t),{increment:!1}))}equals(e){return!e||!e.constructor||!(e instanceof this.constructor)?!1:this.constructor.primaryKeyAttributes.every(t=>this.get(t,{raw:!0})===e.get(t,{raw:!0}))}equalsOneOf(e){return e.some(t=>this.equals(t))}setValidators(e,t){this.validators[e]=t}toJSON(){return l.cloneDeep(this.get({plain:!0}))}static hasMany(e,t){}static belongsToMany(e,t){}static hasOne(e,t){}static belongsTo(e,t){}}v(D,"Model"),Object.assign(D,Y),J.applyTo(D,!0),module.exports=D;
//# sourceMappingURL=model.js.map
